/*******************************************************************************
  MAC Associate Source

  File Name:
    mac_associate.c
  Summary:
    Functionality required for Association
  Description:
    This file Implements the functionality required for Association.

 *******************************************************************************/

//DOM-IGNORE-BEGIN
/*******************************************************************************
* Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
*
* Subject to your compliance with these terms, you may use Microchip software
* and any derivatives exclusively with Microchip products. It is your
* responsibility to comply with third party license terms applicable to your
* use of third party software (including open source software) that may
* accompany Microchip software.
*
* THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
* EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
* WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
* PARTICULAR PURPOSE.
*
* IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
* INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
* WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
* BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
* FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
* ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
* THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 *******************************************************************************/
//DOM-IGNORE-END

/* === Includes ============================================================= */
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include "pal.h"
#include "bmm.h"
#include "qmm.h"
#include "phy.h"
#include "ieee_mac_const.h"
#include "mac_msg_const.h"
#include "mac_api.h"
#include "mac_msg_types.h"
#include "mac_data_structures.h"
#include "stack_config.h"
#include "mac_internal.h"
#include "mac.h"
#include "mac_config.h"
#include "mac_tasks.h"

/* === Macros =============================================================== */

/* Payload length of association request frame. */
#define ASSOC_REQ_PAYLOAD_LEN           (2)

/* Payload length of association response frame. */
#define ASSOC_RESP_PAYLOAD_LEN          (4)

/* === Globals ============================================================== */

/* === Prototypes =========================================================== */

/* === Implementation ======================================================= */

#if (MAC_ASSOCIATION_REQUEST_CONFIRM == 1)

/*
 * @brief Initiates MLME associate confirm message
 *
 * This function creates and appends a MLME associate confirm message
 * into the  internal event queue.
 *
 * @param buf_ptr Buffer for sending MLME associate confirm message to NHLE
 * @param status Status of association
 * @param assoc_short_addr Allocated short address
 */
void MAC_GenMLMEAssociateConf(buffer_t *bufPtr,
		uint8_t status,
		uint16_t assocShortAddr)
{
    qmm_status_t qmmStatus  = QMM_QUEUE_FULL;
	/* Reuse the associate request buffer for associate confirm. */
	MLME_AssociateConf_t *assocConf
		= (MLME_AssociateConf_t *)MAC_BUFFER_POINTER(bufPtr);

	assocConf->cmdcode = MLME_ASSOCIATE_CONFIRM;
	assocConf->status = status;
	assocConf->AssocShortAddress = assocShortAddr;

	/* Append the associate confirm message to MAC-NHLE queue. */
	qmmStatus = qmm_queue_append(&macNhleQueue, bufPtr);
    WPAN_PostTask();
    (void)qmmStatus;
}

#endif /* (MAC_ASSOCIATION_REQUEST_CONFIRM == 1) */

#if (MAC_ASSOCIATION_REQUEST_CONFIRM == 1)

/**
 * @brief Handles the MLME associate request command from the NWK layer
 *
 * The MLME associate request primitive is generated by the next higher layer
 * of an unassociated device and issued to its MAC to request an association
 * with a coordinator.
 *
 * @param m Pointer to MLME association request parameters
 */
void MAC_MLME_AssociateRequest(void *m)
{
	MLME_AssociateReq_t mar;
    PHY_Retval_t chPageStatus, curChStatus;
    PHY_Retval_t phyStatus = PHY_FAILURE;
	(void)memcpy(((void *)&mar), (MAC_BUFFER_POINTER((buffer_t *)m)),
			sizeof(MLME_AssociateReq_t));

	/*
	 * Store the buffer which was received from the NHLE as it will be
	 * reused
	 * while sending MLME association confirmation to the NHLE.
	 */
	macConfBufPtr = m;

	if ((FCF_SHORT_ADDR != mar.CoordAddrMode) &&
			(FCF_LONG_ADDR != mar.CoordAddrMode)) {
		MAC_GenMLMEAssociateConf((buffer_t *)m,
				(uint8_t)MAC_INVALID_PARAMETER,
				INVALID_SHORT_ADDRESS);

		return;
	}

	if (FCF_SHORT_ADDR == mar.CoordAddrMode) {
		ADDR_COPY_DST_SRC_16(macPib.mac_CoordShortAddress,
				mar.CoordAddress.shortAddress);
	} else {
		ADDR_COPY_DST_SRC_64(macPib.mac_CoordExtendedAddress,
				mar.CoordAddress.longAddress);

		/*
		 * Since the coordinator used its extended address, we need to
		 * mark
		 * this also in its short address.
		 */
		macPib.mac_CoordShortAddress = MAC_NO_SHORT_ADDR_VALUE;
	}

	/* Set the PAN ID. */
	phyStatus = SetPhyPibInternal(macPANId, (void *)&mar.CoordPANId);

	MAC_TrxWakeup();

	/* Build the Association Request command frame. */
	uint8_t frameLen;
	uint8_t *framePtr;
	uint8_t *tempFramePtr;
	uint16_t fcf;
	uint16_t bcAddr = BROADCAST;
    PibValue_t pib_value;

	/*
	 * Use the mlme association request buffer for transmitting an
	 * association request frame.
	 */
	MAC_FrameInfo_t *assocReqFrame
		= (MAC_FrameInfo_t *)(MAC_BUFFER_POINTER((buffer_t *)m));
    

	assocReqFrame->msgType = ASSOCIATIONREQUEST;
	assocReqFrame->buffer_header = (buffer_t *)m;

	/* Get the payload pointer. */
	framePtr = tempFramePtr
				= (uint8_t *)assocReqFrame +
					LARGE_BUFFER_SIZE -
					ASSOC_REQ_PAYLOAD_LEN - 2; /* Add 2 octets for FCS */

	/* Update the payload field. */
	*framePtr++ = (uint8_t)ASSOCIATIONREQUEST;
	/* Build the capability info. */
	*framePtr = mar.CapabilityInformation;

	/* Get the payload pointer again to add the MHR. */
	framePtr = tempFramePtr;

	/* Update the length. */
	frameLen = ASSOC_REQ_PAYLOAD_LEN +
			2 + /* Add 2 octets for FCS */
			2 + /* 2 octets for Destination PAN-Id */
			2 + /* 2 octets for short Destination Address */
			2 + /* 2 octets for Source PAN-Id */
			8 + /* 8 octets for long Source Address */
			3; /* 3 octets DSN and FCF */

	/* Source address */
	framePtr -= 8;
    phyStatus = PHY_PibGet(macIeeeAddress, (uint8_t *)&pib_value);
    convert_64_bit_to_byte_array(pib_value.pib_value_64bit, framePtr);


	/* Source PAN-Id is broadcast PAN ID */
	framePtr -= 2;
	convert_16_bit_to_byte_array(bcAddr, framePtr);

	/* Destination address */
	if (FCF_SHORT_ADDR == mar.CoordAddrMode) {
		framePtr -= 2;
		convert_16_bit_to_byte_array(macPib.mac_CoordShortAddress,
				framePtr);

		fcf = FCF_SET_FRAMETYPE(FCF_FRAMETYPE_MAC_CMD) |
				FCF_SET_DEST_ADDR_MODE(FCF_SHORT_ADDR) |
				FCF_SET_SOURCE_ADDR_MODE(FCF_LONG_ADDR) |
				FCF_ACK_REQUEST;
	} else {
		framePtr -= 8;
		frameLen += 6U; /* Add further 6 octets for long Destination
		                 * Address */

		convert_64_bit_to_byte_array(macPib.mac_CoordExtendedAddress,
				framePtr);

		fcf = FCF_SET_FRAMETYPE(FCF_FRAMETYPE_MAC_CMD) |
				FCF_SET_DEST_ADDR_MODE(FCF_LONG_ADDR) |
				FCF_SET_SOURCE_ADDR_MODE(FCF_LONG_ADDR) |
				FCF_ACK_REQUEST;
	}

	/* Destination PAN-Id */
	framePtr -= 2;
    phyStatus = PHY_PibGet(macPANId, (uint8_t *)&pib_value);
    convert_16_bit_to_byte_array(pib_value.pib_value_16bit, framePtr);
    

	/* Set DSN. */
	framePtr--;
	*framePtr = macPib.mac_DSN++;

	/* Set the FCF. */
	framePtr -= 2;
	convert_spec_16_bit_to_byte_array(fcf, framePtr);

	/* First element shall be length of PHY frame. */
	framePtr--;
	*framePtr = frameLen;

	/* Finished building of frame. */
	assocReqFrame->mpdu = framePtr;
    (void)phyStatus;
    
	/* Set the channel page passed by the request. */
	chPageStatus = SetPhyPibInternal(phyCurrentPage,
			(void *)&(mar.ChannelPage));

	/* Set the channel passed by the request. */
	curChStatus = SetPhyPibInternal(phyCurrentChannel,
			(void *)&(mar.LogicalChannel));

	if ((PHY_SUCCESS == chPageStatus) && (PHY_SUCCESS == curChStatus)) {

		/*
		 * In Nonbeacon build the association request frame is
		 * transmitted
		 * with unslotted CSMA-CA and frame retry.
		 */
		phyStatus = sendFrame(assocReqFrame, CSMA_UNSLOTTED, true);

		if (PHY_SUCCESS == phyStatus) {
			MAKE_MAC_BUSY();
		} else {
			MAC_GenMLMEAssociateConf((buffer_t *)m,
					(uint8_t)MAC_CHANNEL_ACCESS_FAILURE,
					INVALID_SHORT_ADDRESS);

			/* Set radio to sleep if allowed */
			MAC_SleepTrans();
		}
	} else {
		MAC_GenMLMEAssociateConf((buffer_t *)m,
				(uint8_t)MAC_CHANNEL_ACCESS_FAILURE,
				INVALID_SHORT_ADDRESS);

		/* Set radio to sleep if allowed */
		MAC_SleepTrans();
	}
} /* MAC_MLME_AssociateRequest */

#endif /* (MAC_ASSOCIATION_REQUEST_CONFIRM == 1) */

#if (MAC_ASSOCIATION_INDICATION_RESPONSE == 1)

/**
 * @brief Processes a received association request command frame
 *
 * This function will process a received association request command frame and
 * generates a MLME associate indication to the NHLE.
 *
 * @param assoc_req Specifies a pointer to the received association request
 * frame
 */
void MAC_ProcessAssociateRequest(buffer_t *assocReq)
{
    qmm_status_t qmmStatus = QMM_QUEUE_FULL;
	/* Use the frame reception buffer for association indication. */
	MLME_AssociateInd_t *mai = (MLME_AssociateInd_t *)MAC_BUFFER_POINTER(
			assocReq);

	/*
	 * If the coordinator has macAssociationPermit set to false, and
	 * receives an
	 * association request command from a device, the command shall be
	 * ignored.
	 */
	if ((macPib.mac_AssociationPermit) == 0U) {
		bmm_buffer_free(assocReq);
		return;
	}

	/* Build the MLME association indication parameters. */
	ADDR_COPY_DST_SRC_64(mai->DeviceAddress,
			macParseData.srcAddr.longAddress);
	mai->CapabilityInformation
		= macParseData.macPayloadData.assocReqData.
			capabilityInfo;
	mai->cmdcode = MLME_ASSOCIATE_INDICATION;

	/* Append the MLME associate indication to the MAC-NHLE queue. */
	qmmStatus = qmm_queue_append(&macNhleQueue, assocReq);
    WPAN_PostTask();
    (void)qmmStatus;
}

#endif /* (MAC_ASSOCIATION_INDICATION_RESPONSE == 1) */

#if (MAC_ASSOCIATION_INDICATION_RESPONSE == 1)

/**
 * @brief Entry point from the stack for MLME associate response
 *
 * The MLME associate response primitive is used to initiate a response to a
 * MLME association indication primitive.
 *
 * @param m Pointer to association response parameters
 */
void MAC_MLME_AssociateResponse(void *m)
{
	uint8_t frameLen;
	uint8_t *framePtr;
	uint8_t *tempFramePtr;
	uint16_t fcf;
    PibValue_t pib_value;
    PHY_Retval_t pibStatus = PHY_FAILURE;
   
	MLME_AssociateResp_t mar;
	(void)memcpy(((void *)&mar), MAC_BUFFER_POINTER((buffer_t *)m), sizeof(MLME_AssociateResp_t));

	MAC_FrameInfo_t *assocRespFrame
		= (MAC_FrameInfo_t *)MAC_BUFFER_POINTER((buffer_t *)m);

	/*
	 * A MLME associate response can only be processed
	 * in the MAC_PAN_COORD_STARTED or MAC_COORDINATOR state.
	 */
	if ((MAC_PAN_COORD_STARTED != macState) &&
			(MAC_COORDINATOR != macState)
			) {
		bmm_buffer_free((buffer_t *)m);
		return;
	}

	/* Build the Association Response frame. */
	assocRespFrame->msgType = ASSOCIATIONRESPONSE;

	/* Get the payload pointer. */
	framePtr = tempFramePtr
				= (uint8_t *)assocRespFrame +
					LARGE_BUFFER_SIZE -
					ASSOC_RESP_PAYLOAD_LEN - 2; /* Add 2
	                                                             * octets
	                                                             * for
	                                                             * FCS. */

	/* Update the payload field. */
	*framePtr++ = (uint8_t)ASSOCIATIONRESPONSE;

	/* Add the short address allocated for the device. */
	convert_16_bit_to_byte_array(mar.AssocShortAddress, framePtr);
	framePtr += 2;

	/* Build the association status. */
	*framePtr = mar.status;

	/* Get the payload pointer again to add the MHR. */
	framePtr = tempFramePtr;

	/* Update the length. */
	frameLen = ASSOC_RESP_PAYLOAD_LEN +
			2 + /* Add 2 octets for FCS */
			2 + /* 2 octets for Destination PAN-Id */
			8 + /* 8 octets for long Destination Address */
			8 + /* 8 octets for long Source Address */
			3; /* 3 octets DSN and FCF */

	/* Source address */
	framePtr -= 8;
    pibStatus = PHY_PibGet(macIeeeAddress, (uint8_t *)&pib_value);
    convert_64_bit_to_byte_array(pib_value.pib_value_64bit, framePtr);


	/* Build the Destination address. */
	framePtr -= 8;
	convert_64_bit_to_byte_array(mar.DeviceAddress, framePtr);

	/* Build the Destination PAN ID. */
	framePtr -= 2;
    pibStatus = PHY_PibGet(macPANId, (uint8_t *)&pib_value);
    convert_16_bit_to_byte_array(pib_value.pib_value_16bit, framePtr);

	/* Set DSN. */
	framePtr--;
	*framePtr = macPib.mac_DSN++;

	/* Set the FCF. */
	/* Create the frame control field. */
	fcf = FCF_SET_FRAMETYPE(FCF_FRAMETYPE_MAC_CMD) |
			FCF_SET_DEST_ADDR_MODE(FCF_LONG_ADDR) |
			FCF_SET_SOURCE_ADDR_MODE(FCF_LONG_ADDR) |
			FCF_PAN_ID_COMPRESSION |
			FCF_ACK_REQUEST;
	framePtr -= 2;
	convert_spec_16_bit_to_byte_array(fcf, framePtr);

	/* First element shall be length of PHY frame. */
	framePtr--;
	*framePtr = frameLen;

	/* Finished building of frame. */
	assocRespFrame->mpdu = framePtr;

#if (MAC_INDIRECT_DATA_FFD == 1)
	/* Indirect transmission not ongoing yet. */
	assocRespFrame->indirectInTransit = false;
#endif  /* (MAC_INDIRECT_DATA_FFD == 1) */

	/* Append the association response into indirect queue. */
#ifdef ENABLE_QUEUE_CAPACITY
	if (QMM_QUEUE_FULL == qmm_queue_append(&indirectDataQueue, (buffer_t *)m)) {
		/*
		 * Indirect queue reached the maximum size allowed.
		 * Send the comm status indication with MAC transaction
		 * overflow.
		 */
		MAC_MLME_CommStatus((uint8_t)MAC_TRANSACTION_OVERFLOW,(buffer_t *)m);

		return;
	}

#else
	qmm_queue_append(&indirectDataQueue, (buffer_t *)m);
#endif  /* ENABLE_QUEUE_CAPACITY */

	/*
	 * If an FFD does have pending data,
	 * the MAC persistence timer needs to be started.
	 */
	assocRespFrame->persistenceTime = macPib.mac_TransactionPersistenceTime;
	MAC_CheckPersistenceTimer();
    WPAN_PostTask();
    (void)pibStatus;
} /* MAC_MLME_AssociateResponse */

#endif /* (MAC_ASSOCIATION_INDICATION_RESPONSE == 1) */

#if (MAC_ASSOCIATION_REQUEST_CONFIRM == 1)

/**
 * @brief Processing of an associaton reponse command frame
 *
 * This function processes the received association response
 * command frame.
 *
 * @param assoc_resp Association response receive buffer
 */
void MAC_ProcessAssociateResponse(buffer_t *assocResp)
{
	uint16_t panid;
	uint16_t shortAddr;

	uint8_t status = macParseData.macPayloadData.assocResponseData.assocStatus;
    PHY_Retval_t pibSetStatus = PHY_FAILURE;

	/* Free the buffer received for association response frame. */
	bmm_buffer_free(assocResp);

	if (ASSOCIATION_SUCCESSFUL == status) {
		/* Set the short address received in association response frame.
		**/
		pibSetStatus = SetPhyPibInternal(macShortAddress,
				(void *)&(macParseData.macPayloadData.
				assocResponseData.shortAddr));

		shortAddr
			= macParseData.macPayloadData.assocResponseData.
				shortAddr;

		ADDR_COPY_DST_SRC_64(macPib.mac_CoordExtendedAddress,
				macParseData.srcAddr.longAddress);

		/* Node is properly associated now */
		macState = MAC_ASSOCIATED;
		macPollState = MAC_POLL_IDLE;

		if (MAC_SYNC_BEFORE_ASSOC == macSyncState) {
			macSyncState = MAC_SYNC_TRACKING_BEACON;
		}
	} else {
		/* Restore the default values. */
		macPollState = MAC_POLL_IDLE;

		panid = macPANId_def;

		pibSetStatus = SetPhyPibInternal(macPANId, (void *)&panid);

		macPib.mac_CoordShortAddress = macCoordShortAddress_def;
		(void)memset((uint8_t *)&macPib.mac_CoordExtendedAddress, 0,
				sizeof(macPib.mac_CoordExtendedAddress));
		/* macPib.mac_CoordExtendedAddress = CLEAR_ADDR_64; */

		shortAddr = INVALID_SHORT_ADDRESS;
	}

	/*
	 * The MLME association request buffer is stored in mac_conf_buf_ptr,
	 * which is reused to generate MLME association confirmation.
	 */
	MAC_GenMLMEAssociateConf((buffer_t *)((void*)macConfBufPtr),
			status,
			shortAddr);

	/* Set radio to sleep if allowed */
	MAC_SleepTrans();
    (void)pibSetStatus;
} /* MAC_ProcessAssociateResponse */

#endif /* (MAC_ASSOCIATION_REQUEST_CONFIRM == 1) */

#if (MAC_ASSOCIATION_REQUEST_CONFIRM == 1)

/**
 * @brief Handle Timer_PollWaitTime timer after successful transmission of an
 *        association request frame and before sending out the subsequent
 *        data request frame.
 *
 * @param callbackParameter Callback parameter.
 */
void MAC_Timer_ResponseWaitCb(void *callbackParameter)
{
	uint32_t responseTimeUs;
	PAL_Status_t timerStatus;
	bool status;

	responseTimeUs = PHY_CONVERT_SYMBOLS_TO_US(
			macPib.mac_ResponseWaitTime);

	/*
	 * IEEE 802.15.4-2006 page 154:
	 *
	 * If the data request command is being sent following the
	 * acknowledgment
	 * to an association request command frame, the Destination Addressing
	 * Mode
	 * subfield of the Frame Control field shall be set according to the
	 * coordinator to which the data request command is directed.
	 * If macCoordShortAddress is equal to 0xfffe, extended addressing
	 * shall be used. Short addressing shall be used otherwise.
	 * The Source Addressing Mode subfield shall be set to use
	 * extended addressing.
	 */

	/*
	 * No explicit destination address attached, so use current values of
	 * PIB attributes macCoordShortAddress or macCoordExtendedAddress.
	 */
	status = MAC_BuildAndTxDataReq(false, true, 0, NULL, 0);

	if (!status) {
		/*
		 * Data request could not be transmitted, hence association
		 * confirmation
		 * is generated using the buffer stored in mac_conf_buf_ptr.
		 */
		MAC_GenMLMEAssociateConf((buffer_t *)((void*)macConfBufPtr),
				(uint8_t)MAC_CHANNEL_ACCESS_FAILURE,
				INVALID_SHORT_ADDRESS);
		return;
	}

	timerStatus = PAL_TimerStart(Timer_PollWaitTime,
			responseTimeUs,
			TIMEOUT_RELATIVE,
			&MAC_Timer_AssocresponsetimeCb, NULL,CALLBACK_SINGLE);

	if (PAL_SUCCESS != timerStatus) {
		/* Timer could not be started. */
		MAC_Timer_AssocresponsetimeCb(NULL);
	}

	callbackParameter = callbackParameter; /* Keep compiler happy. */
}

#endif /* (MAC_ASSOCIATION_REQUEST_CONFIRM == 1) */

#if (MAC_ASSOCIATION_REQUEST_CONFIRM == 1)

/*
 * @brief Handle Timer_PollWaitTime while waiting for the association reponse
 * frame
 *
 * @param callbackParameter Callback parameter
 */
void MAC_Timer_AssocresponsetimeCb(void *callbackParameter)
{
	uint16_t panid;
    PHY_Retval_t pibSetStatus = PHY_FAILURE;

	/*
	 * Association response is not received within time, hence generate
	 * mlme association confirm with MAC_NO_DATA using the buffer stored in
	 * mac_conf_buf_ptr.
	 */
	MAC_GenMLMEAssociateConf((buffer_t *)((void*)macConfBufPtr),
			(uint8_t)MAC_NO_DATA,
			BROADCAST);

	/* Restore the mac poll state in case of association failure. */
	macPollState = MAC_POLL_IDLE;

	/* Set the default parameters. */
	panid = macPANId_def;
	pibSetStatus = SetPhyPibInternal(macPANId, (void *)&panid);

	macPib.mac_CoordShortAddress = macCoordShortAddress_def;
	(void)memset((uint8_t *)&macPib.mac_CoordExtendedAddress, 0,
			sizeof(macPib.mac_CoordExtendedAddress));
	/* macPib.mac_CoordExtendedAddress = CLEAR_ADDR_64; */

	/* Set radio to sleep if allowed */
	MAC_SleepTrans();

	callbackParameter = callbackParameter; /* Keep compiler happy. */
    (void)pibSetStatus;
}

#endif /* (MAC_ASSOCIATION_REQUEST_CONFIRM == 1) */

/* EOF */
