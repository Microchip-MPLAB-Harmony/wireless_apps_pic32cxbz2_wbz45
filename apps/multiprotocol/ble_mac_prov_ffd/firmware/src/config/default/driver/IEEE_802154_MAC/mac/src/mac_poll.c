/*******************************************************************************
  MAC Poll Source

  File Name:
    mac_poll.c
  Summary:
    MLME-POLL.request handling
  Description:
    This file implements the MLME-POLL.request handling.

 *******************************************************************************/

//DOM-IGNORE-BEGIN
/*******************************************************************************
* Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
*
* Subject to your compliance with these terms, you may use Microchip software
* and any derivatives exclusively with Microchip products. It is your
* responsibility to comply with third party license terms applicable to your
* use of third party software (including open source software) that may
* accompany Microchip software.
*
* THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
* EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
* WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
* PARTICULAR PURPOSE.
*
* IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
* INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
* WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
* BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
* FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
* ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
* THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 *******************************************************************************/
//DOM-IGNORE-END

/* === Includes ============================================================ */
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include "pal.h"
#include "bmm.h"
#include "qmm.h"
#include "phy.h"
#include "ieee_mac_const.h"
#include "mac_msg_const.h"
#include "mac_api.h"
#include "mac_msg_types.h"
#include "mac_data_structures.h"
#include "stack_config.h"
#include "mac_internal.h"
#include "mac.h"
#include "mac_config.h"

#if (MAC_INDIRECT_DATA_BASIC == 1)

/* === Macros ============================================================== */

/* === Globals ============================================================= */

/* === Prototypes ========================================================== */

/* === Implementation ====================================================== */

/*
 * @brief Internal function to initiate mlme poll confirm message.
 *
 * @param buf_ptr Buffer to send poll confirmation to NHLE.
 * @param status MLME Poll request status.
 */
static void Gen_MLME_PollConf(buffer_t *bufPtr, uint8_t status)
{
    qmm_status_t  qmmStatus;
	MLME_PollConf_t *mpc = (MLME_PollConf_t *)MAC_BUFFER_POINTER(bufPtr);

	mpc->cmdcode = MLME_POLL_CONFIRM;
	mpc->status = status;

	/*
	 * Only go to sleep if poll is not successful,
	 * otherwise stay awake until subsequent evaluation of data frame
	 */
	if ((uint8_t)MAC_SUCCESS != status) {
		/* Set radio to sleep if allowed */
		MAC_SleepTrans();
	}

	qmmStatus = qmm_queue_append(&macNhleQueue, bufPtr);
    WPAN_PostTask();
    (void)qmmStatus;
}

/**
 * @brief Implements MLME-POLL.request
 *
 * This function handles an MLME-POLL.request primitive.
 * The MLME-POLL.request primitive is generated by the next
 * higher layer and issued to its MLME when data are to be
 * requested from a coordinator.
 *
 * @param m Pointer to the message
 */
void MAC_MLME_PollRequest(void *m)
{
	/*
	 * Polling for data is only allowed, if the node
	 * 1) is not a PAN coordinator,
	 * 2) is not polling already, and
	 * 3) is not scanning.
	 */
	if (
		(MAC_POLL_IDLE == macPollState) &&
#if (MAC_START_REQUEST_CONFIRM == 1)
		(MAC_PAN_COORD_STARTED != macState) &&
#endif  /* MAC_START_REQUEST_CONFIRM == 1) */
		(MAC_SCAN_IDLE == macScanState)
		) {
		bool status;
		AddressField_t coordAddr;

		/* Wake up radio first */
		MAC_TrxWakeup();

		/*
		 * Extract the Coordinator address information from the Poll
		 * request.
		 * This is required later for building the proper destination
		 * address
		 * information in the data request frame.
		 */
		MLME_PollReq_t *msg
			= (MLME_PollReq_t *)MAC_BUFFER_POINTER((buffer_t
				*)m);

		{
			uint8_t dataReqAddrMode;

			if (msg->CoordAddrMode == FCF_SHORT_ADDR) {
				dataReqAddrMode = FCF_SHORT_ADDR;
				ADDR_COPY_DST_SRC_16(coordAddr.shortAddress,
						((uint16_t)(msg->CoordAddress)));
			} else {
				dataReqAddrMode = FCF_LONG_ADDR;
				ADDR_COPY_DST_SRC_64(coordAddr.longAddress,
						msg->CoordAddress);
			}

			/* Build and transmit data request frame due to explicit
			 * poll request */
			status = MAC_BuildAndTxDataReq(true,
					false,
					dataReqAddrMode,
					&coordAddr,
					msg->CoordPANId);
		}

		if (status) {
			/* Store the poll request buffer to give poll confirm */
			macConfBufPtr = m;
		} else {
			Gen_MLME_PollConf((buffer_t *)m,
					(uint8_t)MAC_CHANNEL_ACCESS_FAILURE);
		}
	} else {
		Gen_MLME_PollConf((buffer_t *)m, (uint8_t)MAC_CHANNEL_ACCESS_FAILURE);
	}
}

/**
 * @brief Timer_PollWaitTime timer callback
 *
 * This function implements the Timer_PollWaitTime timer callback.
 * If a poll request is pending, a mlme-poll-confirm is generated.
 *
 * @param callbackParameter Callback parameter
 */
void MAC_Timer_PollWaitTimeCb(void *callbackParameter)
{
	if (MAC_POLL_EXPLICIT == macPollState) {
		/*
		 * Data is not received on time for the poll request, hence
		 * generate
		 * the poll confirm using the poll request buffer which was
		 * stored in
		 * mac_conf_buf_ptr.
		 */
		Gen_MLME_PollConf((buffer_t *)((void *)macConfBufPtr), (uint8_t)MAC_NO_DATA);
	}

	macPollState = MAC_POLL_IDLE;

	/* MAC was busy during poll. */
	MAKE_MAC_NOT_BUSY();

	callbackParameter = callbackParameter; /* Keep compiler happy. */
}

/**
 * @brief Processes a data response to an MLME-POLL.request
 *
 * This function processes a data response to an MLME-POLL.request.
 * Our coordinator has responded with a data frame. It is checked
 * whether any data has been received, and the appropriate
 * MLME-POLL.confirm message is constructed.
 */
void MAC_ProcessDataResponse(void)
{
	uint8_t status;
    PAL_Status_t palStatus;

	if (FCF_FRAMETYPE_BEACON == macParseData.frameType) {
		/*
		 * Node is currently in polling state, so only command or data
		 * frames
		 * are of interest.
		 * This is an unexpected frame type, do nothing.
		 * Note. Ack frames are not uploaded to this point.
		 * All subsequent actions are not to be done now.
		 * Instead the timer will expire and initiate the proper stuff.
		 */
		return;
	} else {
		/* Stop the MaxFrameResponseTime timer */
		palStatus = PAL_TimerStop(Timer_PollWaitTime);

		/*
		 * For received command frames (Association response or
		 * disassociation notification) and for data frames with zero
		 * payload length the potential status for the poll.confirm
		 * message
		 * is supposed to be "No data".
		 */
		status = (uint8_t)MAC_NO_DATA;

		if ((FCF_FRAMETYPE_DATA == macParseData.frameType) &&
				(macParseData.macPayloadLength > 0U)
				) {
			/*
			 * For received data frames with non-zero payload length
			 * the potential status for the poll.confirm message is
			 * supposed to be "Success".
			 */
			status = (uint8_t)MAC_SUCCESS;
		}
	}

	if (MAC_POLL_EXPLICIT == macPollState) {
		/*
		 * Data is received on explicit poll request, hence generate the
		 * poll confirm using
		 * the buffer which was stored in mac_conf_buf_ptr.
		 */
		Gen_MLME_PollConf((buffer_t *)((void *)macConfBufPtr), status);
	}

	/* MAC was busy during poll. */
	MAKE_MAC_NOT_BUSY();

	macPollState = MAC_POLL_IDLE;
    (void)palStatus;
} /* MAC_ProcessDataResponse() */

#endif /* (MAC_INDIRECT_DATA_BASIC == 1) */

/* EOF */
