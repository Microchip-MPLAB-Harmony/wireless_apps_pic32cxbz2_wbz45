/*******************************************************************************
  MAC Disassociate Source

  File Name:
    mac_disassociate.c
  Summary:
    MLME-DISASSOCIATION functionality
  Description:
    This file implements the MLME-DISASSOCIATION functionality.

 *******************************************************************************/

//DOM-IGNORE-BEGIN
/*******************************************************************************
* Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
*
* Subject to your compliance with these terms, you may use Microchip software
* and any derivatives exclusively with Microchip products. It is your
* responsibility to comply with third party license terms applicable to your
* use of third party software (including open source software) that may
* accompany Microchip software.
*
* THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
* EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
* WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
* PARTICULAR PURPOSE.
*
* IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
* INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
* WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
* BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
* FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
* ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
* THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 *******************************************************************************/
//DOM-IGNORE-END

/* === Includes ============================================================ */
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include "pal.h"
#include "bmm.h"
#include "qmm.h"
#include "phy.h"
#include "ieee_mac_const.h"
#include "mac_msg_const.h"
#include "mac_api.h"
#include "mac_msg_types.h"
#include "mac_data_structures.h"
#include "stack_config.h"
#include "mac_internal.h"
#include "mac.h"
#include "mac_config.h"
#include "mac_tasks.h"

#if (MAC_DISASSOCIATION_BASIC_SUPPORT == 1)

/* === Macros =============================================================== */

/*
 * Disassociation payload length
 */
#define DISASSOC_PAYLOAD_LEN             (2)

/* === Globals ============================================================= */

/* === Prototypes ========================================================== */

static bool MAC_AwakeDisassociate(buffer_t *bufPtr);

static void MAC_Gen_MLME_DisassociateConf(buffer_t *buf,
		uint8_t status,
		uint8_t devAddrMode,
		uint16_t devPanid,
		AddressField_t *devAddr);

/* === Implementation ====================================================== */

/**
 * @brief Initiates MLME disassociate confirm message
 *
 * This function creates and appends a MLME disassociate confirm message
 * into the  internal event queue.
 *
 * @param buf Buffer for sending MLME disassociate confirm message to NHLE
 * @param status Status of disassociation
 * @param dev_addr_mode Addressing mode of the device that has either requested
 *                      disassociation or been instructed to disassociate by
 *                      its coordinator.
 * @param dev_panid PAN identifier of the device that has either requested
 *                  disassociation or been instructed to disassociate by its
 *                  coordinator.
 * @param devAddr Address of the device that has either requested
 *                 disassociation or been instructed to disassociate by its
 *                 coordinator.
 */
static void MAC_Gen_MLME_DisassociateConf(buffer_t *buf,
		uint8_t status,
		uint8_t devAddrMode,
		uint16_t devPanid,
		AddressField_t *devAddr)
{
    qmm_status_t  qmmStatus = QMM_QUEUE_FULL;
	MLME_DisassociateConf_t *mdc;

	mdc = (MLME_DisassociateConf_t *)MAC_BUFFER_POINTER(buf);

	mdc->cmdcode = MLME_DISASSOCIATE_CONFIRM;
	mdc->status = status;
	mdc->DeviceAddrMode = devAddrMode;
	mdc->DevicePANId = devPanid;

	if (FCF_SHORT_ADDR == devAddrMode) {
		/* Clean-up of 64 bit address before writing 16 bit value. */
		mdc->DeviceAddress = 0;
		/* A short device address is requested. */
		ADDR_COPY_DST_SRC_16(mdc->DeviceAddress,
				devAddr->shortAddress);
	} else {
		/* A long device address is requested. */
		ADDR_COPY_DST_SRC_64(mdc->DeviceAddress,
				devAddr->longAddress);
	}

	qmmStatus = qmm_queue_append(&macNhleQueue, (buffer_t *)buf);
    WPAN_PostTask();
    (void)qmmStatus;
}

/**
 * @brief Handles the MLME disassociate request command from the NWK layer
 *
 * The MLME-DISASSOCIATE.request primitive is generated by the next
 * higher layer of an associated device and issued to its MLME to
 * request disassociation from the PAN. It is also generated by the
 * next higher layer of the coordinator and issued to its MLME to
 * instruct an associated device to leave the PAN.
 *
 * @param m Pointer to the MLME-DISASSOCIATION.Request message passed by NHLE
 */
void MAC_MLME_DisassociateRequest(void *m)
{
	MLME_DisassociateReq_t disassocReq;
    PibValue_t pib_value;
    PHY_Retval_t pibStatus = PHY_FAILURE;

	MAC_FrameInfo_t *transmitFrame
		= (MAC_FrameInfo_t *)MAC_BUFFER_POINTER((buffer_t *)m);

	/* Store the disassociation request received from NHLE. */
	(void)memcpy((uint8_t *)&disassocReq, (uint8_t *)transmitFrame,
			sizeof(MLME_DisassociateReq_t));

    pibStatus = PHY_PibGet(macPANId, (uint8_t *)&pib_value);

	if (disassocReq.DevicePANId != pib_value.pib_value_16bit) {
		MAC_Gen_MLME_DisassociateConf((buffer_t *)m,
				(uint8_t)MAC_INVALID_PARAMETER,
				disassocReq.DeviceAddrMode,
				disassocReq.DevicePANId,
				(AddressField_t *)((void *)&disassocReq.DeviceAddress));
        (void)pibStatus;
		return;
	}

	/* Now build the actual disassociation command frame. */
	{
		uint8_t frameLen;
		uint8_t *framePtr;
		uint8_t *tempFramePtr;
		uint16_t fcf;

		transmitFrame->buffer_header = (buffer_t *)m;
		transmitFrame->msgType = DISASSOCIATIONNOTIFICATION;

		/* Get the payload pointer. */
		framePtr = tempFramePtr
					= (uint8_t *)transmitFrame +
						LARGE_BUFFER_SIZE -
						DISASSOC_PAYLOAD_LEN - 2; /* Add
		                                                           * 2
		                                                           *
		                                                           *
		                                                           *
		                                                           *octets
		                                                           * for
		                                                           *
		                                                           *
		                                                           *
		                                                           *FCS.
		                                                           **/

		/* Update the payload field. */
		*framePtr++ = (uint8_t)DISASSOCIATIONNOTIFICATION;

		/* Set up the disassociation reason code. */
		*framePtr = disassocReq.DisassociateReason;

		/* Get the payload pointer again to add the MHR. */
		framePtr = tempFramePtr;

		/* Update the length. */
		frameLen = DISASSOC_PAYLOAD_LEN +
				2 + /* Add 2 octets for FCS */
				2 + /* 2 octets for Destination PAN-Id */
				2 + /* 2 octets for short Destination Address */
				8 + /* 8 octets for long Source Address */
				3; /* 3 octets DSN and FCF */

		/* Source address */
		framePtr -= 8;
        pibStatus = PHY_PibGet(macIeeeAddress, (uint8_t *)&pib_value);
        convert_64_bit_to_byte_array(pib_value.pib_value_64bit, framePtr);


		/* Destination address */
		if (FCF_SHORT_ADDR == disassocReq.DeviceAddrMode) {
			framePtr -= 2;
			convert_16_bit_to_byte_address(
					((uint16_t)(disassocReq.DeviceAddress)), framePtr);
		} else {
			framePtr -= 8;
			frameLen += 6U;
			convert_64_bit_to_byte_array(disassocReq.DeviceAddress,
					framePtr);
		}

		/* Destination PAN-Id */
		framePtr -= 2;
        pibStatus = PHY_PibGet(macPANId, (uint8_t *)&pib_value);
        convert_16_bit_to_byte_array(pib_value.pib_value_16bit, framePtr);


		/* Set DSN. */
		framePtr--;
		*framePtr = macPib.mac_DSN++;

		/* Construct FCF. */
		/* 802.15.4-2006 sets the PAN-Id compression) bit. */
		fcf = FCF_SET_FRAMETYPE(FCF_FRAMETYPE_MAC_CMD) |
				FCF_SET_DEST_ADDR_MODE(
				disassocReq.DeviceAddrMode) |
				FCF_SET_SOURCE_ADDR_MODE(FCF_LONG_ADDR) |
				FCF_PAN_ID_COMPRESSION |
				FCF_ACK_REQUEST;

		/* Set the FCF. */
		framePtr -= 2;
		convert_spec_16_bit_to_byte_array(fcf, framePtr);

		/* First element shall be length of PHY frame. */
		framePtr--;
		*framePtr = frameLen;

		/* Finished building of frame. */
		transmitFrame->mpdu = framePtr;
	}
    (void)pibStatus;

#if (MAC_DISASSOCIATION_FFD_SUPPORT == 1)
	/* Indirect transmission not ongoing yet. */
	transmitFrame->indirectInTransit = false;

	if (
		((MAC_PAN_COORD_STARTED == macState) ||
		(MAC_COORDINATOR == macState)) &&
		(disassocReq.TxIndirect)
		) {
		/*
		 * The current device is a coordinator, and if the DeviceAddress
		 * is not ours, then send via indirect transmission.
		 */
		if (
			((disassocReq.DeviceAddrMode == WPAN_ADDRMODE_SHORT) &&
			(disassocReq.DeviceAddress != macCoordShortAddress)) ||
			((disassocReq.DeviceAddrMode == WPAN_ADDRMODE_LONG) &&
			(disassocReq.DeviceAddress !=
			macPib.mac_CoordExtendedAddress))
			) {
			/* Append the data into indirect queue. */
#ifdef ENABLE_QUEUE_CAPACITY
			if (QMM_QUEUE_FULL ==
					qmm_queue_append(&indirectDataQueue,
					(buffer_t *)m)) {
				/*
				 * If there is no capacity to store the
				 * transaction, the MLME
				 * will discard the MSDU and issue the
				 * MLME-DISASSOCIATE.
				 * confirm primitive with a status of
				 * TRANSACTION_OVERFLOW.
				 */
				MAC_Gen_MLME_DisassociateConf((buffer_t *)m,
						(uint8_t)MAC_TRANSACTION_OVERFLOW,
						disassocReq.DeviceAddrMode,
						disassocReq.DevicePANId,
						(AddressField_t *)((void *)&disassocReq.DeviceAddress));
				return;
			}

#else
			qmm_queue_append(&indirectDataQueue, (buffer_t *)m);
#endif  /* ENABLE_QUEUE_CAPACITY */

			/*
			 * If an FFD does have pending data,
			 * the MAC persistence timer needs to be started.
			 */
			transmitFrame->persistenceTime
				= macPib.mac_TransactionPersistenceTime;
			MAC_CheckPersistenceTimer();
            WPAN_PostTask();
		}

		else {
			MAC_Gen_MLME_DisassociateConf((buffer_t *)m,
					(uint8_t)MAC_INVALID_PARAMETER,
					disassocReq.DeviceAddrMode,
					disassocReq.DevicePANId,
					(AddressField_t *)((void *)&disassocReq.DeviceAddress));
			return;
		}
	} else /* Device */
#endif /* (MAC_DISASSOCIATION_FFD_SUPPORT == 1) */
	{
		bool transmission_status;

		/* Wake up the radio first */
		MAC_TrxWakeup();

		transmission_status = MAC_AwakeDisassociate((buffer_t *)m);

		if (!transmission_status) {
			/* Create the MLME DISASSOCIATION confirmation message
			**/
			MAC_Gen_MLME_DisassociateConf((buffer_t *)m,
					(uint8_t)MAC_CHANNEL_ACCESS_FAILURE,
					disassocReq.DeviceAddrMode,
					disassocReq.DevicePANId,
					(AddressField_t *)((void *)&disassocReq.DeviceAddress));

			/* Set radio to sleep if allowed */
			MAC_SleepTrans();
		}
	}
} /* MAC_MLME_DisassociateRequest() */

/*
 * @brief Continues handling MLME-DISASSOCIATE.request once the radio is awake
 *
 * This function sends the disassociation request information to TAL. On
 * sending the disassociation request all information about its parent device
 * is cleared.
 *
 * @param m Pointer to the buffer to be sent to TAL.
 *
 * @return True if the frame is transmitted successfully, false otherwise.
 */
static bool MAC_AwakeDisassociate(buffer_t *bufPtr)
{
	MAC_FrameInfo_t *transmitFrame;
	transmitFrame = (MAC_FrameInfo_t *)MAC_BUFFER_POINTER(bufPtr);

	/*
	 * Send the disassociation information to the TAL.
	 * Start CSMA-CA using backoff and retry (direct transmission).
	 */
	PHY_Retval_t phyStatus;

	/* In Nonbeacon build the frame is sent with unslotted CSMA-CA. */
	phyStatus = sendFrame(transmitFrame, CSMA_UNSLOTTED, true);

	if (PHY_SUCCESS == phyStatus) {
		MAKE_MAC_BUSY();
	} else {
		return false;
	}

	return true;
}

/**
 * @brief Process a disassociation notification command
 *
 * This functions processes a received disassociation notification
 * command frame.
 * Actual data are taken from the incoming frame in mac_parse_buffer.
 *
 * @param msg Frame buffer to be filled in
 */
void MAC_ProcessDisassociateNotification(buffer_t *msg)
{
    qmm_status_t  qmmStatus = QMM_QUEUE_FULL;
	MLME_DisassociateInd_t *dai
		= (MLME_DisassociateInd_t *)MAC_BUFFER_POINTER(
			((buffer_t *)msg));

	/* Set up the header portion of the MLME_DisassociateInd_t. */
	dai->cmdcode = MLME_DISASSOCIATE_INDICATION;

	/* Build the indication parameters. */

	/*
	 * Set the DeviceAddress first. The device address is the address
	 * of the device requesting the disassociaton which is always
	 * contained in the source address.
	 */
	ADDR_COPY_DST_SRC_64(dai->DeviceAddress,
			macParseData.srcAddr.longAddress);

	dai->DisassociateReason
		= macParseData.macPayloadData.disassocReqData.
			disassocReason;

	qmmStatus = qmm_queue_append(&macNhleQueue, (buffer_t *)msg);

	/*
	 * Once a device is disassociated from a coordinator, the coordinator's
	 * address info should be cleared.
	 */
	(void)memset((uint8_t *)&macPib.mac_CoordExtendedAddress, 0,
			sizeof(macPib.mac_CoordExtendedAddress));
	/* macPib.mac_CoordExtendedAddress = (uint64_t)CLEAR_ADDR_64; */

	/* The default short address is 0xFFFF. */
	macPib.mac_CoordShortAddress = INVALID_SHORT_ADDRESS;
    WPAN_PostTask();
    (void)qmmStatus;
}

/**
 * @brief Prepares a disassociation confirm message with device address
 * information
 *
 * This functions prepares a disassociation confirm message in case the device
 * address information needs to be extracted.
 *
 * @param buf Buffer for sending MLME disassociate confirm message to NHLE
 * @param status Status of disassociation
 */
void MAC_PrepDisassocConf(buffer_t *buf,
		uint8_t status)
{
	MAC_FrameInfo_t *framePtr = (MAC_FrameInfo_t *)MAC_BUFFER_POINTER(buf);
    PHY_Retval_t pibStatus = PHY_FAILURE;
    PibValue_t pib_panid;
    PibValue_t pib_shortaddr;
    PibValue_t pib_ieeeaddr;

#if (MAC_DISASSOCIATION_FFD_SUPPORT == 1)
	uint8_t disDestAddrMode;
	uint64_t tempDevAddr = 0;

	disDestAddrMode
		= (((framePtr->mpdu[PL_POS_FCF_2]) >>
			FCF_2_DEST_ADDR_OFFSET) & 3U);

	if ((FCF_SHORT_ADDR == disDestAddrMode) ||
			(FCF_LONG_ADDR  == disDestAddrMode)) {
		tempDevAddr
			= convert_byte_array_to_64_bit(&(framePtr->mpdu[
					PL_POS_DST_ADDR_START
				]));
	}

	if (MAC_PAN_COORD_STARTED == macState) {
		/*
		 * For PAN coordinator fill parameters of device that
		 * we requested to disassociate into the disassociation confirm
		 * message.
		 * Since we have transmitted the disassociation notification
		 * frame
		 * ourvelves, the destination address information is to be used
		 * here.
		 */
        pibStatus = PHY_PibGet(macPANId, (uint8_t *)&pib_panid);
		if (FCF_SHORT_ADDR == disDestAddrMode) {
			MAC_Gen_MLME_DisassociateConf((buffer_t *)buf,
					status,
					disDestAddrMode,
					pib_panid.pib_value_16bit,
					(AddressField_t *)((void *)&tempDevAddr));
		} else {
			MAC_Gen_MLME_DisassociateConf((buffer_t *)buf,
					status,
					disDestAddrMode,
					pib_panid.pib_value_16bit,
					(AddressField_t *)((void *)&tempDevAddr));
		}
	} else if (MAC_COORDINATOR == macState) {
		/* We are a coordinator. */

		/*
		 * There are 2 potential choices for a coordinator to get here:
		 * 1) We have requested ourselves to disassociate with our own
		 * parent.
		 * 2) We have requested one of our children (other coordinators
		 * or
		 *    end devices) to leave the network.
		 */

		/*
		 * For case 1) check whether the destination address of the
		 * disassociation notification frame is matching the address
		 * of our parent.
		 */
		if (

		        /*
		         * We had requested to disassociate from our parent
		         * using the
		         * short address of the parent.
		         */
			(
				(FCF_SHORT_ADDR == disDestAddrMode) &&
				(convert_byte_array_to_16_bit(&framePtr->mpdu[
					PL_POS_DST_ADDR_START]) ==
				macPib.mac_CoordShortAddress)
			) ||

		        /*
		         * We had requested to disassociate from our parent
		         * using the
		         * extended address of the parent.
		         */
			(
				(FCF_LONG_ADDR == disDestAddrMode) &&
				convert_byte_array_to_64_bit(&framePtr->mpdu[
					PL_POS_DST_ADDR_START]) ==
				macPib.mac_CoordExtendedAddress
			)
			) {
			/*
			 * We are acting as a child here, so we need to fill in
			 * our
			 * own device parameter into the disassociation confirm
			 * message.
			 */
            pibStatus = PHY_PibGet(macShortAddress, (uint8_t *)&pib_shortaddr);
            pibStatus = PHY_PibGet(macPANId, (uint8_t *)&pib_panid);
            pibStatus = PHY_PibGet(macIeeeAddress, (uint8_t *)&pib_ieeeaddr);
			if ((BROADCAST == pib_shortaddr.pib_value_16bit) ||
					(MAC_NO_SHORT_ADDR_VALUE ==
					pib_shortaddr.pib_value_16bit)
					) {
				/* We have no valid short address. */
				MAC_Gen_MLME_DisassociateConf((buffer_t *)buf,
						status,
						FCF_LONG_ADDR,
						pib_panid.pib_value_16bit,
						(AddressField_t *)((void *)&pib_ieeeaddr.pib_value_64bit));
			} else {
				/* We have a valid short address. */
				MAC_Gen_MLME_DisassociateConf((buffer_t *)buf,
						status,
						FCF_SHORT_ADDR,
						pib_panid.pib_value_16bit,
						(AddressField_t *)((void *)&pib_shortaddr.pib_value_16bit));
			}
		} else {
			/*
			 * We are acting as a parent here and have requested one
			 * of our
			 * children to leave the network.
			 * For coordinators that are disassociating their
			 * children.
			 * fill parameters of device/child that we requested to
			 * disassociate into the disassociation confirm message.
			 * Since we have transmitted the disassociation
			 * notification frame
			 * ourvelves, the destination address information is to
			 * be used here.
			 */
            pibStatus = PHY_PibGet(macPANId, (uint8_t *)&pib_panid);
			MAC_Gen_MLME_DisassociateConf((buffer_t *)buf,
					status,
					disDestAddrMode,
					pib_panid.pib_value_16bit,
					(AddressField_t *)((void *)&tempDevAddr));
		}
	} else
#endif /* (MAC_DISASSOCIATION_FFD_SUPPORT == 1) */
	
    {
		/*
		 * We are an end device, so we need to fill in our own device
		 * parameter into the disassociation confirm message.
		 */
        pibStatus = PHY_PibGet(macShortAddress, (uint8_t *)&pib_shortaddr);
        pibStatus = PHY_PibGet(macPANId, (uint8_t *)&pib_panid);
        pibStatus = PHY_PibGet(macIeeeAddress, (uint8_t *)&pib_ieeeaddr);
		if ((BROADCAST == pib_shortaddr.pib_value_16bit) ||
				(MAC_NO_SHORT_ADDR_VALUE ==
				pib_shortaddr.pib_value_16bit)
				) {
			/* We have no valid short address. */
			MAC_Gen_MLME_DisassociateConf((buffer_t *)buf,
					status,
					FCF_LONG_ADDR,
					pib_panid.pib_value_16bit,
					(AddressField_t *)((void *)&pib_ieeeaddr.pib_value_64bit));
		} else {
			/* We have a valid short address. */
			MAC_Gen_MLME_DisassociateConf((buffer_t *)buf,
					status,
					FCF_SHORT_ADDR,
					pib_panid.pib_value_16bit,
					(AddressField_t *)((void *)&pib_shortaddr.pib_value_16bit));
		}
	}

    (void)pibStatus;
	framePtr = framePtr; /* Keep compiler happy. */
}

#endif  /* (MAC_DISASSOCIATION_BASIC_SUPPORT == 1) */

/* EOF */
