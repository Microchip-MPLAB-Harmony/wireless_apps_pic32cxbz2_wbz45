/*******************************************************************************
  MAC Rx Enable Source

  File Name:
    mac_rx_enable.c
  Summary:
    MLME-RX-ENABLE functionality
  Description:
    This file implements the MLME-RX-ENABLE functionality.

 *******************************************************************************/

//DOM-IGNORE-BEGIN
/*******************************************************************************
* Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
*
* Subject to your compliance with these terms, you may use Microchip software
* and any derivatives exclusively with Microchip products. It is your
* responsibility to comply with third party license terms applicable to your
* use of third party software (including open source software) that may
* accompany Microchip software.
*
* THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
* EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
* WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
* PARTICULAR PURPOSE.
*
* IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
* INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
* WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
* BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
* FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
* ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
* THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 *******************************************************************************/
//DOM-IGNORE-END

/* === Includes ============================================================ */
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include "pal.h"
#include "bmm.h"
#include "qmm.h"
#include "phy.h"
#include "ieee_mac_const.h"
#include "mac_msg_const.h"
#include "mac_api.h"
#include "mac_msg_types.h"
#include "mac_data_structures.h"
#include "stack_config.h"
#include "mac_internal.h"
#include "mac.h"
#include "mac_config.h"

#if (MAC_RX_ENABLE_SUPPORT == 1)

/* === Macros ============================================================== */

/* === Globals ============================================================= */

/* === Prototypes ========================================================== */

static void MAC_Timer_RxOffCb(void *callbackParameter);

static uint8_t MAC_RxEnable(void);
static void GenRxEnableConf(buffer_t *buf, uint8_t status);

static void HandleRxOn(uint32_t rxOnDurationSymbols, void *m);

/* === Implementation ====================================================== */

/**
 * @brief Implement the MLME-RX-ENABLE.request primitive.
 *
 * The MLME-RX-ENABLE.request primitive is generated by the next
 * higher layer and issued to MAC to enable the receiver for a
 * fixed duration, at a time relative to the start of the current or
 * next superframe on a beacon-enabled PAN or immediately on a
 * nonbeacon-enabled PAN. The receiver is enabled exactly once per
 * primitive request.
 *
 * @param m Pointer to the MLME-RX-ENABLE.request message
 */
void MAC_MLME_RxEnableRequest(void *m)
{
	MLME_RxEnableReq_t *rxe;

	rxe = (MLME_RxEnableReq_t *)MAC_BUFFER_POINTER((buffer_t *)m);

	/* If RxOnDuration is zero, the receiver shall be disabled */
	if (0U == rxe->RxOnDuration) {
		/*
		 * Turn the radio off. This is doney by calling the
		 * same function as for the expiration of the Rx on timer.
		 */
		MAC_Timer_RxOffCb(NULL);

		/* Send the confirm immediately. */
		GenRxEnableConf((buffer_t *)m, (uint8_t)MAC_SUCCESS);
		return;
	}

	/*
	 * Reject the request when the MAC is currently in any of the
	 * polling states or scanning.
	 */
	if ((MAC_POLL_IDLE != macPollState) ||
			(MAC_SCAN_IDLE != macScanState)
			) {
		/* Send the confirm immediately. */
		GenRxEnableConf((buffer_t *)m, (uint8_t)MAC_TX_ACTIVE);
		return;
	}
	HandleRxOn(rxe->RxOnDuration, m);
} /* MAC_MLME_RxEnableRequest() */

/*
 * @brief Continues handling of MLME-RX-ENABLE.request by
 * waking radio up and setting it into rx on state.
 *
 * @param rxe_buff_ptr Pointer to the MLME-RX-ENABLE buffer allocated by the
 * NHLE.
 */
static uint8_t MAC_RxEnable(void)
{
	uint8_t status;

	/* Wake up the radio first */
	MAC_TrxWakeup();

	/* Turn the receiver on immediately. */
	status = (uint8_t)(PHY_RxEnable(PHY_STATE_RX_ON));

	/* Rx is enabled */
	macRxEnabled = true;

	return (status);
} /* MAC_RxEnable() */

/*
 * @brief Set the transceiver state to PHY_TRX_OFF
 *
 * This actually turns the radio receiver off - i.e. this is the end
 * of the PHY_RX_ON period.
 *
 * @param callbackParameter Callback parameter
 */
static void MAC_Timer_RxOffCb(void *callbackParameter)
{
	uint8_t status;
    PAL_Status_t timerStatus;

	/*
	 * Rx is disabled.
	 * This will make sure that the radio will be put to sleep in function
	 * MAC_SleepTrans().
	 */
	macRxEnabled = false;

	/*
	 * In case macRxOnWhenIdle is not set, the radio is put to PHY_TRX_OFF
	 * state, until the return status does not match the desired radio
	 * state,
	 * i.e. PHY_TRX_OFF
	 */
	if (!macPib.mac_RxOnWhenIdle) {
		/*
		 * In case the radio is awake, we need to switch RX off.
		 */
		if (RADIO_AWAKE == macRadioSleepState) {
			status = (uint8_t)(PHY_RxEnable(PHY_STATE_TRX_OFF));

			if (status != (uint8_t)PHY_TRX_OFF) {
				/*
				 * The TAL is still busy and cannot set the TRX
				 * to OFF.
				 * In order to get progress this requires
				 * another
				 * round of the TAL task being processed.
				 * Therefore the MAC task needs to stopp here
				 * and pass
				 * controll back to the TAL.
				 * This is reached by starting the Rx-Enable
				 * timer again
				 * for a very short time with the same callback
				 * returning
				 * here very soon.
				 */
				timerStatus = PAL_TimerStart(Timer_RxEnable,
						/*MIN_TIMEOUT*/100,
						TIMEOUT_RELATIVE,
						&MAC_Timer_RxOffCb,
						NULL,CALLBACK_SINGLE);

				/*
				 * Return now, since the TAL is still busy, so
				 * radio cannot go
				 * to sleep for now.
				 */
                (void)timerStatus;
				return;
			} else {
				/* Set radio to sleep if allowed */
				MAC_SleepTrans();
			}
		}
	}

	callbackParameter = callbackParameter; /* Keep compiler happy. */
}

/*
 * @brief Internal function to handle immediate RX_ON
 *
 * This function immediately enables the receiver with the given
 * RxOnDuration time in symbols from now.
 *
 * @param rx_on_duration_symbols Duration in symbols that the reciever is
 *                               switched on.
 */
static void HandleRxOn(uint32_t rxOnDurationSymbols, void *m)
{
	PAL_Status_t timerStatus;
	uint8_t rx_enable_status = MAC_RxEnable();

	/*
	 * TODO: Once it is possible to restart a timer even if it is
	 * already running, this could be improved by simply calling
	 * function PAL_TimerStart() without this previous check using
	 * function PAL_TimerIsRunning().
	 */
	if (PAL_TimerIsRunning(Timer_RxEnable)) {
		/*
		 * Rx-Enable timer is already running, so we need to stopp it
		 * first
		 * before it will be started.
		 */
		timerStatus = PAL_TimerStop(Timer_RxEnable);
	}
    (void)timerStatus;

	/*
	 * Start timer for the Rx On duration of the radio being on
	 * in order to switch it off later again.
	 */
	timerStatus
		= PAL_TimerStart(Timer_RxEnable,
			PHY_CONVERT_SYMBOLS_TO_US(rxOnDurationSymbols),
			TIMEOUT_RELATIVE,
			&MAC_Timer_RxOffCb,
			NULL,CALLBACK_SINGLE);


	/*
	 * Send the confirm immediately depending on the status of
	 * the timer start and the Rx Status
	 */
	if (PAL_SUCCESS != timerStatus) {
		GenRxEnableConf((buffer_t *)m, (uint8_t)MAC_INVALID_PARAMETER);
		/* Do house-keeeping and turn radio off. */
		MAC_Timer_RxOffCb(NULL);
	} else if ((uint8_t)PHY_RX_ON != rx_enable_status) {
		GenRxEnableConf((buffer_t *)m, (uint8_t)MAC_TX_ACTIVE);
	} else {
		GenRxEnableConf((buffer_t *)m, (uint8_t)MAC_SUCCESS);
	}

	return;
}

/*
 * @brief Internal function to initiate rx enable confirm message.
 *
 * This function creates the rx enable confirm structure,
 * and appends it into internal event queue.
 *
 * @param buf Buffer for rx enable confirmation.
 * @param status Status of attempt to switch receiver on.
 */
static void GenRxEnableConf(buffer_t *buf, uint8_t status)
{
    qmm_status_t  qmmStatus;
	MLME_RxEnableConf_t *rec
		= (MLME_RxEnableConf_t *)MAC_BUFFER_POINTER(buf);

	rec->cmdcode = MLME_RX_ENABLE_CONFIRM;
	rec->status = status;
	qmmStatus = qmm_queue_append(&macNhleQueue, buf);
    WPAN_PostTask();
    (void)qmmStatus;
}

#endif /* (MAC_RX_ENABLE_SUPPORT == 1) */

/* EOF */
