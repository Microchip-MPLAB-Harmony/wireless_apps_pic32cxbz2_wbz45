var SearchFiles = ["GUID-7663617B-0DD1-45FA-86B5-EB0778A5A424.html","GUID-4A40968E-8B6E-4C84-93B9-D31419BBBDA6.html","GUID-53253F80-1A8A-41EE-8A9D-C0ECBD08A6F9.html","GUID-38587445-E9CF-4BF1-9ECF-2B8E6F85BA2B.html","GUID-3533318C-9ECB-4770-AD96-1D2DC7C659F6.html","GUID-3F360AE8-2799-450C-BE42-EABFBF27D5E9.html","GUID-6AB1EDE7-A7E2-4798-8037-4C6D797DA147.html","GUID-B7A921CE-929D-46FD-B74E-95E78116593A.html","GUID-2AD37FE2-1915-4E34-9A05-79E3810726D7.html","GUID-0D2F114A-B713-4B27-AC5E-4593D234D9B7.html","GUID-3504C96C-3B1A-40E5-AF97-A3270CA7EC77.html","GUID-A55E9342-CE44-4A91-86BB-FEC6706FCD1C.html","GUID-5DEB6FE0-1234-4A15-A805-E451B3E73825.html","GUID-B86E8493-D00D-46EF-8624-D412342147F0.html","GUID-EA74172C-595E-4A34-B359-D42EE443F0EC.html","GUID-FAC65B28-B78E-48AF-BCFE-2D63DC274CDB.html","GUID-3CC3561E-252E-43B9-BC8A-47DD108A0A46.html","GUID-17DABF04-E5D8-4201-A746-2FC244450A19.html","GUID-E8C0DDA5-3AD0-42A4-B4EF-BCB02811BF8C.html","GUID-897B75C0-387F-4AF8-B353-1F97A3B0BEC8.html","GUID-950762E2-DD5E-41CD-AAB4-895439CCFBC4.html","GUID-8C3372E5-CAB6-4923-9B59-E97022E1252D.html","GUID-7C948236-7D8E-45CA-9511-AB244B44BE64.html","GUID-7A350957-2010-468F-AF8D-0635373EF79D.html","GUID-741308A7-A912-4C74-BF94-D5C44132003D.html","GUID-B3B46369-F5B4-401B-8405-658BE34988F4.html","GUID-AB1A02BF-4F9B-4058-90D9-02BFB3136682.html","GUID-820CEA03-90AE-484F-87C9-9CF2CE652702.html","GUID-9A3C4C97-E09F-4FF9-878C-3873892445F4.html","GUID-3D0C03E0-8EFC-455C-970B-17EBE5CB8F78.html","GUID-3D0C03E0-8EFC-455C-970B-17EBE5CB8F78.html",
							"GUID-F9A0C390-C124-49A7-9F22-157D20BFBE5D.html","GUID-07EC83B7-CC28-4C55-8634-4B7F56A9DB36.html","GUID-0F3193BF-C61D-4DDB-9E98-7F0A444269A8.html","GUID-59D44A45-F1F0-46AF-A611-9720C8CE7E93.html","GUID-CB26EBC2-7D3B-454B-98D1-C29A3223ADE6.html","GUID-E1A0E9CA-311E-4F53-9C27-160173609975.html","GUID-92137358-930E-4654-9431-E8BA0E260468.html","GUID-D3F1BF46-F275-409B-A344-4DB9EAABC5E9.html","GUID-D320EA38-86CE-4C0B-8093-60C59E1F03AE.html","GUID-BAAA9A7D-DCB6-4ADB-820A-68D1E8B81B09.html","GUID-71834715-4833-43ED-A1ED-A2A72DDE48BC.html","GUID-668A6CB2-F1FB-438D-9E1E-D67AC3C1C132.html","GUID-B70D4611-9448-4ACC-99C6-308B8EC2BEB7.html","GUID-BA19A3F8-CCEB-44C2-B5BF-C203DD6A8D41.html","GUID-7E62A1F7-3B35-4B5A-86DA-F5694100F9E8.html","GUID-C8CD15B7-2156-4EF8-8D55-C879C829A34B.html","GUID-C8CD15B7-2156-4EF8-8D55-C879C829A34B.html",
							"GUID-C8CD15B7-2156-4EF8-8D55-C879C829A34B.html",
							"GUID-C8CD15B7-2156-4EF8-8D55-C879C829A34B.html",
							"GUID-E7EBE9A5-6B89-4D7A-9620-AE652F4FB0A8.html","GUID-ACC1C69A-65C7-45E5-94FD-81BF5B29E381.html","GUID-F5F71ECD-98A9-49B0-8147-68A25191BEAD.html","GUID-6A3E9676-3271-4BA6-BD4F-AAC9661E51B6.html","GUID-07AD46F8-182D-4FBA-AA80-D58BEEDC78AB.html","GUID-0A5556D0-B6B7-4DD8-BEF1-D9B2B95F01ED.html","GUID-2A54CAC1-1370-4448-8768-E6C7B8CFCA23.html","GUID-11ABDEE6-3F90-4086-AC19-BB2607CA8064.html","GUID-707BAEEE-0EFF-428F-AFEC-C2E6C5E65BA9.html","GUID-CD3623AD-850D-4926-AE66-031692156BAB.html","GUID-998705A8-0286-429C-B35C-0F5E95D94A3D.html","GUID-3D00CE26-A97E-44F4-9A17-A9CC112DAF43.html","GUID-3E242310-437D-4F50-9E63-3C9EF144CD18.html","GUID-FD0DA0D6-A339-4EA1-A3DC-A090B3F44E05.html","GUID-6E27C8C5-A17B-4C9E-8527-CE32F3C68405.html","GUID-F073AA25-D5B2-4CEB-8C81-6DAA9F12BB7A.html","GUID-D81BF788-CE6C-44D4-875D-89BFAC20D01F.html","GUID-3142F765-D7A3-4D0D-B73C-463BF59B0738.html","GUID-637578B7-6092-40CF-88A5-FCF506D998C9.html","GUID-B9333775-2F34-4B60-9429-E1B1B7F505FD.html","GUID-D79D28FC-6693-4FE3-B380-9F6983BCE151.html","GUID-D2666558-1C41-4DC4-AB25-856CE215F5C8.html","GUID-CB9637B8-3D2B-4FD8-86FD-7A4407A9F78D.html","GUID-F9A40E74-7127-4C2C-B480-2746007AAEAE.html","GUID-994B6462-D0F1-4B8C-A97B-A9CBF20426C2.html","GUID-101C8B73-AD8E-4845-831A-DC498B147435.html","GUID-D7A53CEA-74B4-4CAA-A5D4-F69980188D1B.html","GUID-399616BF-E65E-43B3-9831-4B19472A5EF0.html","GUID-003E64BA-98A3-40EA-8417-ED7F09C14761.html","GUID-908446A4-F490-4063-9096-66C4831F9BE4.html","GUID-159581BB-D157-4A79-A4B0-7C9A9692449A.html","GUID-F2D3E8B2-1470-4065-82A4-A313FCBAC126.html","GUID-DF914131-7CEA-4CF1-8F13-C5872AAB7DC6.html","GUID-894A155C-558E-45FD-AA0C-1546AE00DE53.html","GUID-03033848-F789-4EF6-845B-0C7594868889.html","GUID-1DBEFA54-6B29-4BB3-8C75-9FD48DB81F3F.html","GUID-2624FC46-FF08-4D14-9FA0-25B260F81754.html","GUID-84A8D478-B715-4D83-8D8F-49E3F5AFE32C.html","GUID-70714605-ACB2-451F-87F0-66F97057949F.html","GUID-D392EA5B-9A98-4F73-8F52-BD4C9445CD4F.html","GUID-436FCDB1-1B96-4B4C-802C-0C61967DA657.html","GUID-6816EA2C-EDCC-48EC-9D99-BF8EAF56C5A1.html","GUID-5B01388B-241F-4BCF-9204-BE758BC2F97F.html","GUID-FC914BE3-2FDF-44C2-9611-A500FBF9A3A6.html","GUID-85366FA2-8437-418E-AD4C-9099D24AB295.html","GUID-E1908801-D1CA-4E21-97D2-B8F7419AE88A.html","GUID-D3DC88CA-D2C0-4FFF-B035-FE4E6DAE1D97.html","GUID-4CE8CC1D-B3B8-4218-B67B-279E2D29D12E.html","GUID-8AAF102A-1CE5-497A-A6F5-AB939178D89C.html","GUID-F05AF46A-7BBB-4175-9128-7552429BC260.html","GUID-EBCBA6AB-093F-4B8D-88F1-C98BE40F5156.html","GUID-F4386E1E-9C89-4A53-8F6F-D6729E9DF217.html","GUID-84753265-274F-4A53-9E2A-D432905E1E3C.html","GUID-E1668A2E-87A9-405D-9234-53C592A035DF.html","GUID-543C2332-73E4-4305-93D5-6649FE075F35.html","GUID-0B266078-AD33-4AB4-8C96-4F34D86C4BF3.html","GUID-2E405D3D-C758-40B8-A1DC-24B16E0AC2C1.html","GUID-8D2F1488-E176-4352-994E-9B8B96AA6369.html","GUID-7FCA82FF-EA4D-41F3-9141-12D317B414CB.html","GUID-E1668A2E-87A9-405D-9234-53C592A035DF.html","GUID-217228C6-8E92-4C6F-8924-F7B0F8B2314C.html","GUID-A3F96AEA-7517-4859-9799-149B152B5BC4.html","GUID-4F84E615-EC93-4752-AF4D-B9477527B4FA.html","GUID-95F50FC6-4CEE-4EA3-BB70-939637997C8B.html","GUID-1F6A4D91-48E2-4ACF-B566-CFD184B6FF5C.html","GUID-A40B634A-339D-4B50-9146-1FA15512D537.html","GUID-E24160FD-C371-4A9C-99F3-CB7C84DFD5C6.html","GUID-931E0477-A4B1-4887-BC2C-370DC398B29C.html","GUID-E1A30ECC-1212-4B25-AE72-7EAF982C6D50.html","GUID-CDA62122-6D5D-4CDC-B1B7-3EB02C26552C.html","GUID-4A2BABB9-3C7D-45F1-BAD5-C7978B7429B5.html","GUID-CBFFF24C-4BA1-47FC-8AC4-7731929F39A5.html",
							"GUID-CBFFF24C-4BA1-47FC-8AC4-7731929F39A5.html",
							"GUID-CBFFF24C-4BA1-47FC-8AC4-7731929F39A5.html",
							"GUID-222AEAB9-376D-4929-9BD2-5C490840C896.html","GUID-92E7736F-5413-4A33-A7CB-4731DB34B39D.html",
							"GUID-92E7736F-5413-4A33-A7CB-4731DB34B39D.html",
							"GUID-92E7736F-5413-4A33-A7CB-4731DB34B39D.html",
							"GUID-92E7736F-5413-4A33-A7CB-4731DB34B39D.html",
							"GUID-FBB2BFC4-2C4B-4772-8FA0-983E5933D3D4.html",
							"GUID-FBB2BFC4-2C4B-4772-8FA0-983E5933D3D4.html",
							"GUID-FBB2BFC4-2C4B-4772-8FA0-983E5933D3D4.html",
							"GUID-2815D98C-88B9-44C6-8B5E-FC9DC91AB639.html",
							"GUID-2815D98C-88B9-44C6-8B5E-FC9DC91AB639.html",
							"GUID-2815D98C-88B9-44C6-8B5E-FC9DC91AB639.html",
							"GUID-2815D98C-88B9-44C6-8B5E-FC9DC91AB639.html",
							"GUID-01FF8B34-B517-435D-B4A7-10E11D215A5F.html",
							"GUID-01FF8B34-B517-435D-B4A7-10E11D215A5F.html",
							"GUID-01FF8B34-B517-435D-B4A7-10E11D215A5F.html",
							"GUID-01FF8B34-B517-435D-B4A7-10E11D215A5F.html",
							"GUID-B60E4C4F-5960-49AB-9D58-FA4478D807B6.html",
							"GUID-B60E4C4F-5960-49AB-9D58-FA4478D807B6.html",
							"GUID-B60E4C4F-5960-49AB-9D58-FA4478D807B6.html",
							"GUID-79AF944E-7E79-4F1B-A5C9-305D6E2F1C54.html",
							"GUID-79AF944E-7E79-4F1B-A5C9-305D6E2F1C54.html",
							"GUID-79AF944E-7E79-4F1B-A5C9-305D6E2F1C54.html",
							"GUID-79AF944E-7E79-4F1B-A5C9-305D6E2F1C54.html",
							"GUID-663C8EEC-EBB2-4718-AF16-0259D1634561.html",
							"GUID-663C8EEC-EBB2-4718-AF16-0259D1634561.html",
							"GUID-663C8EEC-EBB2-4718-AF16-0259D1634561.html",
							"GUID-86B0620A-487B-42E4-B14A-900C325C8F74.html",
							"GUID-86B0620A-487B-42E4-B14A-900C325C8F74.html",
							"GUID-86B0620A-487B-42E4-B14A-900C325C8F74.html",
							"GUID-86B0620A-487B-42E4-B14A-900C325C8F74.html",
							"GUID-DB38933D-09B1-4BD1-9BE8-3BC43C5870EB.html",
							"GUID-DB38933D-09B1-4BD1-9BE8-3BC43C5870EB.html",
							"GUID-DB38933D-09B1-4BD1-9BE8-3BC43C5870EB.html",
							"GUID-6A676CE1-9475-4B6D-AE01-8E4961BF00DC.html",
							"GUID-6A676CE1-9475-4B6D-AE01-8E4961BF00DC.html",
							"GUID-6A676CE1-9475-4B6D-AE01-8E4961BF00DC.html",
							"GUID-F280F94A-7926-43EF-9D5A-EBD53B9CDBC1.html",
							"GUID-F280F94A-7926-43EF-9D5A-EBD53B9CDBC1.html",
							"GUID-F280F94A-7926-43EF-9D5A-EBD53B9CDBC1.html",
							"GUID-E0701C6C-5685-4F72-8BB6-86C491F5106F.html",
							"GUID-E0701C6C-5685-4F72-8BB6-86C491F5106F.html",
							"GUID-E0701C6C-5685-4F72-8BB6-86C491F5106F.html",
							"GUID-159FB68F-FBE7-4DF3-AFE3-09B4E8767F48.html","GUID-974C2B95-A6F2-42E5-9AFC-57AB0C5507FF.html","GUID-D337D190-6F61-4EA0-AEE9-CA58B5C83335.html",
							"GUID-D337D190-6F61-4EA0-AEE9-CA58B5C83335.html",
							"GUID-D337D190-6F61-4EA0-AEE9-CA58B5C83335.html",
							"GUID-0E14539E-032F-4959-9669-CF515777EC50.html","GUID-940847B5-E800-48A3-9934-BDF510A9666D.html",
							"GUID-940847B5-E800-48A3-9934-BDF510A9666D.html",
							"GUID-940847B5-E800-48A3-9934-BDF510A9666D.html",
							"GUID-940847B5-E800-48A3-9934-BDF510A9666D.html",
							"GUID-940847B5-E800-48A3-9934-BDF510A9666D.html",
							"GUID-D5E7B8C5-9CB4-40A0-8DB9-3B4C6A66E8CE.html",
							"GUID-D5E7B8C5-9CB4-40A0-8DB9-3B4C6A66E8CE.html",
							"GUID-D5E7B8C5-9CB4-40A0-8DB9-3B4C6A66E8CE.html",
							"GUID-D5E7B8C5-9CB4-40A0-8DB9-3B4C6A66E8CE.html",
							"GUID-9DCAF883-CC0F-4D07-848D-D39C1DA512E5.html",
							"GUID-9DCAF883-CC0F-4D07-848D-D39C1DA512E5.html",
							"GUID-9DCAF883-CC0F-4D07-848D-D39C1DA512E5.html",
							"GUID-9DCAF883-CC0F-4D07-848D-D39C1DA512E5.html",
							"GUID-9DCAF883-CC0F-4D07-848D-D39C1DA512E5.html",
							"GUID-8BCCAF48-DE26-4E7B-A94D-A1560B775CC4.html",
							"GUID-8BCCAF48-DE26-4E7B-A94D-A1560B775CC4.html",
							"GUID-8BCCAF48-DE26-4E7B-A94D-A1560B775CC4.html",
							"GUID-8BCCAF48-DE26-4E7B-A94D-A1560B775CC4.html",
							"GUID-8BCCAF48-DE26-4E7B-A94D-A1560B775CC4.html",
							"GUID-D481FB40-2B38-4578-8BC7-9AA1AAE7F547.html",
							"GUID-D481FB40-2B38-4578-8BC7-9AA1AAE7F547.html",
							"GUID-D481FB40-2B38-4578-8BC7-9AA1AAE7F547.html",
							"GUID-184F3667-3719-4254-91C4-089B4E718F79.html",
							"GUID-184F3667-3719-4254-91C4-089B4E718F79.html",
							"GUID-184F3667-3719-4254-91C4-089B4E718F79.html",
							"GUID-184F3667-3719-4254-91C4-089B4E718F79.html",
							"GUID-FFB256C1-978B-428C-BBA5-5FDCC2A63E5E.html","GUID-53A92559-C8B7-4045-970D-455EB3B190E5.html",
							"GUID-53A92559-C8B7-4045-970D-455EB3B190E5.html",
							"GUID-53A92559-C8B7-4045-970D-455EB3B190E5.html",
							"GUID-53A92559-C8B7-4045-970D-455EB3B190E5.html",
							"GUID-A18401FE-608E-4562-9544-A14814D47777.html",
							"GUID-A18401FE-608E-4562-9544-A14814D47777.html",
							"GUID-A18401FE-608E-4562-9544-A14814D47777.html",
							"GUID-A18401FE-608E-4562-9544-A14814D47777.html",
							"GUID-3095456E-3B15-42F9-BCDA-E5E1337D0AA1.html","GUID-55B35426-69EB-4BCC-8F95-F6647E69BD46.html","GUID-332DFF7E-D9EC-4308-B212-7D8E6B36DAB8.html",
							"GUID-332DFF7E-D9EC-4308-B212-7D8E6B36DAB8.html",
							"GUID-332DFF7E-D9EC-4308-B212-7D8E6B36DAB8.html",
							"GUID-332DFF7E-D9EC-4308-B212-7D8E6B36DAB8.html",
							"GUID-4CF8DE3C-29BF-4F46-9C0C-17AF6E24421F.html",
							"GUID-4CF8DE3C-29BF-4F46-9C0C-17AF6E24421F.html",
							"GUID-4CF8DE3C-29BF-4F46-9C0C-17AF6E24421F.html",
							"GUID-4CF8DE3C-29BF-4F46-9C0C-17AF6E24421F.html",
							"GUID-BDEA426A-51E9-4C3D-B8B0-FAAC0279AD65.html","GUID-E0E5C82C-569C-4FFB-809D-929A67D9AB6B.html",
							"GUID-E0E5C82C-569C-4FFB-809D-929A67D9AB6B.html",
							"GUID-E0E5C82C-569C-4FFB-809D-929A67D9AB6B.html",
							"GUID-95651E94-1B2F-4659-8B0B-FD1795A0ED6A.html","GUID-E59A9B66-D83B-4CAD-8348-562FB613CC35.html",
							"GUID-E59A9B66-D83B-4CAD-8348-562FB613CC35.html",
							"GUID-E59A9B66-D83B-4CAD-8348-562FB613CC35.html",
							"GUID-E59A9B66-D83B-4CAD-8348-562FB613CC35.html",
							"GUID-C6AFAD38-982A-4C34-99F8-C00B7B4273BB.html",
							"GUID-C6AFAD38-982A-4C34-99F8-C00B7B4273BB.html",
							"GUID-C6AFAD38-982A-4C34-99F8-C00B7B4273BB.html",
							"GUID-C6AFAD38-982A-4C34-99F8-C00B7B4273BB.html",
							"GUID-A414641C-76BE-469B-9072-FC17022ADFF5.html",
							"GUID-A414641C-76BE-469B-9072-FC17022ADFF5.html",
							"GUID-A414641C-76BE-469B-9072-FC17022ADFF5.html",
							"GUID-A414641C-76BE-469B-9072-FC17022ADFF5.html",
							"GUID-4C7F16E0-6963-4C6C-9BAC-9AE0D41789B7.html",
							"GUID-4C7F16E0-6963-4C6C-9BAC-9AE0D41789B7.html",
							"GUID-4C7F16E0-6963-4C6C-9BAC-9AE0D41789B7.html",
							"GUID-4C7F16E0-6963-4C6C-9BAC-9AE0D41789B7.html",
							"GUID-CA0E784B-D0E6-4D70-B485-6D9E6022B744.html",
							"GUID-CA0E784B-D0E6-4D70-B485-6D9E6022B744.html",
							"GUID-CA0E784B-D0E6-4D70-B485-6D9E6022B744.html",
							"GUID-CA0E784B-D0E6-4D70-B485-6D9E6022B744.html",
							"GUID-CA0E784B-D0E6-4D70-B485-6D9E6022B744.html",
							"GUID-58B9BA26-60FE-4271-B40C-7EC8F4F7B192.html",
							"GUID-58B9BA26-60FE-4271-B40C-7EC8F4F7B192.html",
							"GUID-58B9BA26-60FE-4271-B40C-7EC8F4F7B192.html",
							"GUID-58B9BA26-60FE-4271-B40C-7EC8F4F7B192.html",
							"GUID-58B9BA26-60FE-4271-B40C-7EC8F4F7B192.html",
							"GUID-84FD86A5-5EF7-4B41-B2AE-4FE3C18C13BB.html","GUID-61F29AB6-C3E0-44E4-B77A-DC259FD83C2C.html",
							"GUID-61F29AB6-C3E0-44E4-B77A-DC259FD83C2C.html",
							"GUID-61F29AB6-C3E0-44E4-B77A-DC259FD83C2C.html",
							"GUID-61F29AB6-C3E0-44E4-B77A-DC259FD83C2C.html",
							"GUID-4DF9729B-BAFC-4305-B4B5-577F28797F81.html",
							"GUID-4DF9729B-BAFC-4305-B4B5-577F28797F81.html",
							"GUID-4DF9729B-BAFC-4305-B4B5-577F28797F81.html",
							"GUID-4DF9729B-BAFC-4305-B4B5-577F28797F81.html",
							"GUID-E28C9796-BFFB-4D8D-85E8-3D32F3F3CC53.html",
							"GUID-E28C9796-BFFB-4D8D-85E8-3D32F3F3CC53.html",
							"GUID-E28C9796-BFFB-4D8D-85E8-3D32F3F3CC53.html",
							"GUID-E28C9796-BFFB-4D8D-85E8-3D32F3F3CC53.html",
							"GUID-927B1C36-F5B5-48D8-8F28-D8A4FE5026F8.html",
							"GUID-927B1C36-F5B5-48D8-8F28-D8A4FE5026F8.html",
							"GUID-927B1C36-F5B5-48D8-8F28-D8A4FE5026F8.html",
							"GUID-927B1C36-F5B5-48D8-8F28-D8A4FE5026F8.html",
							"GUID-0904E9A3-4DFA-48B3-B59C-5A4A911E07C9.html",
							"GUID-0904E9A3-4DFA-48B3-B59C-5A4A911E07C9.html",
							"GUID-0904E9A3-4DFA-48B3-B59C-5A4A911E07C9.html",
							"GUID-0904E9A3-4DFA-48B3-B59C-5A4A911E07C9.html",
							"GUID-2262C95D-85A7-48DD-A78C-F57E5917141B.html","GUID-8BBF5057-BBDA-491E-8DFE-7DFEF244DD81.html","GUID-5AF018E7-5002-44C7-8C0F-AE7D83BDA49D.html",
							"GUID-5AF018E7-5002-44C7-8C0F-AE7D83BDA49D.html",
							"GUID-5AF018E7-5002-44C7-8C0F-AE7D83BDA49D.html",
							"GUID-5AF018E7-5002-44C7-8C0F-AE7D83BDA49D.html",
							"GUID-6987A03A-ADB1-42E6-918B-E0AB1447964C.html",
							"GUID-6987A03A-ADB1-42E6-918B-E0AB1447964C.html",
							"GUID-6987A03A-ADB1-42E6-918B-E0AB1447964C.html",
							"GUID-6987A03A-ADB1-42E6-918B-E0AB1447964C.html",
							"GUID-37C0393D-F38C-4BC7-BF76-B5B7F01A9CF8.html","GUID-A8FBF1F1-80DD-42AA-82E8-3935CBABFB82.html","GUID-A7AE34A9-87E8-4AC1-8D72-8002DBC06789.html",
							"GUID-A7AE34A9-87E8-4AC1-8D72-8002DBC06789.html",
							"GUID-A7AE34A9-87E8-4AC1-8D72-8002DBC06789.html",
							"GUID-A7AE34A9-87E8-4AC1-8D72-8002DBC06789.html",
							"GUID-5DBE9129-D654-406C-9A3F-460A39626F1F.html","GUID-DD9E2B64-B9E7-4B9F-B28A-ECF9A4668A89.html",
							"GUID-DD9E2B64-B9E7-4B9F-B28A-ECF9A4668A89.html",
							"GUID-DD9E2B64-B9E7-4B9F-B28A-ECF9A4668A89.html",
							"GUID-DD9E2B64-B9E7-4B9F-B28A-ECF9A4668A89.html",
							"GUID-BBDEFB96-FD29-4302-927D-CD4E2CDFBCD8.html","GUID-22E72B1B-A789-4A9B-85FD-C1830AE41DD6.html",
							"GUID-22E72B1B-A789-4A9B-85FD-C1830AE41DD6.html",
							"GUID-22E72B1B-A789-4A9B-85FD-C1830AE41DD6.html",
							"GUID-22E72B1B-A789-4A9B-85FD-C1830AE41DD6.html",
							"GUID-22E72B1B-A789-4A9B-85FD-C1830AE41DD6.html",
							"GUID-4078553E-F3E2-4E02-8F41-2D9C261A8DF9.html",
							"GUID-4078553E-F3E2-4E02-8F41-2D9C261A8DF9.html",
							"GUID-4078553E-F3E2-4E02-8F41-2D9C261A8DF9.html",
							"GUID-4078553E-F3E2-4E02-8F41-2D9C261A8DF9.html",
							"GUID-4078553E-F3E2-4E02-8F41-2D9C261A8DF9.html",
							"GUID-6D689B6A-8D10-44E3-8C28-0D17E58D870B.html",
							"GUID-6D689B6A-8D10-44E3-8C28-0D17E58D870B.html",
							"GUID-6D689B6A-8D10-44E3-8C28-0D17E58D870B.html",
							"GUID-6D689B6A-8D10-44E3-8C28-0D17E58D870B.html",
							"GUID-6D689B6A-8D10-44E3-8C28-0D17E58D870B.html",
							"GUID-BFBA4374-C877-4873-A71E-6E5324F5324F.html",
							"GUID-BFBA4374-C877-4873-A71E-6E5324F5324F.html",
							"GUID-BFBA4374-C877-4873-A71E-6E5324F5324F.html",
							"GUID-BFBA4374-C877-4873-A71E-6E5324F5324F.html",
							"GUID-BFBA4374-C877-4873-A71E-6E5324F5324F.html",
							"GUID-ABAB7167-0F22-4DE9-8CCB-24CDD499365D.html","GUID-7190D043-D2F7-4691-ACEC-7134AD39FD98.html","GUID-4A6BAE4C-4665-4BF5-A625-D048BD590CEF.html","GUID-8BA13BF9-A9CF-47CE-A8CB-4A902FC8B206.html","GUID-738DF609-9803-4FA9-91E5-25D8E08FF8B2.html","GUID-A5A9AB06-7BDA-49F9-83B7-4496976A5B5B.html","GUID-72B8AB89-595F-4CE8-9D3D-9D54C8D092C9.html","GUID-ECDD91F4-F6E0-414E-9BAF-26E216410F51.html","GUID-769877FB-8190-4D79-A21B-67B2A76CD688.html","GUID-8F4088F1-5CA1-4E03-A205-A2BD9CD6A829.html","GUID-1EB023D2-F2C1-4E5A-A47F-CF04918F28E2.html","GUID-EFC7A6D6-20AE-4722-8342-33C1B0633869.html","GUID-650C54A5-5839-41AE-89A4-9C04D89C5714.html","GUID-F8C09A37-7D47-49DF-B9CF-7BAA4112B301.html","GUID-2D8ADA07-6DC1-4E27-A58B-1876F4FE03C7.html","GUID-C3DCAEFB-F548-4E77-9887-8689398F94A1.html","GUID-ABC53259-394B-44F5-B0C2-A92BBA5206FE.html","GUID-25E9E0F6-C673-40B9-9EC3-914570527168.html","GUID-6E91C3E4-2A6D-42A7-BBD3-CA4B6B18892A.html","GUID-C0D2B156-B4B8-471B-BB7D-06FDA8C13D3C.html","GUID-8B4E6F25-6A3E-4E2D-A0EE-0449E4863420.html","GUID-2E5C58CA-0968-45C9-92CB-D867494C3BC0.html","GUID-AC2A32B8-1F5D-4CFC-8E0B-B83A52E8CD45.html","GUID-5FC6D5A2-B8C3-4AD8-AC31-0AABE237A2F7.html","GUID-99583057-8B1A-42F2-84E8-CFC7717FA5D1.html","GUID-9C28F407-4879-4174-9963-2CF34161398E.html","GUID-F8FE2886-8A2C-4FC0-9956-C094CE44D162.html","GUID-BA0204D8-EFF0-4932-830D-73E2A72614A0.html","GUID-BA0204D8-EFF0-4932-830D-73E2A72614A0.html",
							"GUID-BA0204D8-EFF0-4932-830D-73E2A72614A0.html",
							"GUID-BA0204D8-EFF0-4932-830D-73E2A72614A0.html",
							"GUID-0FB3F908-88EE-45CE-94F5-E97AF9049C9B.html","GUID-7551DC67-D79D-4F0C-B56F-7B17E12400E0.html","GUID-CDA512D8-0DE4-4672-8716-04CAC681CB38.html","GUID-F05182E4-B102-4775-A746-1FF37F465312.html","GUID-E8251634-7B15-4073-A103-5A5F128B8699.html","GUID-125F1A93-76CC-4BD7-BACA-01844FBD5F4F.html","GUID-21750586-F9F2-4E33-87FB-8F2994BF4744.html","GUID-07985EED-D525-413B-AEFE-78B563328687.html","GUID-02A694CF-88A5-4ADA-8785-7EEEC62D66EA.html"];

var SearchTitles = ["Introduction",
"Getting Started with WBZ451 Curiosity Board",
"Hardware",
"Preprogrammed Demo Software",
"BLE Demo Experience",
"ZigBee Demo Experience",
"Multiprotocol (BLE + ZigBee)Demo Experience",
"Next Steps",
"Getting Started with Software Development",
"Install IDE and Compiler",
"Install Device Family Part Pack",
"Install MCC Plugin",
"Install Harmony 3 Dependencies",
"Creating a new MCC Harmony Project",
"Running a Precompiled Application Example",
"Next Steps",
"BLE Applications",
"Building Block Examples",
"Central",
"Central - FreeRTOS BLE Stack and App Initialize",
"BLE Legacy Scan",
"BLE Scanning Extended Advertisements",
"BLE Connection",
"BLE Transparent UART",
"BLE Multilink Transparent UART",
"Peripheral",
"Peripheral - FreeRTOS BLE Stack and App Initialize",
"BLE Sleep Mode Legacy Advertisements",
"BLE Extended Advertisements",
"BLE Deep Sleep Advertising",
"Known Issue:",
"BLE Connection",
"BLE Transparent UART",
"BLE Custom service",
"BLE Multirole Multilink Transparent UART",
"Chip Peripherals",
"UART -- Hello World",
"Advanced Applications",
"BLE Sensor App",
"Protocol Exchange",
"BLE Throughput",
"BLE Virtual Sniffer",
"Getting Started with Zigbee Applications",
"Zigbee Project Generation",
"Zigbee Console Commands",
"Zigbee Commisioning Procedure",
"Zigbee Network Security Models",
"Key Exchange Process: Centralised Network",
"Key Exchange Process: Distributed Network",
"Example Logs",
"Zigbee Green Power",
"ZigBee Applications",
"Zigbee Application Demo: Light control and Monitoring using Combined Interface",
"Zigbee Application Demo: Light control and Monitoring using Alexa Echo Plus",
"Zigbee Centralised Network Formation by Combined Interface",
"Zigbee Application Demo: Multi-Sensor with Low Power Functionality",
"Getting Started With Multiprotocol Applications",
"Multiprotocol (BLE+ZIGBEE) Concurrent Application - Tutorial",
"Multiprotocol Application Demo: Zigbee light and Zigbee commissioning through BLE",
"Multiprotocol Device Firmware Upgrade over BLE Link",
"Zigbee commissioning through BLE - Protocol Exchange",
"BLE ZigBee Provisioning Low Power Application Demo: Zigbee Multi-Sensor and Zigbee commissioning through BLE",
"Getting Started with IEEE 802 15 4 P2P Phy Application",
"Reference Documentation",
"Software Requirements",
"Hardware Requirements",
"Creating a New MCC Harmony Project",
"Operating Modes",
"Command Table",
"How-to: Adding Chip Peripherals",
"USART with Direct Pin Enable",
"USART with Peripheral Pin Select (PPS)",
"Clock",
"How-to: Low Power Design",
"Low Power Design on PIC32CXBZ2 Devices",
"Low Power BLE Application Design",
"How-to: Firmware and OTA Updates",
"Bootloader",
"Device Firmware Upgrade Over Serial",
"Device Firmware Upgrade Over BLE",
"BLE OTA DFU Firmware Architecture",
"Memory Management",
"Microchip defined BLE OTA DFU Profile",
"BLE OTA DFU Image File Definition",
"BLE OTA DFU Image Distribution Procedure",
"BLE OTA DFU Implementation",
"MCC Component and Code Generation",
"OTA Application Development",
"Project Properties Configuration for Current/Running Firmware",
"Unified Image Generation",
"Programming the Current Application Image using MPLABX IDE",
"Upgradable image bin file generation",
"BLE OTA DFU Demo",
"Device Firmware Upgrade Over Zigbee Link",
"Zigbee OTAU Firmware Architecture",
"OTAU Basic Protocol and Control Flow",
"Memory Management",
"Zigbee OTAU Image File Definition",
"Zigbee OTAU - Image Distribution Procedure",
"OTA Implementation Details - OTAU Client Side",
"Application Development",
"Project Properties Configuration for Current Image",
"Unified Image Generation",
"Programming the Current Application Image using MPLABX IDE",
"Upgradable image zigbee file generation",
"OTA Implementation Details - OTAU Server",
"Application Development",
"Project Properties Configuration for Serial Bootloading",
"Unified Image Generation for Serial Bootloading",
"Programming the Current Application Image using MPLABX IDE",
"Zigbee OTAU Demo",
"Microchip Utility Tool",
"Introduction",
"Tools Description",
"Zigbee Over The Air Update Demo",
"ISD Protocol",
"Serial Bootloader Demo",
"Programming using IPECMD exe",
"Wireless System Services API",
"BLE_OTA",
"BLE_OTA Enums",
"APP_OTA_HDL_Mode_T",
"C",
"Description",
"BLE_OTA Functions",
"APP_OTA_EvtHandler",
"C",
"Description",
"Parameters",
"APP_OTA_HDL_Complete",
"C",
"Description",
"APP_OTA_HDL_ErrorHandle",
"C",
"Description",
"Parameters",
"APP_OTA_HDL_GetOTAMode",
"C",
"Description",
"Return values",
"APP_OTA_HDL_Init",
"C",
"Description",
"APP_OTA_HDL_Prepare",
"C",
"Description",
"Parameters",
"APP_OTA_HDL_Reset",
"C",
"Description",
"APP_OTA_HDL_SetOTAMode",
"C",
"Description",
"Parameters",
"APP_OTA_HDL_Start",
"C",
"Description",
"APP_OTA_HDL_Updating",
"C",
"Description",
"APP_OTA_Reboot_Handler",
"C",
"Description",
"APP_OTA_Timeout_Handler",
"C",
"Description",
"BLE_Conn_Handler",
"BLE_Conn_Handler Enums",
"APP_BLE_LinkState_T",
"C",
"Description",
"BLE_Conn_Handler Functions",
"APP_BleGapConnEvtHandler",
"C",
"Description",
"Events generated",
"Parameters",
"APP_GetBleState",
"C",
"Description",
"Return values",
"APP_GetConnHandleByIndex",
"C",
"Description",
"Parameters",
"Return values",
"APP_GetConnInfoByConnHandle",
"C",
"Description",
"Parameters",
"Return values",
"APP_InitConnList",
"C",
"Description",
"APP_SetBleState",
"C",
"Description",
"Parameters",
"BLE_Conn_Handler Structures",
"APP_BLE_ConnData_T",
"C",
"Description",
"Field Documentation",
"APP_BLE_ConnList_T",
"C",
"Description",
"Field Documentation",
"APP_TRPS",
"APP_TRPS Defines",
"Control Response ID status Length",
"C",
"Description",
"Macro Definition",
"Maximum Control List Size",
"C",
"Description",
"Macro Definition",
"APP_TRPS Enums",
"APP_TRPS_CTRL_STATUS_CODE_T",
"C",
"Description",
"APP_TRPS Functions",
"APP_TRPS_ConnEvtProc",
"C",
"Description",
"Parameters",
"APP_TRPS_deInit",
"C",
"Description",
"Parameters",
"APP_TRPS_DiscEvtProc",
"C",
"Description",
"Parameters",
"APP_TRPS_EventHandler",
"C",
"Description",
"Parameters",
"APP_TRPS_Init",
"C",
"Description",
"Parameters",
"Return values",
"APP_TRPS_SendNotification",
"C",
"Description",
"Parameters",
"Return values",
"APP_TRPS Structures",
"APP_TRPS_CmdResp_T",
"C",
"Description",
"Field Documentation",
"APP_TRPS_ConnList_T",
"C",
"Description",
"Field Documentation",
"APP_TRPS_Ctrl_T",
"C",
"Description",
"Field Documentation",
"APP_TRPS_CtrlCmd_T",
"C",
"Description",
"Field Documentation",
"APP_TRPS_NotifyData_T",
"C",
"Description",
"Field Documentation",
"APP_ERROR_DEF",
"APP_ERROR_DEF Defines",
"Error Codes Def-1",
"C",
"Description",
"Macro Definition",
"Error Codes Def-2",
"C",
"Description",
"Macro Definition",
"APP_Timer",
"APP_Timer Defines",
"APP_TIMER_TIMEOUT",
"C",
"Description",
"Macro Definition",
"APP_Timer Enums",
"APP_TIMER_TimerId_T",
"C",
"Description",
"Note",
"App_Timer Functions",
"APP_TIMER_IsTimerExisted",
"C",
"Description",
"Parameters",
"Return values",
"APP_TIMER_ResetTimer",
"C",
"Description",
"Parameters",
"Return values",
"APP_TIMER_SetTimer",
"C",
"Description",
"Parameters",
"Return values",
"APP_TIMER_StopTimer",
"C",
"Description",
"Parameters",
"Return values",
"Application Timer Service",
"15_4_P2P_Phy_App",
"15_4_P2P_Phy_App Defines",
"15_4_P2P_Phy_App Enums",
"APP_Mode_T",
"APP_TEST_Mode_T",
"APP_OP_STATE_T",
"15_4_P2P_Phy_App Functions",
"15_4_P2P_Phy_App Structures",
"DEVICE_TABLE",
"APP_NWK_PARAM",
"CCA",
"CSMA",
"ED_SCAN",
"APP_STATES_PARAM",
"SYSTIMER_FLAGS",
"MODE_SWITCH_FLAGS",
"APP_MODE_PARAMS",
"APPL_DATA_MODE",
"APPL_CNT_TEST_MODE",
"APPL_PERIOD_TEST_MODE",
"APPL_PER_TEST_MODE",
"APPL_THROUGHPUT_TEST_MODE",
"Support Documentation",
"User Action",
"MPLAB Code Configurator(MCC) Code Generation",
"Import existing App Example Configuration",
"Porting Guide for WBZ451 to PIC32CX1012BZ25048",
"Introduction",
"Steps for porting an MCC project",
"References",
"Microchip Information",
"The Microchip Website",
"Product Change Notification Service",
"Customer Support",
"Microchip Devices Code Protection Feature",
"Legal Notice",
"Trademarks",
"Quality Management System",
"Worldwide Sales and Service"];

var SearchInfo = [" Introduction This document covers evaluation development environment setup and application examples documentation to enable users create their product using PIC32CXBZ2_WBZ45 devices Users can evaluate the development platform by running the preprogrammed demo example Preprogrammed BLE+Zigbee Application demo experience or running the precompiled appplication examples Documentation describing steps to test and develop the precompiled BLE application examples The precompiled application examples are a combination of simple and advanced applications Simple application examples otherwise referred to as building blocks provide user basic BLE Applications which cover individual concepts like advertisement (legacy and extended) data transer using a profile and service The advanced applications showcase more complex applications which involve multiple digital/analog peripherals running in parallel while maintaining a BLE link Zigbee This is a generic document which gives the user an overview of few key Zigbee 3 0 protocol concepts and guidance on implementing these features on PIC32CX-BZ/WBZ using Microchip software It shows how the protocol configurations(such as application device types clusters commissioning) can be enabled/disabled configured in a step by step manner using Microchip's embedded software development framework tools Microchip Harmony Framework is a full-featured production grade embedded software development platform from Microchip It provides a framework for creating zigbee devices running on PIC32CX-BZ/WBZ family of device and modules and Multiprotocol Documentation describing steps to test and develop the precompiled BLE and Zigbee coexistence application examples (BLE+Zigbee) Applications are available for users who are interested to develop their Zigbee use case We recommend a user run the preprogrammed demo example then install the tool chain and other application examples run some of the precompiled application examples of interest and then start developing their own application by choosing a application example that best suits their needs The table below provides a list of resources available and a summary of information the sections within this documentation cover Section Concepts covered Getting Started with WBZ451 Curiosity Board This section covers evaluation board features and running the preprogrammed demo example Evaluation Board Features Running the preprogrammed demo example Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Steps to install IDE tool chain BLE stacks and application examples on your PC BLE Applications Documentation describing steps to test and develop the precompiled BLE application examples BLE Application Documentation describing steps to test and develop the precompiled application examples developed by us Zigbee Applications This is a generic document which gives the user an overview of few key Zigbee 3 0 protocol concepts and guidance on implementing these features on PIC32CX-BZ/WBZ using Microchip software It shows how the protocol configurations(such as application device types clusters commissioning) can be enabled/disabled configured in a step by step manner using Microchip's embedded software development framework tools Microchip Harmony Framework is a full-featured production grade embedded software development platform from Microchip It provides a framework for creating zigbee devices running on PIC32CX-BZ/WBZ family of device and modules Zigbee application Documentation describing steps to test and develop the precompiled application examples developed by us Multiprotocol Applications Documentation describing steps to test and develop the precompiled BLE and Zigbee coexistence application examples BLE + Zigbee Precompiled Application and support Documentation Chip Peripherals Guidance on how to add analog/digital peripherals to your application Guidance on how to add analog/digital peripherals to your application Low Power Design Enable low power modes - Sleep/Standby or Deep Sleep/Backup Modes in your design Enable low power modes - Sleep/Standby or Deep Sleep/Backup Modes in your design Bootloader and Device Firmware Upgrade This section documents how to enable FW updates in your design whether its serial or over the air Enable FW updates in your design whether its serial or over the air Support Documentation This section has documentation that is generic and used as supporting document with our application example documentation Documentation that is generic and used as supporting document with our application example documentation ",
							" Getting Started with WBZ451 Curiosity Board This section covers evaluation board features and running the preprogrammed demo example ",
							" Hardware The WBZ451 Curiosity Board is an efficient and modular development platform that supports rapid prototyping and demonstrates the features capabilities and interfaces of Microchip's BLE+Zigbee RF Module WBZ451 This board offers integrated programming/debugging features using PICkit™ On-Board (PKOB4) debugger and requires only a micro-USB cable to power-up and program the board Users can expand its functionality through MikroElectronika mikroBUS™ Click™ adapter boards and do rapid prototyping utilizing the BLE+Zigbee enabled RF Module The WBZ451 Curiosity Board supports a variety of applications such as wireless lighting home automation/Internet of Things (IoT) industrial automation and other BLE or Zigbee related applications Features WBZ451 BLE+Zigbee RF Module USB or Battery Powered On-board Programmer/Debug Circuit using PKoB4 based on Microchip SAME70 MCU Microchip MCP73871 Li-Ion/LiPo Battery Charger with Power Path Management On-board USB to UART Serial Converter with HW Flow Control based on Microchip MCP2200 mikroBUS™ Socket to Expand Functionality using MikroElectronika Click™ Adapter Boards RGB Lighting LED connected to PWM Reset Switch One User Configurable Switch One User LED • 32 768 kHz Crystal Microchip SST26VF064B 64 Mbit External QSPI Flash Microchip MCP9700A Low Power Analog Voltage Temperature Sensor 10 pin ARM SWD Header for External Programmer/Debugger WBZ451 Curiosity Board WBZ451 Curiosity Board Top View WBZ450 Curiosity Board WBZ451 Curiosity Board Bottom View ",
							" Preprogrammed Demo Software Preprogrammed BLE+Zigbee Application demo experience Your WBZ451 Curiosity Board comes pre-programmed with example software that demonstrates two common BLE and/zigbee use-cases in a single application: BLE Sensor monitoring and BLE Lighting control Zigbee Lighting control and monitoring The pre-programmed software implements a fully functional BLE Temperature Sensor The Curiosity on-board temperature sensor data is regularly read and made available via both advertising information (thus available without needing to connect) and also updated periodically after a BLE connection is initiated The pre-programmed software also implements full BLE control for the RGB LED populated on the Curiosity Board Once connected a user can control the LED's brightness color and on/off state via BLE Additionally the on/off state is made available via advertising information so that a user can know the status without connecting Users can try anyone of the demo experience based on their use case BLE only Demo Experience Zigbee only Demo Experience Multiprotocol (BLE+Zigbee) Demo Experience ",
							" BLE Demo Experience The demo consists of the WBZ451 Curiosity board with accompanying ble_senor_app Firmware the Microchip Bluetooth Data (MBD) Smartphone App The MBD app has the capability to scan for BLE Advertisements from WBZ451 module and to establish a connection Scan operation monitors temperature sensor and status of RGB LED (on or off) Establishing a BLE connection with WBZ451 module enables users to control the RGB status (on or off) as well as intensity and color of the RGB LED using slide controls BLE Sensor App Demo Install the Microchip Bluetooth Data (MBD) Smartphone App iOS/Android users can search for “Microchip Bluetooth Data” App in App Store and install Enable Bluetooth on the Smartphone Launch the MBD Smartphone App Supply power to WBZ451 Curiosity Board Connect a USB cable to the kit or a 4 2V Li-ion/Li-Po Battery For more information refer to the Power Supply section of the PIC32CX-BZ25 and WBZ451 Curiosity Board User's Guide The user-programmable blue LED starts blinking on the Curiosity Board when the board is in advertisement mode Monitor RGB LED state and Temperature WBZ451 Curiosity Board starts in advertisement mode to advertise its presence on a smartphone and to allow access to RGB LED on/off state and temperature sensor data Navigate through the Smartphone App as shown in the following figure to access the advertisement information Control RGB LED state on/off as well as intensity and color Click the device that shows up after initiating a scan to establish a connection with WBZ451 module The user programmable blue LED becomes solid once connection is established between the smartphone and WBZ451 module Controls the RGB LED state on/off Controls the color of RGB LED when the LED is “on” Controls the intensity of RGB LED when the LED is “on” Additional information To disconnect the MBD Application running on your smart phone you can do one of the following: Press the reset button on WBZ451 Curiosity Board Initiating a “Scan” on Smartphone App Upon successful disconnection the WBZ451 module starts in Advertisement Mode ",
							" ZigBee Demo Experience The demo consists of the WBZ451 Curiosity board with accompanying ble_zigbee_light_prov (Zigbee Router/Zigbee Lights) Firmware the Amazon Echo or Combined Interface firmware The Amazon Echo or Combined Interface firmware plays the role of Zigbee Coordinator The Coordinator upon reset creates a Zigbee network (Network Forming) and enables permit join for 3 minutes (Network Steering) The Router upon reset sends beacon requests looking for any existing network If a network is found (beacon received from Zigbee Coordinator) the router will join (Network Steering) the existing network To experience the Out of Box demo users need to reset (factory new) the Zigbee Coordinator first followed by a reset (factory new) on the Zigbee Router After a successful connection between the Zigbee Coordinator and the router the router starts sending attributes to the coordinator The Coordinator can control the router's Light On/Off level and color Demo of Zigbee Lights with Amazon Echo as Coordinator Supply power to the WBZ451 Curiosity Board by connecting a USB cable to the kit (PC to WBZ451 Curiosity Board) Discovering Zigbee Lights (Using Voice Commands or the Alexa App) Voice Commands Ask Alexa to discover your device Say “Discover my devices ” Alexa App From the menu select \"Add Device \" Select the type of smart home device “Light” and select other Initiate Discover Devices Note: Echo/Alexa is in discovery mode for 45 secs Devices (Lights/other) wanting to join Echo should initiate joining/connecting procedure within this time limit for a successful join Connecting Zigbee Lights (Router) to Echo (Coordinator) Issue Reset to factory new by pressing and holding the SW2 button for 10 second Users can view the data logs for a better understanding of the demo experience To view the logs - Open a terminal emulator like Teraterm with the following settings (Speed: 115200 Data: 8-bit Parity: none Stop bits: 1 bit Flow control: none LF+CR for tx and rx echo enabled (Use of TeraTerm is not mandatory to experience the demo) The following message will be printed To initiate a connection the user needs to press and hold the SW2 button for 5 secs Router finds the network and joins Note 1: Reset to factory new (using SW2 button press) will erase the Zigbee connection state stored prior to reset and bring up the device as a factory new device Note 2: Reset (SW1 button press) will not clear the Zigbee connection state prior to reset Note 3: After a successful/unsuccessful join process users can also initiate the reset to factory new by entering the command ‘resetToFN’ over UART Note 4: When using more than 1 WBZ451 Zigbee Light users need to reprogram the new kit with different a mac ID Control the on/off state of RGB LEDs Voice commands Ask Alexa “Alexa turn on first light” to change status of RGB LED from off to on Ask Alexa “Alexa Dim first light” to reduce the brightness Ask Alexa “Alexa Turn my first light green” to change the color Alexa App select First Light in “Lights” and control Setup – Zigbee Coordinator (Combined Interface)-Network Creation and Steering Supply Power: Connect a USB cable to the WBZ451 Curiosity Board (zigbee_combined_interface) Open a terminal emulator like Teraterm with the following settings for both the WBZ451 Curiosity boards USB Serial Device COMxx (Speed: 115200 Data: 8-bit Parity: none Stop bits: 1 bit Flow control: none LF+CR for tx and rx echo enabled) Reset the board to factory new (use either step 3 a or 3 b) using button (SW2) press and hold SW2 button for 10 secs send “resetToFN” to Coordinator over UART Note: Combined Interface will have permit join enabled for 180 secs after a successful creation of centralized network Devices (Lights/other) wishing to join the combined interface must initiate the joining/connecting procedure within this time limit in order for the join to be successful Zigbee Router (Lights) Setup – Connecting Zigbee Lights to the Network Supply Power: Connect a USB cable to the WBZ451 Curiosity Board (PC to Board) Issue Reset to factory new by pressing and holding the SW2 button for 10 seconds Users can view the data logs for a better understanding of the demo experience To view the logs - Open a terminal emulator like Teraterm with the following settings (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none LF+CR for tx and rx echo enabled The following message will be printed To initiate a connection user needs to press and hold the SW2 button for 5 secs Router finds the network and joins Zigbee Lights (Router) will search for an existing network to join and after joining an existing network the finding and binding of clusters will be initiated and completed Note: Zigbee Lights(Router) will be in identifying mode and will toggle RGB LED for 3 mins after Finding and Binding is successful Note 1: Resetting to factory new (by pressing the SW2 button) will erase the Zigbee connection state stored prior to the reset and restore the device as a factory new device Note 2: Reset (SW1 button press) will not clear the Zigbee connection state prior to reset Note 3: After a successful or unsuccessful join process users can also initiate the reset to factory new by entering the command ‘resetToFN’ over UART Note 4: When using more than 1 WBZ451 Zigbee Lights users need to reprogram the new kit with different mac ID Monitoring and Control Zigbee Lights (Router) Obtain the Router's Network Address To get the Network Address of Router user should send the getNetworkAddress command (the Router should have completed the joining process) A Command should be entered in terminal window of the Zigbee Router The network address is also displayed on the Zigbee Coordinator device logs Monitor the OnOff status level and Color control of Zigbee lights on the Coordinator After a successful finding and binding the coordinator device receives attributes automatically from the router periodically On/off control of Zigbee lights (RGB LED state) On–Send the following command from Coordinator device over UART: onOff -s 0x8185 0x23 -on Off-Send the following command from Coordinator device over UART: onOff -s 0x8185 0x23 -off Note: \"0x8185\" is the address of the router (Light) the coordinator is trying to control Note: \"0x23\" is the zigbee endpoint of the zigbee light in control Coordinator (Combined Interface-left) and the router (Zigbee Lights-right) ",
							" Multiprotocol (BLE + ZigBee)Demo Experience The demo consists of the WBZ451 Curiosity board with the accompanying ble_zigbee_light_prov firmware and the Microchip Bluetooth Data (MBD) Smartphone App Users can provision the zigbee device over BLE control and monitor the lights and temperature using either the BLE link or Zigbee link using the MBD app and Alexa App respectively MBD app has the capability to scan for BLE advertisements from the WBZ451 module and to establish a connection There are multiple sub apps in the Microchip Bluetooth Data App for showcasing the provisioning and control/monitor capabilities over BLE The BLE Scan operation helps monitor the following parameters before connection Zigbee Device Name Temperature Sensor RGB LED Status (on or off) The BLE Connection operation helps monitor the following parameters Zigbee Device Status Device Type Current Channel Current MAC ID Device State SW Version Device Name Temperature Sensor RGB LED Status (on or off) BLE Device Information Service Manufacturer Name Model Number Serial Number Hardware Revision Firmware Revision Software Revision System ID Regular Certification Data List BLE Connection operation helps control the following parameters Zigbee Device Connection Params Current Channel Device Name RGB LED Status (on or off) Controls the color and intensity of RGB LED when LED is “on” When using an Amazon Echo as a Zigbee Coordinator Alexa App helps control the following parameters When the RGB LED is \"on \" it controls the color and intensity of the LED When using another WBZ451 Curiosity Board as a Zigbee Coordinator UART commands can be used to control the following parameters RGB LED Status (on or off) Controls the color and intensity of RGB LED when LED is “on” The multiprotocol demo experience starts with provisioning the Zigbee Device then a successful zigbee connection followed by the control/monitor of Lights over both the Zigbee and BLE links Multiprotocol Light Demo with Amazon Echo as Coordinator Supply power to the WBZ451 Curiosity Board by connecting a USB cable to the kit (PC to WBZ451 Curiosity Board) The Discovery of Zigbee Lights Voice Commands Ask Alexa to discover your device Say “Discover my devices ” Alexa App From the menu select \"Add Device \" Select the type of smart home device “Light” and select other Initiate Discover Devices Note: Echo/Alexa is in discovery mode for 45 secs Devices (Lights/other) wanting to join Echo should initiate the joining/connecting procedure within this time limit for a successful join Provisioning - Connecting Zigbee Lights (Router) to Coordinator (Combined Interface/Amazon Echo) Issue Reset to factory new (Use either 1 a or 1 b) using button (SW2) press and hold SW2 button for 10 secs Users can view the data logs for a better understanding of the demo experience To view the logs - Open a terminal emulator like Teraterm with following settings (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none LF+CR for tx and rx echo enabled (Use of TeraTerm is not mandatory to experience the demo) Open Microchip Bluetooth Data (MBD) App select BLE Provisioning - Coming Soon- COMBO_LIGHT_9393 - Factory Reset The following message will be printed in the terminal window post a successful reset to factory new To scan for nearby WBZ451 devices running the Multiprotocol demo open Microchip Bluetooth Data (MBD) App select “BLE Provisioning” and select the “Coming Soon” option Scan operation will find – COMBO_LIGHT_xxxx device in results select this device After selecting the device status will be displayed Users can now either change the device name or move ahead to provisioning the device keeping the device name as default Select the \"Provision\" option in the MBD App to configure channel map Channel map needs to be chosen and select commission (In channel Map select all the channels before selecting commision unless user is aware of channel on which Echo is operating on) When the commission option is selected the device begins to search for an existing zigbee network to join When the device joins the existing network created by Amazon Echo a 180-second finding and binding process begins Note: Echo device must be in discovery mode when selecting the commission option Upon completion of 180 seconds the Commissioning process is completed Users can select \"ok\" Device State changes from “Not Commissioned” to “Commissioned” Multiprotocol Control/Monitor of Lights using BLE (MBD App) Monitor RGB LED state and Temperature The WBZ451 Curiosity board begins in advertisement mode allowing access to RGB LED on/off state and temperature sensor data and advertising its presence to a smartphone Navigate through the Smartphone App as shown in the following Figure to access the advertisement information Control RGB LED on/off status as well as intensity and color Click the device that shows up after initiating a scan to establish a connection with the WBZ451 module The user programmable blue LED becomes solid once connection is established between the smartphone and WBZ451 module Controls the RGB LED state on/off Controls the color of RGB LED when LED is “on” Controls the intensity of RGB LED when LED is “on” The light status (on/off) light color and intensity chosen via the BLE link will be relayed on to Alexa App Multiprotocol Control/Monitor of Lights using Zigbee (Alexa App) Lights Getting Found and Connected to Echo Control the on/off status of RGB LEDs Voice commands Ask Alexa “Alexa Turn on first light” to change status of RGB LED from off to on Ask Alexa “Alexa Dim first light” to reduce the brightness Ask Alexa “Alexa Turn my first light green” to change the color Alexa App select First Light in “Lights” and control The Light Status (on/off) light color and intensity chosen via the voice commands/Alexa App (Zigbee link) will be relayed on to the MBD App (BLE Sensor App) Setup: Multiprotocol Lights Demo with another WBZ451 Curiosity Board as Coordinator Setup – Zigbee Coordinator (Combined Interface) - Network Creation and Steering BLE Provisioning - Lights to join the Zigbee network created by another WBZ451 Curiosity Board as Coordinator After completing steps 1 and 2 lights can be controlled by MBD App over BLE or Zigbee Commands Turn on the light with the MBD App via the BLE link Turn on the RGB LEDs The light status (on/off) light color and intensity chosen via the MBD App (BLE link) will be relayed on to Multiprotocol lights (Zigbee link) Turn off the light with the MBD App via the Zigbee link Off-Send the following command from the Coordinator device over UART (\"0xf9e\" is the router address and \"0x23\" is the zigbee endpoint of the zigbee light in control): onOff -s 0xf93e 0x23 -off The light status (on/off) light color and intensity chosen via the Zigbee Coordinator UART commands (Zigbee link) will be relayed on to the MBD App (BLE Sensor App) ",
							" Next Steps How to start developing your application The WBZ451 Curiosity Board is a fully functioning MCU for prototyping and developing your next BLE/Zigbee Application Once you a finished experimenting with the preprogrammed demo it is time to get your hands dirty and start building When you are ready to start developing code we recommend first reading the Getting Started with Software Development Guide Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC After you have set up your development environment then you can find (and compile and reprogram if necessary) the source code that implements the Preprogrammed Demo Software Preprogrammed BLE+Zigbee Application demo experience from the Harmony 3 github repository Documentation and link to the repository can be found in BLE Zigbee Light Prov ",
							" Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC  Prior to each release our Wireless Stack and Application Examples are thoroughly tested against a snapshot of tool versions and other software dependencies This guide will walk you through setting up your development environment with all required dependencies versions  Each section of this Guide will describe in detail the steps to fulfill all dependencies If you are already familiar Microchip Tools then you can find a table summarizing the dependencies below   Tools and Harmony Component Versions    Tool Chain         IDE Compiler and MCC plugin    Version    Location      MPLAB X IDE    6 00 or above    Web      XC32 Compiler    v4 10 or above    Web      Microchip Code Configurator(MCC)    5 1 9 or above    MPLAB X IDE Tools Plugins Installing MPLAB Code Configurator Plugin         Harmony Components        Harmony components to be cloned with MCC Content Manager    Version      csp    3 13 0      core    3 11 0      mhc    3 8 3      dev_packs    3 13 0      bsp    3 13 0      CMSIS-FreeRTOS    10 3 1      crypto    3 7 4      wolfssl    4 7 0      PIC32CX-BZ_DFP    1 0 107      wireless_ble    1 0 0      wireless_system_pic32cxbz_wbz    1 1 0      wireless_apps_pic32cxbz2_wbz45    1 1 0      wireless_pic32cxbz_wbz    1 1 0     wireless_zigbee  5 0 0      ",
							" Install IDE and Compiler Links to Install MPLAB x IDE and Compiler Install the MPLAB X IDE Install the XC32 Compiler ",
							" Install Device Family Part Pack PIC32CXBZ2 Device Support is handled by Device Family Part Pack installation  Installing PIC32CXBZ2 DFP   Open the MPLAB X IDE and Select Tools Packs  Search for \" BZ2 \" in the search box available and select \"install\"   Introduction to DFP gives background information on usage of Device Family Part Pack in application development ",
							" Install MCC Plugin Installing MPLAB Code Configurator Plugin Install MCC Plugin in the IDE Install MCC Plugin Install MCC Plugin Plugins Plugins MPLAB Code Configuration Plugin Configure the plugin options Plugin Options Several aspects of the operation of the MCC can be managed by using the “Options” panel (see figure below) which can be invoked by clicking Tools → Options → Plugins → MPLAB Code Configurator in the menu bar of the MPLAB X IDE ",
							" Install Harmony 3 Dependencies This section will describe in detail how to install the correct versions of the required Harmony 3 component dependencies The following table summarizes the components and versions that will be installed   Harmony Components        Harmony components to be cloned with MCC Content Manager    Version      csp    3 13 0      core    3 11 0      mhc    3 8 3      dev_packs    3 13 0      bsp    3 13 0      CMSIS-FreeRTOS    10 3 1      crypto    3 7 4      wolfssl    4 7 0      PIC32CX-BZ_DFP    1 0 107      wireless_ble    1 0 0      wireless_system_pic32cxbz_wbz    1 1 0      wireless_apps_pic32cxbz2_wbz45    1 1 0      wireless_pic32cxbz_wbz    1 1 0     wireless_zigbee  5 0 0      Clone the Harmony repositories using MCC Content Manager Wizard Create a new “MCC Harmony” project (In order to clone the Harmony repositories user needs to create an empty project and clone the required repositories)  Select \"New Project\"  New Project Creation      Select \"32-bit MCC Harmony Project\"  MCC Harmony Project option       Framework Selection  Framework Selection   Local PC directory where cloned repos would be placed       Project Settings  Project Settings   Project Folder Path and Name Selection       Configuration Settings and select the device WBZ451   Configuration Settings  Device Name and Configuration Settings     Open “MPLAB Code Configurator” after creation of project MCC Content Manager window will appear in IDE    MCC in IDE        Select “MPLAB Harmony” from the content manager window  MCC Content Manager window      Select \"Optional Content\" as shown below  Optional Content Window MCC     Ensure all components are selected as displayed in the image below Ignore version selection for now it will be taken care of at a later stage  Required Content       Select “Finish” The downloading of selected components from harmony repositories will take some minutes If all the selected components are cloned successfully MCC logs in IDE will display this information    MCC Logs Snapshot when all selected components are cloned successfully       If in the process a failure to download a particular component appears try redownloading again only the component that failed to download For example if user received a prompt from MCC saying “dev_packs” was not download  close the MCC reopen MCC again and start from step 3 in this section with the “dev_packs” as the only missing component for downloading and select “Finish”     \"dev_packs\" being redownloaded        Select/Confirm the Harmony Framework Path    Harmony Framework Path Selection     Note: Framework Path selection window appears beneath the Initializing Project pop-up users should Choose Path as “C: mchp”   Framework Selection Path    Project Graph Window will appear after choosing the framework path and successful initialization of project  Project Graph      Change to content versions recommended for use during development in the table using the content manager from Device Resources and select “Apply” This step is important and should be followed by user as every wireless stack and app example release is tested with certain version of dependant component  Changing content versions   After successfully checking out the right version of content/components users can start developing application examples Stack Peripherals and other documentation  ",
							" Creating a new MCC Harmony Project 1 Create a new 32-bit MPLAB MCC Harmony Project 2 Select the Framework Path (Framework path must match SDK setup document)and select Next 3 Select Project Folder and select Next 4 Select the device and click Finish or 5 MPLABx Code Configurator will be launched automatically 6 Select \"Next\" 7 Select \"MPLAB Harmony\" 8 Select \"Finish\" 9 Project Graph window of the Configurator may have predefined components 10 Project and Device resources ",
							" Running a Precompiled Application Example Here is how to open build and program an existing application example Prerequisites Install MPLAB X IDE Links to Install MPLAB x IDE and Compiler Install XC32 Compiler Links to Install MPLAB x IDE and Compiler Install Device Family Part Pack PIC32CXBZ2 Device Support is handled by Device Family Part Pack installation Install MCC Plugin Installing MPLAB Code Configurator Plugin Install Harmony 3 Dependency Open Build and Program an existing application example Connect Curiosity Board to the PC using usb cable Open MPLAB X IDE Select File Open Project Browse to project location of choice (In this example we will open \"ble_sensor_app\") project select project from location \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble advanced applications ble_sensor firmware\"   If multiple projects are open within IDE IDE may not choose to build/program the \" ble_sensor \" project  Select the \" ble_sensor \" project Right click and select the setting \"Set as Main Project\"   Information related to the workings of the application example are available in readme md file available in the ble_sensor folder Open Project Properties Select WBZ451 Curiosity Board as hardware tool for programming Ensure correct DFP v1 0 xx is selected as mentioned in the Tools and Harmony Components Select XC32 compiler Select option Build Project in IDE to compile the application example Select option Run Project in IDE to program the target – the onboard debugger will program the example application Note: A smartphone App might be needed to explore the full feature set of BLE Application examples ",
							" Next Steps Stack Peripherals and other documentation Users who have completed the installation of tool chain and Harmony Components as mentioned in Getting Started with Software development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC can start developing their application using the following documentation BLE Stack Documenation Guides user on what API's are required to implement wireless BLE application Device Support Library Documentation It gives common system services like device driver library persistence data server library standalone bootloader and Bootloader services These services are created as components in Harmony Application Example Documentation Documentation describing steps to test and develop the precompiled BLE application examples Develop App examples from scratch Advanced Applications Adding Chip Peripherals to Application Guidance on how to add analog/digital peripherals to your application Device Firmware Upgrade This section documents how to enable FW updates in your design whether its serial or over the air ",
							" BLE Applications Documentation describing steps to test and develop the precompiled BLE application examples The BLE Application examples are divided into 2 categories There are both simple precompiled examples that can be tested by observing blinking LEDs on the board and more complex examples that can communicate with your smartphone using Bluetooth low energy These precompiled examples do not require you to set up the full toolchain Therefore programming and testing them should not take more than a few minutes Building Blocks - Building Blocks are training modules that teach users how to create a basic BLE application from scratch Each block demonstrates a basic BLE function such as \"How to Enable Legacy Adv \" \"How to Enable Long Range Advertising \" and so on This is recommended for users who are new to the Microchip BLE stack and other tool chains like MPLAB Code Configurator Advanced Applications - Advanced Applications are for users who are familiar with the Microchip BLE stack running on the PIC32CXBZ2 family of devices and also with the MPLAB Code Conigurator tool chain Advanced applications demonstrate features like hight throughput functionality monitoring and control of sensor and light functionality and automatic advertisement when a connection is lost ",
							" Building Block Examples This section covers PIC32CXBZ2 Application Building Blocks Building blocks are compact training modules revolving around implementing a particular BLE functionality/feature on PIC32CXBZ2 and WBZ451 Devices These training modules ease users' development experience by providing a step-by-step procedure to build a BLE Feature from Scratch Moving through the building blocks users will be able to gain familiarity with the SDK MPLAB Harmony software development framework MPLAB Code Configurator and API's necessary for implementing the BLE features of interest Users who have working knowledge of BLE and no familiarity with the Harmony framework Microchip BLE SDK tools etc are recommended to start their SW development process with Building Blocks New MPLAB Code Configurator users are recommended to go through the overview  Building blocks are divided into 3 categories based on the device roles and features users are interested in developing This segregation is important as users interested in developing only a certain type of device would be provided only the training modules and necessary reference examples related to the device type Peripheral Building Blocks Central Building Blocks Multirole Building Blocks ",
							" Central BLE Central devices are devices that discover and listen to BLE devices that are advertising These devices are capable of establishing connection to peripherals Central devices are also capable of establishing multiple connections(multilink) at the same time There are certain use cases where a connection between the devices (Peripheral Central) is not essential and scanning (Receive only no transmit) feature alone is sufficient These type of devices are called observers Tip: New MPLAB Code Configurator Users are recommended to go through the overview  Prerequisites Install tool chain and harmony components documented in Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC section Blocks  FreeRTOS and BLE Stack Setup Create a new MCC Harmony project configure Harmony components like FreeRTOS and BLE Stack Init BLE Stack  Adding UART print Hello World  Legacy Scan Receive Data Payload using BLE Legacy Scan(no BLE connection)  Scan Extended Advertisment Receive Data Payload using BLE Extended Scan(no BLE connection)  Connection Configure stack for Central Functionality Connection between Peripheral and Central Device Profiles and services  Microchip propreitary - Transparent UART Central (Legacy Scan + Connection + Data Exchange) Data Exchange using Microchip Transparent UART profile and service between 2 devices(peripheral and central) after a BLE connection  Multilink - Transparent UART Central (Legacy Scan + Multilink Connection + Data Exchange between Multiple Links) Data exchange using Microchip Transparent UART profile and service between 4 devices (1 central and 3 peripherals) after a BLE connection ",
							"  Central - FreeRTOS BLE Stack and App Initialize  Getting Started  Getting Started with Central Building Blocks  FreeRTOS and BLE Stack Setup   --  Adding UART  --  Legacy Scan Introduction This document will help users create a new MCC Harmony project configure FreeRTOS component and BLE stack component in the project generate code using the MPLAB MCC framework These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification Hardware Required None Software Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Steps to Init BLE Stack This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New MPLAB Code Configurator Users are recommended to go through the overview of the plugin Create a new MCC Harmony Project -- link for instructions Open MPLAB Code Configurator Default MPLAB Code Configurator window Click Plus Symbol the BLE Stack component on to the project graph (BLE Stack is part of Wireless Component) Upon BLE Stack being added to project graph the different component dependencies will be requested to be added User has to select \"yes\" to add all the dependant component Activate the components (snapshot below does not cover all the necessary components that need to be activated Users are expected to select \"yes\" for all dependant components) Verify Project Graph Display FreeRTOS component configuration options by Selecting the component in Project Graph Tip: Upon selecting any component the default configuration options available for user are displayed Configure FreeRTOS component to the following The configuration chosen here should suit most application needs users are recommended to follow the FreeRTOS Customization documented here to meet their needs Display BLE Stack component configuration options by Selecting the component in Project Graph Default Configuration: Peripheral Device functionality is enabled by default Central configuration needs to enabled and peripheral configuration should be unchecked  Generate Code Switch to MPLAB X IDE window and Build Project The project should compile successfully Ensure correct compiler version as suggested in development environment Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC is chosen Build Project upon building project user action is required as mentioned here Where to go from here  UART ",
							" BLE Legacy Scan  Getting Started  Getting Started with Central Building Blocks  Adding UART  --  Legacy Scan  --  BLE Connection Introduction This document will help users to enable BLE Scanning on WBZ451 Curiosity board using MPLAB Code Configurator(MCC) BLE Scanning is scanning for devices that are advertising In BLE a central or observer always starts with scanning Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity Board and experience the demo or can go through the steps involved in developing this Application from scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification FreeRtos BLE App Initialize  Adding UART Hardware Required  Tool  Qty WBZ451 Curiosity Board 1 Micro USB cable 1 SDK Setup Getting Started with Sofware Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Software  TeraTerm Smartphone App None Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central legacy_scan hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"legacy_scan x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central legacy_scan firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description This Application Example enables users to do passive scanning After programming the Application Example on reset user will be able to see the beginning of scan operation the Bluetooth addresses of devices scanned for the next 10 seconds the end of scanning operation Testing Connect the WBZ451 Curiosity board to PC program the precompiled hex file or application example as mentioned Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Scanning\" message is displayed on the TeraTerm Once scan operation has begun user will be able to display all the Bluetooth addresses that are advertising on channel 37 38 and 39 After 10 secs \"Scan Completed\" message is sent out Tera Term Users can use another WBZ451 Curiosity Board configured as BLE Advertiser set the address and scan Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project -- link for instructions Import component configuration -- This step helps users setup the basic components and configuration required to develop this application The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central legacy_scan firmware legacy_scan X\" Users should follow the instructions mentioned here to import the component configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Scan Configuration Select BLE_Stack component in project graph Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers Autogenerated Scan Parameters  Source Files  Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble app_ble_handler c All GAP GATT SMP and L2CAP Event handlers Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application | Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file Function Calls MCC generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c User Application Development Include user action is required as mentioned here definitions h in all the files where UART will be used to print debug information Tip: definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised Start Scanning BLE_GAP_SetScanningEnable(true BLE_GAP_SCAN_FD_ENABLE BLE_GAP_SCAN_MODE_OBSERVER 100); This API is called in the Applications initialstate - APP_STATE_INIT in app c Scan duration is 10 secs Scan Results BLE_GAP_EVT_ADV_REPORT event is generated upon finding Adverstisements on legacy channels // code snippet to print scan results uint8_t scanAddr[12]; //var to store ASCII address BLE_GAP_EvtAdvReport_T scanResults; scanResults addr = p_event- eventField evtAdvReport addr; APP_HexToAscii(6 scanResults addr addr scanAddr); SERCOM0_USART_Write((uint8_t *)\"0x\" 2); SERCOM0_USART_Write((uint8_t *)scanAddr 12); SERCOM0_USART_Write((uint8_t *)\" r n\" 2); // function to convert HEX to ASCII static void APP_HexToAscii(uint8_t byteNum uint8_t *p_hex uint8_t *p_ascii) { uint8_t i j c; uint8_t digitNum = byteNum * 2; if (p_hex == NULL || p_ascii == NULL) return; for (i = 0; i digitNum; i++) { j = i / 2; c = p_hex[j] 0x0F; if (c = 0x00 c = 0x09) { p_ascii[digitNum - i - 1] = c + 0x30; } else if (c = 0x0A c = 0x0F) { p_ascii[digitNum - i - 1] = c - 0x0A + 'A'; } p_hex[j] /= 16; } } Scan Timeout Event In app_ble_handler c BLE_GAP_EVT_SCAN_TIMEOUT event is generated when BLE Scan duration expires Users can exercise various other BLE Advertisement functionalities by using BLE Stack API Where to go from here  BLE Connection ",
							" BLE Scanning Extended Advertisements  Getting Started  Getting Started with Central Building Blocks  Adding UART  --   Extended Advertisements (you are here) Introduction This document will enable scanning of Extended Advertisements (ADV_EXT_IND ADV_AUX_IND) on WBZ451 Curiosity board For a successful scan of Extended Advertisement user needs to have a broadcaster transmitting these Advertisements In BLE a central or observer always starts with scanning Usage of scan_ext_adv Application example in combination with ext_adv example will enable users to test features like long range (Coded PHY) and sending data (1M 2M Coded PHY) over extended advertisements Users can run run the precompiled Application Example hex file on the WBZ451 Curiosity Board and go through the steps involved in developing this Application from scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification FreeRtos BLE App Initialize  Adding UART Hardware Required  Tool  Qty WBZ451 Curiosity Board 2 Micro USB cable 2 SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Software  TeraTerm Smartphone App None Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central scan_ext_adv hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"scan_ext_adv x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central scan_ext_adv firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description This Application Example enables users to do scanning of Extended Advertisements (ADV_EXT_IND ADV_AUX_IND PDU's) Scanning of CODED PHY (125 kbps) is enabled by default in the application After programming the Application Example on reset \"ExtAdv Scan Enable Success\" will be printed in the terminal window and if there is a broadcaster sending extended advertisements the Green LED will toggle If this broadcaster is another WBZ451 module programmed with ext_adv example it will print the Application Data sent in Auxiliary packet - ADV_AUX_IND on TeraTerm (115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Green LED toggles denote the reception of Extended Advertisements Testing Users should use another WBZ451 Curiosity Board configured as BLE Ext Adv This section assumes that a user has already programmed the ext_adv and scan_ext_adv application on 2 WBZ451 Curiosity Boards Board1 = WBZ451 Curiosity Board with Ext Adv Programmed Board2 = WBZ451 Curiosity Board with Scan Ext Adv Programmed Board1: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Ext Adv Enable\" message is displayed on the TeraTerm Board2: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"ExtAdv Scan Enable Success\" message is displayed on the TeraTerm \"Microchip\" message will be displayed as soon the WBZ451 module performs an extended advertisement scan Data from advertiser is sent every 2 secs Green LED is toggled when the observer device receives these extended advertisements Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project - instructions Import component configuration -- This step helps users setup the basic components and configuration required to develop this application The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central scan_ext_adv firmware scan_ext_adv X \" Users should follow the instructions mentioned here to import the component configuration Tip: Import and Export functionality of component configuration will help users to start from a known working setup of configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Scan Configuration Select BLE_Stack component in project graph Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers Configuration for scanning extended advertisements is autogenerated Source Files Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble app_ble_handler c All GAP GATT SMP and L2CAP Event handlers app_user_edits c User Code Change instruction Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application | Header Files ble_gap h (Header Files config default ble lib include )- This header file contains BLE GAP functions and is automatically included in the app c file Function Calls MCC generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c User Application Development Include definitions h in all the files where UART will be used to print debug information Tip: definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised user action is required as mentioned User Action Enable Scanning of Extended Advertisement BLE_GAP_SetExtScanningEnable(BLE_GAP_SCAN_MODE_OBSERVER extScan ); API's mentioned in this section are called in the Applications initial state - APP_STATE_INIT in app c Configure LED Add the following piece of code in GPIO_Initialize() available in - Source Files config default peripheral gpio plib_gpio c GPIOB_REGS- GPIO_LAT = 0x0; /* Initial Latch Value */ GPIOB_REGS- GPIO_TRISCLR = 0x8; /* Direction Control */ GPIOB_REGS- GPIO_ANSELCLR = 0x8; /* Digital Mode Enable */ Scan Results BLE_GAP_EVT_EXT_ADV_REPORT event is generated upon finding Adverstisements on legacy channels // code snippet to print ext adv data // GPIO will toggle if it can scan any EXT ADV PDU near based on BLE_GAP_SCAN_PHY chosen GPIOB_REGS- GPIO_PORTINV = 0x08; // length value of 19 is chosen as a filter as ext_adv example sends 19 bytes of data // user can modify filter mechanism based on their requirements if (p_event- eventField evtExtAdvReport length == 19) { SERCOM0_USART_Write((uint8_t *)\" r n\" 2); SERCOM0_USART_Write( p_event- eventField evtExtAdvReport advData[5] 9); } Users can exercise various other BLE Scanning functionalities by using BLE Stack API Where to go from here  Getting Started with Central Building Blocks ",
							" BLE Connection  Getting Started  Getting Started with Central Building Blocks Legacy Scan  --  BLE Connection  --  BLE Transparent UART Introduction This document will help users to enable scan and connect functionality on the BLE Central Device ( WBZ451 ) For a successful BLE connection ADVERTISER must start sending advertisement packets on the three primary advertisement channels (or a subset of these channels) This allows the devices scanning for advertisers to find then and read their advertisement data the scanner can initiate a connection if advertiser allows it To demonstrate a BLE Connection on WBZ451 we need 2 device types Advertiser (Transmitting Connectable Adv) Scanner Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity Board and experience the demo or can go through the steps involved in developing this Application from scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification FreeRtos BLE App Initialize  BLE Legacy Scan Hardware Required  Tool  Qty WBZ451 Curiosity Board 2 Micro USB cable 2 SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Software  TeraTerm Smartphone App None Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central central_conn hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"central_conn x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central central_conn firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description To experience this demo users are required to use central_connection and peripheral_connection application examples The 2 Application Example mentioned above will demonstrate a BLE Connection Establishment Process An advertiser (Peripheral) will start connectable scannable undirected BLE advertisement and the scanner (Central) will receive the advertisements and initiate a BLE connection enables users to transmit Connectable and Scannable Undirected BLE Advertisements Demo will print start of the scanning \"Scanning\" connected \"Connected \" and disconnected \"Disconnected\" \"Disconnected\" state on a terminal emulator like TeraTerm@ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Testing Users should use another WBZ451 Curiosity Board configured as peripheral connection This section assumes that a user has already programmed the peripheral_conn and central_conn application on 2 WBZ451 Curiosity Boards Board1 = WBZ451 Curiosity Board with peripheral_conn application Programmed Board2 = WBZ451 Curiosity Board with central_conn applicaton Programmed Board1: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Advertising\" message is displayed on the TeraTerm Board2: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Scanning\" message is displayed on the TeraTerm Upon finding peripheral device with public address {0xA1 0xA2 0xA3 0xA4 0xA5 0xA6} message \"Found Peer Node\" will be displayed and a connection request will be initiated \"Initiating connection\" Note: Scanner is configured to scan only for 100 secs user should ensure the peer device is advertising After connection establishment both the peripheral device (Board1) and central device(Board2) will display \"Connected \" message on respective terminal windows Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project -- link for instructions Import component configuration -- This step helps users setup the basic components and configuration required to develop this application The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central central_conn firmware central_conn X\" Users should follow the instructions mentioned here to import the component configuration Tip: Import and Export functionality of Harmony component configuration will help users to start from a known working setup of MCC configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Scan and Connection Configuration Select BLE_Stack component in project graph Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers  Source Files  Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble app_ble_handler c All GAP GATT SMP and L2CAP Event handlers Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application | Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file Function Calls MPLAB Code Configurator generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c User Application Development Include user action is required as mentioned here definitions h in all the files where UART will be used to print debug information Tip: definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised Start Scanning BLE_GAP_SetScanningEnable(true BLE_GAP_SCAN_FD_ENABLE BLE_GAP_SCAN_MODE_OBSERVER 1000); This API is called in the Applications initialstate - APP_STATE_INIT in app c Scan duration is 100 secs Scan Results and initiating a BLE connection BLE_GAP_EVT_ADV_REPORT event is generated upon finding Adverstisements on legacy channels BLE connection can be initiated by using the API BLE_GAP_CreateConnection( createConnParam_t); // code snippet to filter scan results and initiate connection if (p_event- eventField evtAdvReport addr addr[0] == 0xA1 p_event- eventField evtAdvReport addr addr[1] == 0xA2) { SERCOM0_USART_Write((uint8_t *)\"Found Peer Node r n\" 17); BLE_GAP_CreateConnParams_T createConnParam_t; createConnParam_t scanInterval = 0x3C; // 37 5 ms createConnParam_t scanWindow = 0x1E; // 18 75 ms createConnParam_t filterPolicy = BLE_GAP_SCAN_FP_ACCEPT_ALL; createConnParam_t peerAddr addrType = p_event- eventField evtAdvReport addr addrType; memcpy(createConnParam_t peerAddr addr p_event- eventField evtAdvReport addr addr GAP_MAX_BD_ADDRESS_LEN); createConnParam_t connParams intervalMin = 0x10; // 20ms createConnParam_t connParams intervalMax = 0x10; // 20ms createConnParam_t connParams latency = 0; createConnParam_t connParams supervisionTimeout = 0x48; // 720ms SERCOM0_USART_Write((uint8_t *)\"Initiating Connection r n\" 23); BLE_GAP_CreateConnection( createConnParam_t); } Connected Disconnected Events All the possible GAP GATT SMP and L2CAP Event handlers are available in file app_ble_handler c users can implement application code to denote Connection State here BLE_GAP_EVT_CONNECTED event is generated after a successful BLE Connection with peripheral device Scan Timeout Event In app_ble_handler c BLE_GAP_EVT_SCAN_TIMEOUT event is generated when BLE Scan duration expires Users can exercise various other BLE Advertisement functionalities by using BLE Stack API Where to go from here BLE Transparent UART ",
							" BLE Transparent UART  Getting Started  Getting Started with Central Building Blocks BLE Connection  -- BLE Transparent UART(you are here)  --  BLE Multilink Transparent UART Introduction This document will help users create a central device and send/receive characters between 2 connected BLE devices over Microchip proprietary Transparent UART Profile The central and peripheral devices in this tutorial are 2 WBZ451 devices The instructions mentioned below are applicable for a BLE Central device Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity board and experience the demo or can go through the steps involved in developing this Application from scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification BLE Connection(central) Hardware Required  Tool  Qty WBZ451 Curiosity Board 2 Micro USB cable 2 SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Software  TeraTerm Smartphone App None Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central profiles_services central_trp_uart hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"central_trp_uart x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central profiles_services central_trp_uart firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description Upon programming the demo application central device ( WBZ451 ) will start scanning for near by peripheral devices to connect After a connection has been made data can be sent back and forth over UART between the two devices that are connected Demo will print start of the scanning \"Scanning\" connected \"Connected \" and disconnected \"Disconnected\" state on a terminal emulator like TeraTerm@ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Application Data to be sent to the connected peripheral device should be entered in the terminal emulator Testing Users should use another WBZ451 Curiosity Board configured as BLE Transparent UART(peripheral) Demo Experience when using 2 WBZ451 Curiosity boards configured as Peripheral and Central device This section assumes that a user has already programmed the peripheral_trp_uart and central_trp_uart application on 2 WBZ451 Curiosity Boards Board1 = WBZ451 Curiosity Board with peripheral_trp_uart application Programmed Board2 = WBZ451 Curiosity Board with central_trp_uart applicaton Programmed Board1: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Advertising\" message is displayed on the TeraTerm Board2: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Scanning\" message is displayed on the TeraTerm Upon finding peripheral device with public address {0xA1 0xA2 0xA3 0xA4 0xA5 0xA6} message \"Found Peer Node\" will be displayed and a connection request will be initiated \"Initiating connection\" Note: Scanner is configured to scan only for 100 secs user should ensure the peer device is advertising After connection establishment both the peripheral device (Board1) and central device(Board2) will display \"Connected \" message on respective terminal windows Users can now start sending data back and forth between the central and peripheral device using the terminal emulator Characters entered on either terminals will immediately be sent to the peer devices Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator(MCC) are recommended to go through the overview  Create a new MPLAB MCC Harmony Project -- link for instructions Import component configuration -- This step helps users setup the basic components and configuration required to develop this application The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central profiles_services central_trp_uart firmware central_trp_uart X\" Users should follow the instructions mentioned here to import the component configuration Tip: Import and Export functionality of component configuration will help users to start from a known working setup of configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Scan Connection and Transparent UART Profile Configuration Select BLE_Stack component in project graph Select Transparent Profile component in project graph Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers  Source Files  Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble app_ble_handler c All GAP GATT SMP and L2CAP Event handlers app_ble app_trspc_handler c All Transparent UART Client related Event handlers ble_trspc c All Transparent Client Functions for user application app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file ble_trspc h is the Header File associated with API’s and structures related to BLE Transparent Client functions for Application User Function Calls MCC generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c User Application Development Include \"ble_trspc h\" in app c BLE Transparent UART Server related API's are available here \"osal/osal_freertos_extend h\" in app_trsps_handler c OSAL related API's are available here definitions h in all the files where UART will be used to print debug information Tip: definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised user action is required as mentioned here Start Scanning BLE_GAP_SetScanningEnable(true BLE_GAP_SCAN_FD_ENABLE BLE_GAP_SCAN_MODE_OBSERVER 1000); This API is called in the Applications initialstate - APP_STATE_INIT in app c Scan duration is 100 secs Scan Results and initiating a BLE connection BLE_GAP_EVT_ADV_REPORT event is generated upon finding Adverstisements on legacy channels BLE connection can be initiated by using the API BLE_GAP_CreateConnection( createConnParam_t); // code snippet to filter scan results and initiate connection if (p_event- eventField evtAdvReport addr addr[0] == 0xA1 p_event- eventField evtAdvReport addr addr[1] == 0xA2) { SERCOM0_USART_Write((uint8_t *)\"Found Peer Node r n\" 17); BLE_GAP_CreateConnParams_T createConnParam_t; createConnParam_t scanInterval = 0x3C; // 37 5 ms createConnParam_t scanWindow = 0x1E; // 18 75 ms createConnParam_t filterPolicy = BLE_GAP_SCAN_FP_ACCEPT_ALL; createConnParam_t peerAddr addrType = p_event- eventField evtAdvReport addr addrType; memcpy(createConnParam_t peerAddr addr p_event- eventField evtAdvReport addr addr GAP_MAX_BD_ADDRESS_LEN); createConnParam_t connParams intervalMin = 0x10; // 20ms createConnParam_t connParams intervalMax = 0x10; // 20ms createConnParam_t connParams latency = 0; createConnParam_t connParams supervisionTimeout = 0x48; // 720ms SERCOM0_USART_Write((uint8_t *)\"Initiating Connection r n\" 23); BLE_GAP_CreateConnection( createConnParam_t); } Connected Disconnected Events In app_ble_handler c BLE_GAP_EVT_CONNECTED event will be generated when a BLE connection is completed Connection Handler Connection handle associated with the peer peripheral device needs to be saved for data exchange after a BLE connection p_event- eventField evtConnect connHandle has this information Transmit Data Add \"APP_MSG_UART_CB\" to the generated APP_MsgId_T BLE_TRSPC_SendData(conn_hdl 1 data); is the API to be used for sending data towards the central device Note: The precompiled application example uses a UART callback to initiate the data transmission upon receiving a character on UART Example Implementation for Transmitting the received data over UART using the BLE_TRSPC_SendData API uint16_t conn_hdl;// connection handle info captured @BLE_GAP_EVT_CONNECTED event uint8_t uart_data; void uart_cb(SERCOM_USART_EVENT event uintptr_t context) { APP_Msg_T appMsg; // If RX data from UART reached threshold (previously set to 1) if( event == SERCOM_USART_EVENT_READ_THRESHOLD_REACHED ) { // Read 1 byte data from UART SERCOM0_USART_Read( uart_data 1); appMsg msgId = APP_MSG_UART_CB; OSAL_QUEUE_Send( appData appQueue appMsg 0); } } void APP_UartCBHandler() { // Send the data from UART to connected device through Transparent service BLE_TRSPC_SendData(conn_hdl 1 uart_data); } // Register call back when data is available on UART for Peripheral Device to send // Enable UART Read SERCOM0_USART_ReadNotificationEnable(true true); // Set UART RX notification threshold to be 1 SERCOM0_USART_ReadThresholdSet(1); // Register the UART RX callback function SERCOM0_USART_ReadCallbackRegister(uart_cb (uintptr_t)NULL); //If msg received in Queue handle the Queue message based on msgID if (OSAL_QUEUE_Receive( appData appQueue appMsg OSAL_WAIT_FOREVER)) { if(p_appMsg- msgId==APP_MSG_BLE_STACK_EVT) { // Pass BLE Stack Event Message to User Application for handling APP_BleStackEvtHandler((STACK_Event_T *)p_appMsg- msgData); } else if(p_appMsg- msgId==APP_MSG_BLE_STACK_LOG) { // Pass BLE LOG Event Message to User Application for handling APP_BleStackLogHandler((BT_SYS_LogEvent_T *)p_appMsg- msgData); } else if(p_appMsg- msgId==APP_MSG_UART_CB) { // Transparent UART Client Data transfer Event APP_UartCBHandler(); } } Receive Data BLE_TRSPC_EVT_RECEIVE_DATA is the event generated when data is sent from central device Users need to use the BLE_TRSPC_GetDataLength( data_len) API to extract the length of application data received BLE_TRSPC_GetData( conn_hdl data); API is used to retrieve the data conn_hdl is the value obtained from Connection Handler section BLE_TRSPC_Event_T p_event structure stores the information about BLE transparent UART callback functions Example Implementation for printing the received data from peripheral device over UART /* TODO: implement your application code */ uint16_t data_len; uint8_t *data; // Retrieve received data length BLE_TRSPC_GetDataLength(p_event- eventField onReceiveData connHandle data_len); // Allocate memory according to data length data = OSAL_Malloc(data_len); if(data == NULL) break; // Retrieve received data BLE_TRSPC_GetData(p_event- eventField onReceiveData connHandle data); // Output received data to UART SERCOM0_USART_Write(data data_len); // Free memory OSAL_Free(data); Users can exercise various other BLE functionalities by using BLE Stack API Where to go from here  BLE Multilink Transparent UART ",
							" BLE Multilink Transparent UART  Getting Started  Getting Started with Central Building Blocks BLE Multilink Transparent UART  --  BLE Multilink Transparent UART Introduction This document will help users create a multilink central device and send/receive characters between connected BLE devices over Microchip proprietary Transparent UART Profile The multilink central will enable users to connect multiple peripheral devices to a central device The central and peripheral devices in this tutorial are WBZ451 devices Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity board and experience the demo or can go through the steps involved in developing this Application from scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification BLE Connection(central)  BLE Transparent UART(central) Hardware Required  Tool  Qty WBZ451 Curiosity Board 3 (min) Micro USB cable 3 SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Software TeraTerm Smartphone App None Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central profiles_services multilink hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"central_ml_trp_uart x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central profiles_services multilink firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description Upon programming the demo application central device ( WBZ451 ) will start scanning for near by peripheral devices to connect After a connection has been made data can be sent back and forth over UART between the two devices that are connected The central device continues scanning until 100 secs and allows new peripheral devices that are advertising to join For this example we are going to demonstrate 2 BLE links ------------------Central Device------------------ | | | | | | Peripheral Device Peripheral Device Peripheral Device Demo will print start of the scanning \"Scanning\" connected \"Connected \" and disconnected \"Disconnected\" state on a terminal emulator like TeraTerm@ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Application Data to be sent to the connected peripheral device should be entered in the terminal emulator Testing Users should use 3 WBZ451 Curiosity Boards configured as BLE Transparent UART(peripheral) Note For demo testing with multiple links users need to configure the BLE Device Address for the 3 peripheral devices as follows Device 1 will have PUBLIC address of {0xA1 0xA2 0xA3 0xA4 0xA5 0xA6} Device 2 will have PUBLIC address of {0xB1 0xB2 0xB3 0xB4 0xB5 0xB6} Device 3 will have PUBLIC address of {0xC1 0xC2 0xC3 0xC4 0xC5 0xC6} Precompiled Hex files for peripheral devices with different addresses as mentioned above are available here Demo Experience when using 4 WBZ451 Curiosity boards 3 configured as Peripheral and 1 configured as Central device This section assumes that a user has already programmed the peripheral_trp_uart and central_trp_uart application on 2 WBZ451 Curiosity Boards Board1 = WBZ451 Curiosity Board with central_trp_uart applicaton Programmed Board2(Device1) = WBZ451 Curiosity Board with peripheral_trp_uart application Programmed Board3(Device2) = WBZ451 Curiosity Board with peripheral_trp_uart application Programmed Board4(Device3) = WBZ451 Curiosity Board with peripheral_trp_uart application Programmed Note It is recommended to reset central device first and then the peripheral devices one by one Board1: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Scanning\" message is displayed on the TeraTerm Upon finding peripheral device with public address {0xA1 0xA2 0xA3 0xA4 0xA5 0xA6} message \"Found Peer Node\" will be displayed and a connection request will be initiated \"Initiating connection\" During the scan time if more devices are available which will be true in this case central device will keep initiating connections with the new peer nodes Board2/Board3/Board4: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Advertising\" message is displayed on the TeraTerm Note: Scanner is configured to scan only for 100 secs user should ensure the peer device is advertising After connection establishment both the peripheral device (Board2/3/4) and central device(Board1) will display \"Connected \" message on respective terminal windows Users can now start sending data back and forth between the central and peripheral device using the terminal emulator Characters entered on any peripheral device's (Board2 3 4) terminal emulator will appear on central device's (Board1) terminal emulator Characters entered on central devices terminal emulator will appear on peripheral devices emulator in a round-robin fashion without priority For example in order to send character \"a\" to all peripheral devices \"aaa\" needs to be entered on terminal emulator of the central device Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project -- link for instructions Import component configuration -- This step helps users setup the basic components and configuration required to develop this application The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central profiles_services multilink firmware central_ml_trp_uart X\" Users should follow the instructions mentioned here to import the component configuration Tip: Import and Export functionality of component configuration will help users to start from a known working setup of configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Scan Connection and Transparent UART Profile Configuration Select BLE_Stack component in project graph Select Transparent Profile component in project graph Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers  Source Files  Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble app_ble_handler c All GAP GATT SMP and L2CAP Event handlers app_ble app_trspc_handler c All Transparent UART Client related Event handlers config default ble profile_ble ble_trspc ble_trspc c All Transparent Client Functions for user application Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file ble_trspc h is the Header File associated with API’s and structures related to BLE Transparent Client functions for Application User Function Calls MCC generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c User Application Development Include \"ble_trspc h\" in app c BLE Transparent UART Server related API's are available here \"osal/osal_freertos_extend h\" in app_trsps_handler c OSAL related API's are available here definitions h in all the files where UART will be used to print debug information Tip: definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised user action is required as mentioned here Start Scanning BLE_GAP_SetScanningEnable(true BLE_GAP_SCAN_FD_ENABLE BLE_GAP_SCAN_MODE_OBSERVER 1000); This API is called in the Applications initialstate - APP_STATE_INIT in app c Scan duration is 100 secs Scan Results and intiating a BLE Connection BLE_GAP_EVT_ADV_REPORT event is generated upon finding Adverstisements on legacy channels BLE connection can be initiated by using the API BLE_GAP_CreateConnection( createConnParam_t); // code snippet to filter scan results and initiate connection // Filter Devices based of Address for this example address checking only 2 bytes if ((p_event- eventField evtAdvReport addr addr[0] == 0xA1 p_event- eventField evtAdvReport addr addr[1] == 0xA2) || (p_event- eventField evtAdvReport addr addr[0] == 0xB1 p_event- eventField evtAdvReport addr addr[1] == 0xB2) || (p_event- eventField evtAdvReport addr addr[0] == 0xC1 p_event- eventField evtAdvReport addr addr[1] == 0xC2)) { SERCOM0_USART_Write((uint8_t *)\"Found Peer Node r n\" 17); BLE_GAP_CreateConnParams_T createConnParam_t; createConnParam_t scanInterval = 0x3C; // 37 5 ms createConnParam_t scanWindow = 0x1E; // 18 75 ms createConnParam_t filterPolicy = BLE_GAP_SCAN_FP_ACCEPT_ALL; createConnParam_t peerAddr addrType = p_event- eventField evtAdvReport addr addrType; memcpy(createConnParam_t peerAddr addr p_event- eventField evtAdvReport addr addr GAP_MAX_BD_ADDRESS_LEN); createConnParam_t connParams intervalMin = 0x10; createConnParam_t connParams intervalMax = 0x10; createConnParam_t connParams latency = 0; createConnParam_t connParams supervisionTimeout = 0x48; SERCOM0_USART_Write((uint8_t *)\"Initiating Connection r n\" 23); BLE_GAP_CreateConnection( createConnParam_t); } Connected Disconnected Events In app_ble_handler c BLE_GAP_EVT_CONNECTED event will be generated when a BLE connection is completed Connection Handler Connection handle associated with the peer peripheral device needs to be saved for data exchange after a BLE connection p_event- eventField evtConnect connHandle has this information In Multilink Application unique connection handler's will be generated for all the peripheral links Transmit Data Add \"APP_MSG_UART_CB\" to the generated APP_MsgId_T BLE_TRSPC_SendData(conn_hdl 1 data); is the API to be used for sending data towards the central device Note: The precompiled application example uses a UART callback to initiate the data transmission upon receiving a character on UART Example Implementation for Transmitting the received data over UART using the BLE_TRSPC_SendData API uint16_t conn_hdl[3] = {0xFFFF 0xFFFF 0xFFFF};// connection handle info captured @BLE_GAP_EVT_CONNECTED event uint8_t no_of_links;// No of connected peripheral devices uint8_t i = 0;// link index uint8_t uart_data; void uart_cb(SERCOM_USART_EVENT event uintptr_t context) { APP_Msg_T appMsg; // If RX data from UART reached threshold (previously set to 1) if( event == SERCOM_USART_EVENT_READ_THRESHOLD_REACHED ) { // Read 1 byte data from UART SERCOM0_USART_Read( uart_data 1); appMsg msgId = APP_MSG_UART_CB; OSAL_QUEUE_Send( appData appQueue appMsg 0); } } void APP_UartCBHandler() { // Send the data from UART to connected device through Transparent service BLE_TRSPC_SendData(conn_hdl[i] 1 uart_data); i++; if(i==no_of_links) i = 0; //reset link index } //If msg received in Queue handle the Queue message based on msgID if (OSAL_QUEUE_Receive( appData appQueue appMsg OSAL_WAIT_FOREVER)) { if(p_appMsg- msgId==APP_MSG_BLE_STACK_EVT) { // Pass BLE Stack Event Message to User Application for handling APP_BleStackEvtHandler((STACK_Event_T *)p_appMsg- msgData); } else if(p_appMsg- msgId==APP_MSG_BLE_STACK_LOG) { // Pass BLE LOG Event Message to User Application for handling APP_BleStackLogHandler((BT_SYS_LogEvent_T *)p_appMsg- msgData); } else if(p_appMsg- msgId==APP_MSG_UART_CB) { // Transparent UART Client Data transfer Event APP_UartCBHandler(); } } Receive Data BLE_TRSPC_EVT_RECEIVE_DATA is the event generated when data is sent from central device Users need to use the BLE_TRSPC_GetDataLength( data_len) API to extract the length of application data received BLE_TRSPC_GetData( conn_hdl data); API is used to retrieve the data conn_hdl is the value obtained from Connection Handler section Tip: BLE_TRSPC_Event_T p_event structure stores the information about BLE transparent UART callback functions Example Implementation for printing the received data from peripheral device over UART /* TODO: implement your application code */ uint16_t data_len; uint8_t *data; // Retrieve received data length BLE_TRSPC_GetDataLength(p_event- eventField onReceiveData connHandle data_len); // Allocate memory according to data length data = OSAL_Malloc(data_len); if(data == NULL) break; // Retrieve received data BLE_TRSPC_GetData(p_event- eventField onReceiveData connHandle data); // Output received data to UART SERCOM0_USART_Write(data data_len); // Free memory OSAL_Free(data); Users can exercise various other BLE functionalities by using BLE Stack API ",
							" Peripheral BLE Peripheral devices send advertisement packets and accept connection requests from another central device Connected BLE devices enable bi-directional data transfer using the profiles and services There are certain use cases where a connection between the devices (Peripheral Central) is not essential and advertisement feature (transmit only no receive) is sufficient SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Note: SDK Setup is mandatory step before users start developing app examples based of Building Blocks Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Blocks  Create FreeRTOS project and configure BLE stack using MPLAB X Harmony Code Configurator 3 Create a new MCC Harmony project configure components like FreeRTOS and BLE Stack Init BLE Stack  Adding UART print Hello World  Legacy Advertisments Transmit Data Payload using BLE Legacy Adv(no BLE connection)  Extended Advertisment Transmit Data Payload using BLE Extended Adv(no BLE connection)  Connection Configure stack for Peripheral Functionality Connection between Peripheral and Central Device  Profiles and services     Transparent UART Peripheral (Legacy Adv + Connection + Data Exchange)    Data Exchange between 2 devices(peripheral and central) after a BLE connection using Microchip Transparent UART profile and service       Custom Service Peripheral (Legacy Adv + Connection + Data Exchange)    Data Exchange between 2 devices(peripheral and central) after a BLE connection using Custom Service      ",
							"  Peripheral - FreeRTOS BLE Stack and App Initialize  Getting Started  Getting Started with Peripheral Building Blocks   FreeRTOS and BLE Stack Setup   --  Adding UART --  Legacy Advertisements(sleep) Introduction This document will help users create a new MCC Harmony project configure FreeRTOS component and BLE stack component in the project generate code using the MPLAB Code Configurator These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification Hardware Required None Software Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Steps to Init BLE Stack This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project -- link for instructions Open MPLAB Code Configurator Default MPLAB Code Configurator window In Available component window expand Wireless BLE and click plus symbol the BLE stack component on to the project graph Upon BLE Stack being added to project graph the different component dependencies will be requested to be added User has to select \"yes\" to add the dependant component Activate the components select \"yes\" Verify Project Graph Display FreeRTOS component configuration options by Selecting the component in Project Graph Configure FreeRTOS component to the following The configuration chosen here should suit most application needs users are recommended to follow the FreeRTOS Customization documented here to meet their needs Tip: Upon selecting any component the default configuration options available for user are displayed Display BLE Stack component configuration options by Selecting the component in Project Graph Default Configuration: Peripheral Device functionality is enabled by default  Generate Code Switch to IDE window right click on project and open Project Properties Ensure correct compiler version as suggested in Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC is chosen Build Project upon building project user action is required as mentioned here Build Project The project will compile successfully Where to go from here  UART ",
							" BLE Sleep Mode Legacy Advertisements  Getting Started  Getting Started with Peripheral Building Blocks   BLE Sleep Mode Legacy Advertisements  Introduction This document will help users to enable \"sleep/standby\" mode with BLE Advertisements on WBZ451 Curiosity board using MPLAB Code Configurator(MCC) In this basic application example the advertisement interval will be set to 1 sec The advertisement interval will dictate the application sleep time Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity Board and experience the demo or can go through the steps involved in developing this Application from scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification FreeRtos BLE App Initialize  Low Power Notes Hardware Required  Tool  Qty WBZ451 Curiosity Board 1 Micro USB cable 1 Power Debugger /Multimeter 1 SDK Setup Gettting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Software  TeraTerm Smartphone App Light Blue Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral legacy_adv hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"legacy_adv x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral legacy_adv firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description This Application Example enables users to enable sleep mode while transmitting non Connectable Undirected BLE Advertisements On reset demo will print \"Advertising\" on a terminal emulator like TeraTerm this denotes start of advertisements Device will enter sleep mode periodically based on the advertisement interval which is set to 1 sec for this example Testing Connect the WBZ451 Curiosity board to PC program the precompiled hex file or application example as mentioned Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Advertising\" message is displayed on the TeraTerm User can open the LightBlue App on Smartphone to scan for Advertisements Device with device name \"Microchip\" will appear Light Blue App users using a wireshark sniffer can examine the complete Application Payload sent Light Blue App Users can use another WBZ451 Curiosity Board configured as BLE scanner Current Consumption Measurement Connect the Multimeter/Power Debugger to Power Measurement Header J6 Power on the Board If using Power Debugger users can use Data Visualizer to measure the current consumption Current measured in sleep/standby mode is 577 9 uA and avg current consumption is around 624 8 uA Users of this Early adopter package should go through the known issues document and understand the limitations if any with the current low power mode implementation Light Blue App Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project -- link for instructions Import component configuration --This step helps users setup the basic components and configuration required to develop this application The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral legacy_adv firmware legacy_adv X\" Users should follow the instructions mentioned here to import the component configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Advertisement system sleep and RTC Clock Source Configuration Select BLE_Stack component in project graph Tip: advertisement payload can be configured by user here Select clock configuration Configure RTC clock configuration Tip: The configuration bits will be generated after user Generates code Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers During system sleep clock (system PLL) will be disabled and syatem tick will be turned off FreeRTOS timer needs to be componsated for the time spent in sleep RTC timer which works in the sleep mode is used to accomplish this RTC timer will be initialized after BLE stack initialization Autogenerated adverisement Data Format  Source Files  Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble_handler c All GAP GATT SMP and L2CAP Event handlers Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application | Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file Function Calls MCC generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c User Application Development Include user action is required as mentioned here definitions h in all the files where UART will be used to print debug information Tip: definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised Set PUBLIC Device Address BLE_GAP_SetDeviceAddr( devAddr); This API can be called in APP_BleConfig() located in file app_ble c BLE_GAP_Addr_T devAddr; devAddr addrType = BLE_GAP_ADDR_TYPE_PUBLIC; devAddr addr[0] = 0xA1; devAddr addr[1] = 0xA2; devAddr addr[2] = 0xA3; devAddr addr[3] = 0xA4; devAddr addr[4] = 0xA5; devAddr addr[5] = 0xA6; // Configure device address BLE_GAP_SetDeviceAddr( devAddr); Start Advertisement BLE_GAP_SetAdvEnable(0x01 0); This API is called in the Applications initialstate - APP_STATE_INIT in app c Users can exercise various other BLE Advertisement functionalities by using BLE Stack API Where to go from here  BLE Connection ",
							" BLE Extended Advertisements  Getting Started  Getting Started with Peripheral Building Blocks  Adding UART  --  Extended Advertisements Introduction This document will help users enable Extended Advertisements (1M 2M coded PHY -- 125kbps) on WBZ451 Curiosity Board This example (ext_adv) enables users to send application data using extended advertisements Extended Advertisements are used to send more data than the legacy advertisements allow and allow long range functionality when using Coded PHY Use of Extended Advertisements also enables the users to select between different PHYs (1M 2M and LE Coded ) which are not permitted when using legacy advertisements In BLE a peripheral or broadcaster always starts with advertisements Advertisement packets enable a central or observer to discover a peripheral or broadcaster Extended Advertisements implemented in this example can be used for sending more data (2M PHY) or do range tests (Coded PHY) For testing these features a scanner Application can be used which is configured to scan the extended advertisement packets To save power low power mode can be enabled If conditions are met then WBZ451 will enter into sleep mode Details will be discussed in later section Users can run the precompiled Application Example hex file provided with this example on the WBZ451 Curiosity Board and go through the steps involved in developing this Application application from the scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification FreeRtos BLE App Initialize  Adding UART  Low Power Details Hardware Required  Tool  Qty WBZ451 Curiosity Board 1 (2 if testing with a scanner) Micro USB cable 1 Optional Power Debugger /Multimeter/OscilloScope to measure power SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Software  TeraTerm Smartphone App None Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral ext_adv hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"ext_adv x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral ext_adv firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description This Application Example enables users to transmit Extended Advertisements @ Coded PHY data rate of 125 Kbps PDU types of ADV_EXT_IND and ADV_AUX_IND will be transmitted Application data (\"Microchip\") is transmitted in Auxiliary packets (ADV_AUX_IND) ADV_EXT_IND carries the Auxiliary Packet Information (ADV_AUX_IND) for scanner to collect the data Demo will print \"Ext Adv Enabled\" information indicating the successful start of Coded PHY Advertisements on a terminal emulator like TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Coded PHY Advertisements are configured to be sent every 2 secs BLE Extended Advertisements (125 kbps 500 kbps)cannot be scanned using a smartphone app This could be due to support of only legacy advertisements on the smartphone or disabled extended adv API's in smartphone app Testing Users can use another WBZ451 Curiosity Board configured as BLE Scan Ext Adv This section assumes that a user has already programmed the ext_adv and scan_ext_adv application on 2 WBZ451 Curiosity Boards Board1 = WBZ451 Curiosity Board with Ext Adv Programmed Board2 = WBZ451 Curiosity Board with Scan Ext Adv Programmed Board1: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Ext Adv Enable\" message is displayed on the TeraTerm Board2: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"ExtAdv Scan Enable Success\" message is displayed on the TeraTerm \"Microchip\" message will be displayed as soon the WBZ451 module performs an extended advertisement scan Current Consumption Measurement Connect the Multimeter/Power Debugger/Oscillo Scope to Power Measurement Header J6 If using Power Debugger users can use Data Visualizer to measure the current consumption Current measured in sleep/standby mode is 575 6 uA and avg current consumption is around 723 0 uA Users of this package should go through the known issues document and understand the limitations if any with the current low power mode implementation Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Setup Harmony framework EA release package has all the neccessary component and should be downloaded individually from the link provided in the package It is recommended to create framework in the root directory The framework looks like Create a new MCC Harmony project - instructions Drag and drop BLE_Stack in the project graph and select Yes to all pop ups Drag and Drop SERCOM0 from Peripherals into project graph for UART messages Project Graph will look like Enable Low Power Enable Low power mode by selecting Low Power Enable in BLE_Stack Configuration Select Yes to all pop ups Click on Window- MCC- Harmony- Clock Configuration Enable SOSC clock Configure Advertisement Configuration Select BLE_Stack component in project graph and make modifications as shown below Configure UART Uart Configuration Details can be found here Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers Autogenerated extended adverisement Data Format  Source Files  Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble app_ble_handler c All GAP GATT SMP and L2CAP Event handlers app_user_edits c User Code Change instruction Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop the application| Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file Function Calls MCC generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c RTC_Timer32Start() defined in plib_rtc_timer c It call to start RTC Timer clock to facilitate low power mode User Application Development Include definitions h in all the files where UART will be used to print debug information Tip: definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised user action is required as mentioned here Start Ext Advertisement BLE_GAP_SetExtAdvEnable(true 0x01 extAdvEnableParam); This API is called in the Applications initialstate - APP_STATE_INIT in app c Parameters for extended advertisement should be chosen Below is an example Users can exercise various other BLE Advertisement functionalities by using BLE Stack API Where to go from here  Getting Started with Peripheral Building Blocks ",
							" BLE Deep Sleep Advertising  Getting Started  Getting Started with Peripheral Building Blocks BLE Deep Sleep Advertising Introduction This document will help users to enable \"Deep sleep\" mode with BLE Advertisements on WBZ451 Curiosity board using MPLAB Code Configurator(MCC) In this basic application example the Deep Sleep advertisement interval will be set to 960 millisecond The advertisement interval will dictate the application Deep sleep time Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity Board and experience the demo or can go through the steps involved in developing this Application from scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification FreeRtos BLE App Initialize Low Power Notes Hardware Required Tool Qty WBZ451 Curiosity Board 1 Micro USB cable 1 Power Debugger /Multimeter 1 SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Software  TeraTerm Smartphone App Light Blue Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral deep_sleep_adv hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"ble_deep_sleep_adv x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral deep_sleep_adv firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description This Application Example enables users to enter Deep sleep mode while transmitting Connectable Undirected BLE Advertisements On power on reset demo will enter \"Deep Sleep Mode\" when the USR_BTN(SW2) is pressed the device onboard led(green) starts blinking which denotes start of advertisements Device will enter Deep sleep mode periodically based on the advertisement interval which is set to 960 milliseconds for this example When device connects with the mobile App the onboard led start to glow solid which indicates the connection established and the device will enter Standby Sleep Mode during Idle state Testing Connect the WBZ451 Curiosity board to PC program the precompiled hex file or application example as mentioned Upon flashing there will not be any indication on the board since the device enters deep sleep mode User can press the USR_BTN(SW2) available on the board to start Deep sleep Advertising To connect to the WBZ451 User can open the Light Blue App on Smartphone to scan for Advertisements Device name \"BLE_DSADV\" will appear Current Consumption Measurement Connect the Multimeter/Power Debugger to Power Measurement Header J6 Power on the Board If using Power Debugger users can use Data Visualizer to measure the current consumption Current measured in Deep sleep mode is around 1 6 uA Current measured in Deep sleep + Advertising mode is around 225 3 uA average Current measured in connected + standby sleep mode is 626 1uA and average current consumption is around 1 26mA Users of this Early adopter package should go through the known issues document and understand the limitations if any with the current low power mode implementation Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview Create a new MCC Harmony Project -- link for instructions Import component configuration --This step helps users setup the basic components and configuration required to develop this application Users should follow the instructions mentioned here to import the component configuration Tip: Import and Export functionality of component configuration will help users to start from a known working setup of configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Deep Sleep Advertisement system sleep and RTC Clock Source Configuration Select BLE_Stack component in project graph Note: Advertising Interval Min can be modified to adjust Deep Sleep Advertising interval Tip: Advertisement payload can be configured by user here Select clock configuration Configure RTC clock configuration Select Device Support Configure PMU Mode configuration Configure LED GPIO Configuration Note: The above GPIO configuration is used for indication of the device state in this example and is optional Tip: The configuration bits will be generated after user Generates code Generate Code Instructions on how to Generate Code After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers During system sleep clock (system PLL) will be disabled and system tick will be turned off FreeRTOS timer needs to be componsated for the time spent in sleep RTC timer which works in the sleep mode is used to accomplish this RTC timer will be initialized after BLE stack initialization Source Files Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble_handler c All GAP GATT SMP and L2CAP Event handlers app_ble_dsadv c Source Code for utilizing the deep sleep advertising functionality device_deep_sleep c Source Code for deep Sleep and wake up related system configurations Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file Function Calls MCC generates and adds the following code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() and Deep Sleep Advertising Functionality in APP_BleDsadvStart(flag) function APP_BleStackInit() and APP_BleDsadvStart(flag) are the API's that will be called inside the Applications Initial State -- APP_STATE_INIT in app c System Manual Configurations The following code modifications needs to be done to utilize the deep sleep Advertising functionality Step 1 - Initialization c CLK_Initialize(); This API call will be originally available in SYS_Initialize function and should be called part of _on_reset() function inside initialization c file void SYS_Initialize (void* data) The below generated code should be removed from the SYS_Initialize Function Add the below code inside SYS_Initialize Function DEVICE_DeepSleepWakeSrc_T wakeSrc; DEVICE_GetDeepSleepWakeUpSrc( wakeSrc); if (wakeSrc == DEVICE_DEEP_SLEEP_WAKE_NONE) //Initialize RTC if wake source is none(i e power on reset) { RTC_Initialize(); } Step 2 - startup_xc32 c PCHE_SetupRam() Copy the below code into the startup_xc32 c __attribute__((ramfunc long_call section(\" ramfunc\") unique_section)) void PCHE_SetupRam(void) { // Set Flash Wait states and enable pre-fetch // clear PFMWS and ADRWS PCHE_REGS- PCHE_CHECON = (PCHE_REGS- PCHE_CHECON (~(PCHE_CHECON_PFMWS_Msk | PCHE_CHECON_ADRWS_Msk | PCHE_CHECON_PREFEN_Msk))) | (PCHE_CHECON_PFMWS(1) | PCHE_CHECON_PREFEN(1)); // write completion delay for(int i=1; i 10; i++) { asm (\"NOP\"); } } Copy the below code into the Reset_Handler Handler Function after __pic32c_data_initialization() Function Call if ( (DSU_REGS- DSU_DID DSU_DID_REVISION_Msk)) //HW A0 version { PCHE_SetupRam(); } Step 3 - heap_4 c Modify with the below code inside heap_4 c (available as part of FreeRTOS-- MemMang) static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ]; -- Original Code static uint8_t __attribute__((section (\" bss ucHeap\") noload)) ucHeap[ configTOTAL_HEAP_SIZE ]; -- Modified Code Step 4 - device_deep_sleep c (optional) Include the Below code inside device_deep_sleep c to configure the GPIO setting for deep sleep Device_GpioConfig(); User Application Development Include user action is required as mentioned here app_ble_dsadv h into app c file definitions h in all the files where port pin macros are used Tip: definitions h is not specific to just port peripheral instead it should be included in all application source files where peripheral functionality will be exercised Enter Deep Sleep mode DEVICE_EnterDeepSleep(false 0); This API can be called to put the device to deep sleep mode Start Deep Sleep Advertisement APP_BleDsadvStart(false); This API can be called to start the Deep sleep Advertising This API is called in the Applications initialstate - APP_STATE_INIT in app c Users can exercise various other BLE Advertisement functionalities by using BLE Stack API  ",
							" Known Issue: System sleep Implementation source(device_sleep c) and header(device_sleep h) files may not include sometimes when regenerated the project through MCC Note: It is recommended to follow the below steps to avoid the mentioned known issue whenever deep sleep project is opened through MCC Step1: Please uncheck and re-enable the Enable Sleep Mode and Enable Deep Sleep Advertising option inside BLE stack Component Configuration Options as shown in the figure below and accept the dependencies requested Step2: Enable force update option and press Generate Where to go from here  BLE Connection ",
							" BLE Connection  Getting Started  Getting Started with Peripheral Building Blocks Legacy Advertisements  --  BLE Connection  -- BLE Transparent UART Introduction This document will help users enable advertisements and connection on WBZ451 Curiosity board using MPLAB Code Configurator(MCC) BLE Advertisement is Broadcasting of small packets to peer devices In BLE a peripheral device always starts with advertisements Advertisement packets enable a central or observer to discover and connect to a peripheral Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity Board and experience the demo or can go through the steps involved in developing this Application from scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification FreeRtos BLE App Initialize  BLE Legacy Advertisements Hardware Required  Tool  Qty WBZ451 Curiosity Board 1 Micro USB cable 1 SDK Setup Getting started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Software  TeraTerm Smartphone App Light Blue Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral peripheral_conn hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"peripheral_conn x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral peripheral_conn firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description This Application Example enables users to transmit Connectable and Scannable Undirected BLE Advertisements On reset demo will print \"Advertising\" on a terminal emulator like TeraTerm this denotes start of advertisements Central device scanning these advertisements can issue connection request and get connected with this device Upon connection demo prints \"Connected\" message on terminal window Testing Connect the WBZ451 Curiosity board to PC program the precompiled hex file or application example as mentioned Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Advertising\" message is displayed on the TeraTerm User can open the LightBlue App on Smartphone to scan for Advertisements Device with device name \"Microchip\" will appear Select the device to get connected after successful connection user can view the advertisement data Terminal output Users can use another WBZ451 Curiosity Board configured as BLE Connection(central) instead of using a Smartphone App Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project -- link for instructions Import component configuration --This step helps users setup the basic components and configuration required to develop this application The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral peripheral_conn firmware peripheral_conn X\" Users should follow the instructions mentioned here to import the component configuration Tip: Import and Export functionality of Harmony component configuration will help users to start from a known working setup of MCC configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Advertisement and Connection Configuration Select BLE_Stack component in project graph Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers Autogenerated advertisement data format  Source Files  Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble app_ble_handler c All GAP GATT SMP and L2CAP Event handlers Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application | Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file Function Calls MCC generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c User Application Development Include user action is required as mentioned here definitions h in all the files where UART will be used to print debug information Tip: definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised Set PUBLIC Device Address BLE_GAP_SetDeviceAddr( devAddr); BLE_GAP_Addr_T devAddr; devAddr addrType = BLE_GAP_ADDR_TYPE_PUBLIC; devAddr addr[0] = 0xA1; devAddr addr[1] = 0xA2; devAddr addr[2] = 0xA3; devAddr addr[3] = 0xA4; devAddr addr[4] = 0xA5; devAddr addr[5] = 0xA6; // Configure device address BLE_GAP_SetDeviceAddr( devAddr); Start Advertisement BLE_GAP_SetAdvEnable(0x01 0); Connected Disconnected Events All the possible GAP GATT SMP and L2CAP Event handlers are available in file app_ble_handler c users can implement application code to denote Connection State here Users can exercise various other BLE Advertisement functionalities by using BLE Stack API Where to go from here BLE Transparent UART ",
							" BLE Transparent UART  Getting Started  Getting Started with Peripheral Building Blocks BLE Connection  --  BLE Transparent UART Introduction This tutorial will help users create a peripheral device and send/receive characters between 2 connected BLE devices over Microchip proprietary Transparent UART Profile Peripheral device will be WBZ451 Device and Central device can either be a Smartphone with Light Blue App or another WBZ451 Device The instructions mentioned below are applicable for a BLE Peripheral device Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity board and experience the demo or can go through the steps involved in developing this Application from scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification BLE Connection(peripheral) Hardware Required  Tool  Qty WBZ451 Curiosity Board 1 Micro USB cable 1 SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Software  TeraTerm Smartphone App Light Blue Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral profiles_services peripheral_trp_uart hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"peripheral_trp_uart x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral profiles_services peripheral_trp_uart firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description Upon programming the demo application WBZ451 will start Advertising (connectable) central device (Smartphone or another WBZ451 ) scanning for these advertisements will connect to the device In case of using Light Blue App search for “Microchip” and connect After a connection has been made data can be sent back and forth over UART between the two devices that are connected Demo will print start of the advertisement “Advertising” connection “BLE Scanning” “Connected” and “Disconnected” state on a terminal emulator like TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Application Data to be sent to the connected central device (Smartphone or another WBZ451 ) should be entered in the terminal emulator Testing This section assumes that user has programmed the Application Example on the WBZ451 Curiosity Board Demo Experience when using a Smartphone (Light Blue App) as Central Device Reset the WBZ451 Curiosity board Open Terminal emulator like Tera Term select the right COM port@ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) open Light Blue App on your smartphone Search and select the advertisement with Device Name \"Microchip\" To receive data from WBZ451 Curiosity Board (peripheral) device to central device users need to select the UUID: 49535343-1E4D-4BD9-BA61-23C647249616 and select listen for notifications Enter \"test\" on Teraterm and data should be displayed on Light Blue App To send data from central device to WBZ451 Curiosity Board (peripheral) users need to select the UUID: 49535343-8841-43F4-A8D4-ECBE34729BB3 and select write new value Enter \"trp uart\" on App and data should be displayed on Terminal Window Demo Experience when using another WBZ451 as Central device Users can use another WBZ451 Curiosity Board configured as BLE Transparent UART(central) instead of using a Smartphone App as central device Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project -- link for instructions Import component configuration --This step helps users setup the basic components and configuration required to develop this application The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral profiles_services peripheral_trp_uart firmware peripheral_trp_uart X\" Users should follow the instructions mentioned here to import the component configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Advertisement Connection and Transparent UART Profile Configuration Select BLE_Stack component in project graph Select Transparent Profile component in project graph Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers Autogenerated advertisement data format  Source Files  Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble app_ble_handler c All GAP GATT SMP and L2CAP Event handlers app_ble app_trsps_handler c All Transparent UART Server related Event handlers ble_trsps c All Transparent Server Functions for user application Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file ble_trsps h is the Header File associated with API’s and structures related to BLE Transparent Client functions for Application User Function Calls MCC generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c User Application Development Include \"ble_trsps h\" in app c BLE Transparent UART Server related API's are available here \"osal/osal_freertos_extend h\" in app_trsps_handler c OSAL related API's are available here definitions h in all the files where UART will be used to print debug information Tip: definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised user action is required as mentioned here Set PUBLIC Device Address BLE_GAP_SetDeviceAddr( devAddr); BLE_GAP_Addr_T devAddr; devAddr addrType = BLE_GAP_ADDR_TYPE_PUBLIC; devAddr addr[0] = 0xA1; devAddr addr[1] = 0xA2; devAddr addr[2] = 0xA3; devAddr addr[3] = 0xA4; devAddr addr[4] = 0xA5; devAddr addr[5] = 0xA6; // Configure device address BLE_GAP_SetDeviceAddr( devAddr); Start Advertisement BLE_GAP_SetAdvEnable(0x01 0); Connected Disconnected Events In app_ble_handler c BLE_GAP_EVT_CONNECTED event will be generated when a BLE connection is completed Connection Handler Connection handle associated with the peer peripheral device needs to be saved for data exchange after a BLE connection p_event- eventField evtConnect connHandle has this information Transmit Data Add \"APP_MSG_UART_CB\" to the generated APP_MsgId_T BLE_TRSPS_SendData(conn_hdl 1 data); is the API to be used for sending data towards the central device Note: The precompiled application example uses a UART callback to initiate the data transmission upon receiving a character on UART Example Implementation for Transmitting the received data over UART using the BLE_TRSPS_SendData API uint16_t conn_hdl;// connection handle info captured @BLE_GAP_EVT_CONNECTED event uint16_t ret; uint8_t uart_data; void uart_cb(SERCOM_USART_EVENT event uintptr_t context) { APP_Msg_T appMsg; // If RX data from UART reached threshold (previously set to 1) if( event == SERCOM_USART_EVENT_READ_THRESHOLD_REACHED ) { // Read 1 byte data from UART SERCOM0_USART_Read( uart_data 1); appMsg msgId = APP_MSG_UART_CB; OSAL_QUEUE_Send( appData appQueue appMsg 0); } } void APP_UartCBHandler() { // Send the data from UART to connected device through Transparent service BLE_TRSPS_SendData(conn_hdl 1 uart_data); } // Register call back when data is available on UART for Peripheral Device to send // Enable UART Read SERCOM0_USART_ReadNotificationEnable(true true); // Set UART RX notification threshold to be 1 SERCOM0_USART_ReadThresholdSet(1); // Register the UART RX callback function SERCOM0_USART_ReadCallbackRegister(uart_cb (uintptr_t)NULL); else if(p_appMsg- msgId==APP_MSG_BLE_STACK_LOG) { // Pass BLE LOG Event Message to User Application for handling APP_BleStackLogHandler((BT_SYS_LogEvent_T *)p_appMsg- msgData); } else if(p_appMsg- msgId==APP_MSG_UART_CB) { // Pass BLE UART Data transmission target BLE UART Device handling APP_UartCBHandler(); } Receive Data BLE_TRSPS_EVT_RECEIVE_DATA is the event generated when data is sent from central device Users need to use the BLE_TRSPS_GetDataLength(p_event- eventField onReceiveData connHandle data_len; API to extract the length of application data received BLE_TRSPS_GetData(p_event- eventField onReceiveData connHandle data); API is used to retrieve the data Tip: BLE_TRSPC_Event_T p_event structure stores the information about BLE transparent UART callback functions Example Implementation for printing the received data from central device over UART /* TODO: implement your application code */ uint16_t data_len; uint8_t *data; // Retrieve received data length BLE_TRSPS_GetDataLength(p_event- eventField onReceiveData connHandle data_len); // Allocate memory according to data length data = OSAL_Malloc(data_len); if(data == NULL) break; // Retrieve received data BLE_TRSPS_GetData(p_event- eventField onReceiveData connHandle data); // Output received data to UART SERCOM0_USART_Write(data data_len); // Free memory OSAL_Free(data); Users can exercise various other BLE functionalities by using BLE Stack API Where to go from here Advanced Application (BLE Sensor App) - BLE Sensor App utlizes the Transparent UART building block ",
							" BLE Custom service Getting Started Getting Started with Peripheral Building Blocks BLE Connection  –  BLE Custom Service Introduction This tutorial will help users create a peripheral device with custom profile and control the RGB LEDs on the WBZ451 Curiosity board and button on the WBZ451 Curiosity board shall be used to enable or disable the LED status Peripheral device will be WBZ451 Device and Central device can be a Smartphone with Light Blue App The instructions mentioned below are applicable for a BLE Peripheral device Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity board and experience the demo or can go through the steps involved in developing this Application from scratch Recommended Reads BLE Software Specification BLE Connection Hardware Required Tool Required Qty WBZ451 Curiosity Board 1 Micro USB Cable 1 SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Software TeraTerm Smartphone App Light Blue Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral profiles_services custom_service hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"peripheral_trp_uart x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral profiles_services custom_service firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description Upon programming the demo application WBZ451 will start Advertising (connectable) central device (Smartphone) scanning for these advertisements will connect to the device In case of using Light Blue App search for “pic32cx-bz” and connect After a connection has been made Button and RGB LED status can be read and RGB LED can be controlled from the central device (Smartphone - Light Blue App) Button status will be notified if subscribed from central device (Smartphone) Demo will print various events on a terminal emulator like Tera Term @ (Speed: 115200 Data: 8-bit Partity: none stop bits: bit Flow control: none) Start of the advertisement - \"[BLE] Device Initialized Ready for connection\" Connection completed - \"[BLE] Connected to Peer Device: \" \" [BLE ] Connection Handle:\" Write Request Received - \"[BLE] GATT Write ATTR Handle 0x\" Read Request Received - \"[BLE] GATT Read ATTR Handle 0x\" Received RGB Data - \"[BLE] RGB LED data 0x 0x 0x\" Button press event - “[BLE] Custom Service Button Event : RGB LED ON” “[BLE] Custom Service Button Event : RGB LED OFF” BLE Disconnected - “[BLE] Disconnected Handle: %d Reason: 0x reason_code ” Testing This section assumes that user has programmed the Application Example on the WBZ451 Curiosity Board Demo Experience when using a Smartphone (Light Blue App) as Central Device Reset the WBZ451 Curiosity board Open Terminal emulator like Tera Term select the right COM port@ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) open Light Blue App on your smartphone Search and select the advertisement with Device Name \"pic32cx-bz\" Once connected on Blue App on your smartphone basic info like Adervetisement Data and Device information will be avilable\" Once connected on Blue App on your smartphone find the custom service with the UUID 4d434850-5255-42d0-aef8-881facf4ceea\" Two characteristics will be avilable on the custom service Button characteristics with Readable Notify property and RGB LED characteristics with Readable Writable property Click on the button characteristics which will have read option and subscribe Read will give the current status of the button Click on the button characteristics subscribe option to listen for button change events Button press activity will be notified to the central device without read intiated and toggle the RGB LEDs Click on the RGB LED characteristics which will have read and write option Read will give the current values stored for the RGB LEDs Value of zero will turn off the LED Other than zero value will turn on LED Click on the button characteristics write option provides option to write info which will change the RGB LED on/off condition Read again to get the updated value for RGB LEDs press back to disconnect the ble connection Disconnected device will advertise again Every event will be notified in the terminal emulator Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project -- link for instructions Import component configuration -- This step helps users setup the basic components and configuration required to develop this application The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral profiles_services custom_service firmware custom_service X\" Users should follow the instructions mentioned here to import the component configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Custom Service Configuration Select BLE_Stack component in project graph Select FreeRTOS component in project graph Select SERCOM0 component in project graph Select System component in project graph Select EIC component in project graph Select Customized Service component in project graph Verify the Clock Configuration from tools option as per low power guide  Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC Source Files Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble app_ble_handler c All GAP GATT SMP and L2CAP Event handlers ble_button_led_svc c All Custom Service button RGB LEDs configurations and functions app_ble_custom_service header and source files can be copied from the reference application Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC User Application Development Initialize Advertisement Custom Service and EIC in APP_Tasks function in file app c Add the code for enable advertisement customer service intilization and button external interrupt callback functions in the APP_STATE_INIT /* Application's initial state */ case APP_STATE_INIT: { bool appInitialized = true; //appData appQueue = xQueueCreate( 10 sizeof(APP_Msg_T) ); APP_BleStackInit(); RTC_Timer32Start(); BLE_GAP_SetAdvEnable(0x01 0); //Enable BLE Advertisement BLE_BUTTON_LED_Add(); APP_Button_Init(); SYS_CONSOLE_PRINT(\"[BLE] Device Initialized Ready for connection r n\"); Handle the button and RGB LED events in APP_Tasks function in file app c Add the RGB and button handlers to the function APP_Tasks() in app c file case APP_STATE_SERVICE_TASKS: { if (OSAL_QUEUE_Receive( appData appQueue appMsg OSAL_WAIT_FOREVER)) { // if(p_appMsg- msgId==APP_MSG_BLE_STACK_EVT) // { // // Pass BLE Stack Event Message to User Application for handling // APP_BleStackEvtHandler((STACK_Event_T *)p_appMsg- msgData); // } switch (p_appMsg- msgId) { case APP_MSG_BLE_STACK_EVT: { APP_BleStackEvtHandler((STACK_Event_T *)p_appMsg- msgData); } break; case APP_MSG_BLE_CS_LED_EVT: { APP_CustomService_RGB_Handler((uint8_t *)((STACK_Event_T *)p_appMsg- msgData)); } break; case APP_MSG_BLE_CS_BUTTON_EVT: { APP_CustomService_Button_Handler(); } break; } } break; } Add the msg ids for the button and RGB LED events in file app h typedef enum APP_MsgId_T { APP_MSG_BLE_STACK_EVT APP_MSG_ZB_STACK_EVT APP_MSG_ZB_STACK_CB APP_MSG_BLE_CS_LED_EVT APP_MSG_BLE_CS_BUTTON_EVT APP_MSG_STACK_END } APP_MsgId_T; Add the custom service file( custom_service firmware src app_ble_custom_service c/ h) which has the supporting functions for Button LED Custom service file Print the required information on the connect and discoonect events in file app_ble_handler c Add the required variables functions and callback handlers for GATT read/write response in the file ble_handler c along with the connect and disconnect void APP_BleGapEvtHandler(BLE_GAP_Event_T *p_event) { switch(p_event- eventId) { case BLE_GAP_EVT_CONNECTED: { /* TODO: implement your application code */ SYS_CONSOLE_PRINT(\"[BLE] Connected to Peer Device: 0x\"); for(int8_t idx=(GAP_MAX_BD_ADDRESS_LEN-1); idx =0; idx--) { SYS_CONSOLE_PRINT(\"%02x\" p_event- eventField evtConnect remoteAddr addr[idx]); } SYS_CONSOLE_PRINT(\" n r[BLE] Connection Handle: %d n r\" p_event- eventField evtConnect connHandle); G_ConnHandle = p_event- eventField evtConnect connHandle; } break; case BLE_GAP_EVT_DISCONNECTED: { /* TODO: implement your application code */ SYS_CONSOLE_PRINT(\"[BLE] Disconnected Handle: %d Reason: 0x%X n r\" p_event- eventField evtDisconnect connHandle p_event- eventField evtDisconnect reason); G_ConnHandle = 0; BLE_GAP_SetAdvEnable(0x01 0); //Enable BLE Advertisement } break; Add the functions for the GATT read and write handlers which will act on the received GATT request in file app_ble_handler c void APP_GattSEvtReadHandler(GATT_EvtRead_T p_event) { uint8_t error = 0; uint16_t status; SYS_CONSOLE_PRINT(\"[BLE] GATT Read ATTR Handle 0x%X r n\" p_event attrHandle); if ((p_event attrHandle = BUTTON_LED_START_HDL) || (p_event attrHandle BUTTON_LED_END_HDL)) { /* Not BLE Custom Service characteristic */ return; } switch(p_event attrHandle) { case BUTTON_LED_HDL_CHAR_0: /** Handle of characteristic 0 */ case BUTTON_LED_HDL_CCCD_0: /** Handle of characteristic 0 CCCD */ case BUTTON_LED_HDL_CHAR_1: /** Handle of characteristic 1 */ case BUTTON_LED_HDL_CHARVAL_1: /** Handle of characteristic 1 value */ error = ATT_ERRCODE_APPLICATION_ERROR; break; case BUTTON_LED_HDL_CHARVAL_0: /** Handle of characteristic 0 value */ // SYS_CONSOLE_PRINT(\" ATTR Handle Read 0x%X r n\" p_event attrHandle); break; } if ((p_event readType == ATT_READ_REQ) || (p_event readType == ATT_READ_BLOB_REQ)) { if ( error) { sp_trsReadRespParams = (GATTS_SendReadRespParams_T *)OSAL_Malloc(sizeof(GATTS_SendReadRespParams_T)); if (sp_trsReadRespParams == NULL) { return; } trsRespErrConnHandle = p_event connHandle; sp_trsReadRespParams- responseType = ATT_READ_RSP; sp_trsReadRespParams- attrLength = 0x01; sp_trsReadRespParams- attrValue[0]= bleCSdata rgbOnOffStatus; // sp_trsReadRespParams- attrLength = 0x03; // sp_trsReadRespParams- attrValue[0]= bleCSdata RGB_LED Red; // sp_trsReadRespParams- attrValue[1]= bleCSdata RGB_LED Green; // sp_trsReadRespParams- attrValue[2]= bleCSdata RGB_LED Blue; status = GATTS_SendReadResponse(p_event connHandle sp_trsReadRespParams); if (status == MBA_RES_SUCCESS) { OSAL_Free(sp_trsReadRespParams); sp_trsReadRespParams = NULL; } } else { sp_trsErrParams = (GATTS_SendErrRespParams_T *)OSAL_Malloc(sizeof(GATTS_SendErrRespParams_T)); if (sp_trsErrParams == NULL) { return; } trsRespErrConnHandle = p_event connHandle; sp_trsErrParams- reqOpcode = p_event readType; sp_trsErrParams- attrHandle = p_event attrHandle; sp_trsErrParams- errorCode = error; status = GATTS_SendErrorResponse(p_event connHandle sp_trsErrParams); if (status == MBA_RES_SUCCESS) { OSAL_Free(sp_trsErrParams); sp_trsErrParams = NULL; } } } } void APP_GattSEvtWriteHandler(GATT_EvtWrite_T p_event) { uint8_t error = 0; uint16_t status; SYS_CONSOLE_PRINT(\"[BLE] GATT Write ATTR Handle 0x%X r n\" p_event attrHandle); if ((p_event attrHandle = BUTTON_LED_START_HDL) || (p_event attrHandle BUTTON_LED_END_HDL)) { /* Not BLE Custom Service characteristic */ error = ATT_ERRCODE_INVALID_HANDLE; return; } switch(p_event attrHandle) { case BUTTON_LED_HDL_CHAR_0: /** Handle of characteristic 0 */ case BUTTON_LED_HDL_CHARVAL_0: /** Handle of characteristic 0 value */ case BUTTON_LED_HDL_CCCD_0: /** Handle of characteristic 0 CCCD */ case BUTTON_LED_HDL_CHAR_1: /** Handle of characteristic 1 */ error = ATT_ERRCODE_APPLICATION_ERROR; break; case BUTTON_LED_HDL_CHARVAL_1: /** Handle of characteristic 1 value */ // SYS_CONSOLE_PRINT(\" ATTR Handle %d r n\" p_event attrHandle); APP_CustomService_RGB_Callback(p_event writeValue); break; } if ((p_event writeType == ATT_WRITE_REQ) || (p_event writeType == ATT_PREPARE_WRITE_REQ)) { if ( error) { sp_trsRespParams = (GATTS_SendWriteRespParams_T *)OSAL_Malloc(sizeof(GATTS_SendWriteRespParams_T)); if (sp_trsRespParams == NULL) { return; } trsRespErrConnHandle = p_event connHandle; sp_trsRespParams- responseType = ATT_WRITE_RSP; status = GATTS_SendWriteResponse(p_event connHandle sp_trsRespParams); if (status == MBA_RES_SUCCESS) { OSAL_Free(sp_trsRespParams); sp_trsRespParams = NULL; } } else { sp_trsErrParams = (GATTS_SendErrRespParams_T *)OSAL_Malloc(sizeof(GATTS_SendErrRespParams_T)); if (sp_trsErrParams == NULL) { return; } trsRespErrConnHandle = p_event connHandle; sp_trsErrParams- reqOpcode = p_event writeType; sp_trsErrParams- attrHandle = p_event attrHandle; sp_trsErrParams- errorCode = error; status = GATTS_SendErrorResponse(p_event connHandle sp_trsErrParams); if (status == MBA_RES_SUCCESS) { OSAL_Free(sp_trsErrParams); sp_trsErrParams = NULL; } } } } Tip: Manual read and write response permissions and other standard events like GAP and GATT can be executed in the app_ble_handler Users can exercise various other BLE functionalities by using BLE Stack API ",
							" BLE Multirole Multilink Transparent UART  Getting Started  Getting Started with Peripheral Building Blocks  Getting Started with Central Building Blocks BLE Transparent UART -- BLE Multilink Transparent UART Introduction This document will help users create a multirole multilink device and send/receive characters between connected BLE devices over Microchip proprietary Transparent UART Profile The multilink central will enable users to connect multiple peripheral devices to a central device The multilink central device will act as peripheral device and will be connected to an another central device(MBD application) The central is MBD application and peripheral devices in this tutorial are WBZ451 devices Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity board and experience the demo or can go through the steps involved in developing this Application from scratch Recommended Reads BLE Software Specification BLE Connection BLE Transparent UART Hardware Required Tool Qty WBZ451 Curiosity Board 3 (min) Micro USB cable 3 SDK Setup  Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Software  TeraTerm Smartphone App Light Blue Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks multirole multilink hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"mr_ml_trp_uart x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks multirole multilink firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description Upon programming the demo application multirole multilink device ( WBZ451 ) will start scanning for near by peripheral devices to connect After a connection has been made data can be sent back and forth over UART between the two devices that are connected The multirole multilink device continues scanning until 100 secs and allows new peripheral devices that are advertising to join For this example we are going to demonstrate 2 BLE links Central Device → MultiRole MultiLink Device → Peripheral Device1 Peripheral Device2 Peripheral Device3 Demo will print start of the scanning \"Scanning\" connected \"Connected \" and disconnected \"Disconnected\" state on a terminal emulator like TeraTerm@ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Application Data to be sent to the connected peripheral device should be entered in the terminal emulator Testing Users should use 3 WBZ451 Curiosity boards Note For demo testing with multiple links users need to configure the BLE Device Address for the 3 peripheral devices as follows Device 1 will have PUBLIC address of {0xA1 0xA2 0xA3 0xA4 0xA5 0xA6} Device 2 will have PUBLIC address of {0xB1 0xB2 0xB3 0xB4 0xB5 0xB6} Device 3 will have PUBLIC address of {0xC1 0xC2 0xC3 0xC4 0xC5 0xC6} Precompiled Hex files for peripheral devices with different addresses as mentioned above are available here Demo Experience when using 4 WBZ451 Curiosity boards 3 configured as Peripheral and 1 configured as MultiRole device This section assumes that a user has already programmed the peripheral_trp_uart application on 3 WBZ451 Curiosity Boards Board1 = WBZ451 Curiosity Board with mr_ml_trp_uart applicaton Programmed Board2(Device1) = WBZ451 Curiosity Board with peripheral_trp_uart application Programmed Board3(Device2) = WBZ451 Curiosity Board with peripheral_trp_uart application Programmed Board4(Device3) = WBZ451 Curiosity Board with peripheral_trp_uart application Programmed Note : It is recommended to reset multirole multilink device first and then the peripheral devices one by one Board1: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Scanning\" message is displayed on the TeraTerm Upon finding peripheral device with public address {0xA1 0xA2 0xA3 0xA4 0xA5 0xA6} message \"Found Peer Node\" will be displayed and a connection request will be initiated \"Initiating connection\" During the scan time if more devices are available which will be true in this case multirole multilink device will keep initiating connections with the new peer nodes Board2/Board3/Board4: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Advertising\" message is displayed on the TeraTerm Note: Scanner is configured to scan only for 100 secs user should ensure the peer device is advertising After connection establishment both the peripheral device (Board2/3/4) and multirole multilink device(Board1) will display \"Connected \" message on respective terminal windows Users can now start sending data back and forth between the multirole multilink device and central/peripheral device using the terminal emulator Characters entered on any peripheral device's (Board2 3 4) terminal emulator will appear on central device's (Board1) terminal emulator Characters entered on any central device(MBD app) terminal will appear on multirole device's (Board1) terminal emulator and also send to all peripheral devices connected Characters entered on multirole multilink device terminal emulator will appear on peripheral devices emulator in a round-robin fashion without priority For example in order to send character \"a\" to all peripheral devices \"aaa\" needs to be entered on terminal emulator of the central device Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview Create a new MCC Harmony Project -- link for instructions Import component configuration -- This step helps users setup the basic components and configuration required to develop this application Users should follow the instructions mentioned here to import the component configuration Tip: Import and Export functionality of component configuration will help users to start from a known working setup of configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Scan Advertisement and Transparent Profile Configuration Select BLE_Stack component in project graph Note: Advertising Interval Min and Max can be modified Tip: Advertisement payload can be configured by user here Select Transparent Profile configuration Generate Code Instructions on how to Generate Code After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers During system sleep clock (system PLL) will be disabled and system tick will be turned off FreeRTOS timer needs to be componsated for the time spent in sleep RTC timer which works in the sleep mode is used to accomplish this RTC timer will be initialized after BLE stack initialization Source Files Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble_handler c All GAP GATT SMP and L2CAP Event handlers app_trspc_handler c All Transparent UART Client related Event handlers app_trsps_handler c All Transparent UART Server related Event handlers ble_trspc c All Transparent Client Functions for user application ble_trsps c All Transparent Server Functions for user application Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file ble_trspc h is the Header File associated with API’s and structures related to BLE Transparent Client functions for Application User ble_trsps h is the Header File associated with API’s and structures related to BLE Transparent Server functions for Application User Function Calls MCC Framework generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c User Application Development Include \"ble_trspc h\" in app c BLE Transparent UART client related API's are available here \"ble_trsps h\" in app c BLE Transparent UART Server related API's are available here \"osal/osal_freertos_extend h\" in app_trsps_handler c OSAL related API's are available here definitions h in all the files where UART will be used to print debug information Tip : definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised user action is required as mentioned here Start Scanning BLE_GAP_SetScanningEnable(true BLE_GAP_SCAN_FD_ENABLE BLE_GAP_SCAN_MODE_OBSERVER 1000); This API is called in the Applications initialstate - APP_STATE_INIT in app c Scan duration is 100 secs Scan Results and intiating a BLE Connection BLE_GAP_EVT_ADV_REPORT event is generated upon finding Adverstisements on legacy channels BLE connection can be initiated by using the API BLE_GAP_CreateConnection( createConnParam_t); // code snippet to filter scan results and initiate connection // Filter Devices based of Address for this example address checking only 2 bytes if ((p_event- eventField evtAdvReport addr addr[0] == 0xA1 p_event- eventField evtAdvReport addr addr[1] == 0xA2) || (p_event- eventField evtAdvReport addr addr[0] == 0xB1 p_event- eventField evtAdvReport addr addr[1] == 0xB2) || (p_event- eventField evtAdvReport addr addr[0] == 0xC1 p_event- eventField evtAdvReport addr addr[1] == 0xC2)) { SERCOM0_USART_Write((uint8_t *)\"Found Peer Node r n\" 17); BLE_GAP_CreateConnParams_T createConnParam_t; createConnParam_t scanInterval = 0x3C; // 37 5 ms createConnParam_t scanWindow = 0x1E; // 18 75 ms createConnParam_t filterPolicy = BLE_GAP_SCAN_FP_ACCEPT_ALL; createConnParam_t peerAddr addrType = p_event- eventField evtAdvReport addr addrType; memcpy(createConnParam_t peerAddr addr p_event- eventField evtAdvReport addr addr GAP_MAX_BD_ADDRESS_LEN); createConnParam_t connParams intervalMin = 0x10; createConnParam_t connParams intervalMax = 0x10; createConnParam_t connParams latency = 0; createConnParam_t connParams supervisionTimeout = 0x48; SERCOM0_USART_Write((uint8_t *)\"Initiating Connection r n\" 23); BLE_GAP_CreateConnection( createConnParam_t); } Connected Disconnected Events In app_ble_handler c BLE_GAP_EVT_CONNECTED event will be generated when a BLE connection is completed Connection Handler Connection handle associated with the peer peripheral device needs to be saved for data exchange after a BLE connection p_event- eventField evtConnect connHandle has this information In Multilink Application unique connection handler's will be generated for all the peripheral links Scan Timeout Handler The initiated scan operation will provide scan timeout event we can start the advertisement to connect with another central device Transmit Data Add \"APP_MSG_UART_CB\" to the generated APP_MsgId_T BLE_TRSPC_SendData(conn_hdl[i] 1 uart_data); is the API to be used for sending data towards the Client device BLE_TRSPS_SendData(conn_hdl[i] 1 uart_data); is the API to be used for sending data towards the Server device Note: * The precompiled application example uses a UART callback to initiate the data transmission upon receiving a character on UART Example Implementation for Transmitting the received data over UART using the BLE_TRSPC_SendData API uint16_t conn_hdl[3];// connection handle info captured @BLE_GAP_EVT_CONNECTED event uint8_t uart_data; uint8_t no_of_links;// No of connected peripheral devices uint8_t i = 0;// link index void uart_cb(SERCOM_USART_EVENT event uintptr_t context) { APP_Msg_T appMsg; // If RX data from UART reached threshold (previously set to 1) if( event == SERCOM_USART_EVENT_READ_THRESHOLD_REACHED ) { // Read 1 byte data from UART SERCOM0_USART_Read( uart_data 1); appMsg msgId = APP_MSG_UART_CB; OSAL_QUEUE_Send( appData appQueue appMsg 0); } } void APP_UartCBHandler() { // Send the data from UART to connected device through Transparent service BLE_TRSPC_SendData(conn_hdl[i] 1 uart_data); i++; if(i==no_of_links) i = 0; //reset link index } // Register call back when data is available on UART for Peripheral Device to send // Enable UART Read SERCOM0_USART_ReadNotificationEnable(true true); // Set UART RX notification threshold to be 1 SERCOM0_USART_ReadThresholdSet(1); // Register the UART RX callback function SERCOM0_USART_ReadCallbackRegister(uart_cb (uintptr_t)NULL); Receive Data BLE_TRSPC_EVT_RECEIVE_DATA is the event generated when data is sent from central device Users need to use the BLE_TRSPC_GetDataLength( data_len) BLE_TRSPS_GetDataLength( data_len) API to extract the length of application data received BLE_TRSPC_GetData( conn_hdl data); BLE_TRSPS_GetData( conn_hdl data); API is used to retrieve the data conn_hdl is the value obtained from Connection Handler section Tip: BLE_TRSPC_Event_T p_event structure stores the information about BLE transparent UART callback functions Tip: BLE_TRSPS_Event_T p_event structure stores the information about BLE transparent UART callback functions Example Implementation for printing the received data from peripheral device over UART /* TODO: implement your application code */ uint16_t data_len; uint8_t *data; // Retrieve received data length BLE_TRSPC_GetDataLength(p_event- eventField onReceiveData connHandle data_len); // Allocate memory according to data length data = OSAL_Malloc(data_len); if(data == NULL) break; // Retrieve received data BLE_TRSPC_GetData(p_event- eventField onReceiveData connHandle data); // Output received data to UART SERCOM0_USART_Write((uint8_t *)\" r nClient Data :\" 15); SERCOM0_USART_Write(data data_len); // Free memory OSAL_Free(data); Users can exercise various other BLE functionalities by using BLE Stack API ",
							" Chip Peripherals Application Examples that showcase BLE Stack Init + Chip Peripheral running ",
							" UART -- Hello World  Getting Started  Getting Started with Peripheral Building Blocks  Getting Started with Central Building Blocks BLE Peripheral Developers: FreeRTOS and BLE Stack Setup  --  Adding UART  --  Legacy Advertisements BLE Central Developers: FreeRTOS and BLE Stack Setup  --  Adding UART  --  Legacy Scan Introduction This document will help users to enable UART functionality on WBZ451 Curiosity board using MPLAB Code Configurator Users of this document can choose to just run the precompiled Application Example hex on the WBZ451 Curiosity Board and experience the demo or can go through the steps involved in enabling UART from scratch using MPLAB Code Configurator Recommended Reads BLE Software Specification FreeRtos BLE App Initialize (Peripheral)  FreeRtos BLE App Initialize (Central) Hardware Required  Tool  Qty WBZ451 Curiosity Board 1 Micro USB cable 1 SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Software  TeraTerm Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks chip_peripherals uart_hello_world hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"uart_hello_world x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks chip_peripherals uart_hello_world firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description This Application Example enables users to print data over a terminal emulator like TeraTerm Testing Connect the WBZ451 Curiosity board to PC program the application example Open Terarerm(Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) and select the COM port that is enumerated when connecting the WBZ451 Curiosity Board Reset the board and Demo will print \"Hello World\" Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project -- link for instructions Import component configuration -- This step helps users setup the basic components required to start their Application Development component configuration related to this Application is available The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks chip_peripherals uart_hello_world firmware uart_hello_world X\" Users should follow the instructions mentioned here to import the component configuration Tip: Import and Export functionality of component configuration will help users to start from a known working setup of configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify UART Configuration Select SERCOM0 component in project graph Select system component in project graph Direct - Digital peripheral is enabled on the default dedicated pins and can operate with Maximum Clock Frequency PPS - Digital peripheral is enabled on pins selected by the MCC pin configurator and can operate with Maximum Clock Frequency/2 Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the peripheral libraries (PLIBs) configuration can be found in the following project directories The sercom initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC according to the user settings Header Files Header File associated with the sercom0 peripheral library or any other peripheral library for a different example is included in definitions h file Tip: To use all the SERCOM0 functionality include the definitions h file in Application code Function Calls MCC generates and adds the code to initialize the UART peripheral in SYS_Initialize() function SERCOM0_USART_Initialize() is the API that will be called inside the SYS_Initialize() function User Application Development Include definitions h in app c (definitions h is called to include the peripheral h files) app_idle_task h in app c Transfer Data using UART Add app_idle_task() in the function vApplicationIdleHook() in freertos_hooks c SERCOM0_USART_Write() is the used to submit a write buffer to the given USART peripheral to transfer data user can call this API in APP_STATE_INIT: Users can exercise various other UART/SERCOM functionalities by using the peripheral library documentation Where to go from here Central role BLE Scanner Peripheral Role BLE Advertisements Peripheral Role BLE Extended Advertisements (sleep) ",
							" Advanced Applications ",
							" BLE Sensor App WBZ451 Curiosity Board Devices (Device):  PIC32CX1012BZ25048 (MCU) on WBZ451 module Devices (Used On-Board): Analog Temperature Sensor RGB LED User Button User LED USB-UART converter  WBZ451 Curiosity Board   Hardware Block Diagram - Curiosity Board Hardware Required Tool Qty WBZ451 Curiosity Board 1 Micro usb cable 1 Andrioid/iOS Smartphone 1  Software Teraterm Smrtphone App Microchip Bluetooth Data (MBD) iOS/Android app available in stores   Programming the precompiled hex file or Application Example  Programming the hex file using MPLABX IPE    Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble advanced_applications ble_sensor precompiled_hex ble_sensor X production signed unified_gpiobased hex\" folder    Follow the steps mentioned here    Caution: Users should choose the correct Device and Tool information  Programming the Application using MPLABX IDE    Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document    Open and program the Application Example \"ble_sensor x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble advanced_applications ble_sensor firmware\" using MPLABX IDE    Harmony Content Path  how to find what is my Harmony Content Path   Demo Description This application demonstrates the capability of WBZ451 module to connect to a mobile phone through Bluetooth Low Energy(BLE) The RGB LED on the Curiosity board can be controlled by mobile app The WBZ451 device will also report the temperature data periodically to mobile phone through Bluetooth low energy (BLE)    The WBZ451 module will be a BLE peripheral device and will advertise on startup The user can initiate the connection through mobile application The advertisement payload holds the temperature information and the RGB ON/OFF status    Uses \"BLE Sensor\" sub app from the Microchip Bluetooth Data (MBD) mobile app for BLE demonstration    Application is supported by iOS and Andrioid OS    Available in respective app stores/play stores      When Connected(ING) to the application the BLUE color \"User LED\" will turn on    Blinks the \"User LED\" with 500 ms blink interval when the device sending advertisement packets    Once connected the \"User LED\" turns on solid      From the Smartphone App the following actions can be performed    The RGB LED can be switched On/Off from MBD mobile app    When LED is switched On the RGB color can be changed from mobile app color wheel   The RGB color value is received as HSV (Hue Saturation Value) from mobile app through TRPS transparent profile and service   The HSV value is converted to RGB equivalent value in the device The corresponding PWM duty cycle for R G B will be calculated and the PWM pulse is provided on R G B LEDs        From the WBZ451 module the following actions can be performed    The RGB LED can be switched on/off by pressing the On board \"User Button\"    When the \"User Button\" is pressed and released the RGB LED is switched ON with default color GREEN or the last stored color    When the \"User Button\" is pressed and released again then the RGB LED will be toggled from the previous state      Read the temperature sensor every 1 sec once and send the temperature value to mobile app when the temperature changes about 1 degree C      Testing  Power Up: Connect the curiosity board using Micro USB to PC Power Supply Green LED will turn on when connected to PC UART Console Behavior The application activity is shown as \"Console Log\" through on board UART-USB converter Open Terminal (eg: Tera Term) to look for these logs - UART baud settings: 115200 8-N-1 without flow control BLE Not Connected Behavior The Blue \"User LED\" will be blinking Scanned from mobile app as \"BLE_Sensor_XXXX\" where 'XXXX' is a uniqu number associated with this board Launch MBD mobile app and follow the below screenshots   BLE Connected Behavior (Connected to \"BLE Sensor\" MBD Mobile Application) The Blue \"User LED\" will be solid On when connected        Firmware Version Bluetooth SIG defined \"Device Info Service\" is implemented in the device to share the device information like \"firmware version\" \"manufacture name\" etc Verify the firmware version shown on console with MBD app The BLE Sensor mobile app will show the temperature (deg C) and LED status received from device as well as allow the user to vary the RGB color and brightness  The RGB LED can also be switched On/Off by pressing the On board \"User Button ( SW2 )\" The On/Off LED status will also be reported to mobile app if connected When the \"User Button ( SW2 )\" is pressed and released RGB LED is switched ON When pressed and released again the state will be toggled from the previous state  Protocol Exchange The communication protocol exchange between BLE sensor mobile app (BLE central) and WBZ451 module (BLE peripheral) is explained here Application Flow Diagram Expanding/Customising the Application The BLE Sensor demo protocol based on TRPS profile is a transparent request response based and not tied only to this BLE sensor application It can be expanded and customized as per the users need  The protocol parser is implemented in app_trps c and app_trps h  Request and Response: when user wants to get and modify data on the device  Notify: when there is a new data to be sent to mobile app    The protocol commands are defined in app_ble_sensor h and related sensor functionalities are implemented in app_ble_sensor c  Request and Response: When a command request is received from mobile app app_trps c parse the data and forward to specific command callback handler in app_ble_sensor c  Notify: When specific Sensor data to be sent to mobile app app_ble_sensor c places the data in data base and calls for notify handler in app_trps c (/ref APP_TRPS_SendNotification())   Example: To add a command to get temperature in Fahrenheit Complete the SDK Setup and open the \"ble_sensor x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble advanced_applications ble_sensor firmware\" using MPLABX IDE Changes to - app_ble_sensor h Define request response size of response payload (not including size of length byte and response ID) Define a new control command ID Define a new control command response Define the length for the new response command Inside the existing APP_TRPS_SensorData_T structure add the new data structure which holds the response data Increase the list size BLE_SENSOR_CMD_RESP_LST_SIZE by one Add new command request/response set in BLE_SENSOR_DEFINE_CTRL_CMD_RESP() list Changes to - app_ble_sensor c Read the temperature periodically and store in above defined data structure Add the below code in App_TRPS_Sensor_TimerHandler() After doing the above changes follow the instruction in select option Build Project in IDE to compile the application example   Select option Run Project in IDE to program the target – the onboard debugger will program the example application  Testing with MBD mobile app The \"BLE Sensor\" sub app in MBD mobile app is designed only to work with specific functionality So if new command is added in BLE sensor application \"BLE Sensor\" mobile app will not know about it To test the above newly added code \"BLE Smart\" sub app in MBD can be used Follow the below screenshots after launching MBD mobile app Using MPLAB Code Configurator MPLABX Harmony provides the MPLAB® Code Configurator (MCC) tool a set of modular device and middleware libraries and numerous example applications all of which are designed to help developers to quickly and easily develop powerful and efficient embedded software MPLAB® Code Configurator (MCC) is a free graphical programming environment that generates seamless easy-to-understand C code to insert into your project Using an intuitive interface it enables and configures a rich set of peripherals and functions specific to your application The following steps can be followed to open MCC tool and generate the code Open MCC tool from MPLABX Once the MCC tool is launched the \"Project Graph\" shows the list of MCC components used in the specific project Clicking on the specific component block will allow to change the configuration of that component eg:SERCOM0 is shown in the screenshot New component can also be added by drag and drop from \"Device Resources\" to \"Project Graph\" Then configure the component as in step #3 eg: SERCOM1 can be added into \"Project Graph\" Once all the required components and configurations are done Generate Code ",
							" Protocol Exchange The communication protocol exchange between mobile app (BLE central) and WBZ451 module (BLE peripheral) is explained here 1 BLE Sensor Data in Advertising Beacon: Advertisement Data: Service UUID: 16-bit Service UUID 0xFEDA is purchased by Microchip from Bluetooth SIG BLE Sensor data: 0x40+Light ON/Off status (1 Byte)+ 0x41+Temperature data (2 bytes) Scan Response Data: The device name is part of the scan response Device name is set as \"BLE_SENSOR_XXXX” (XXXX means the last two bytes of the device address) 2 Transparent Profile and Service (TRP/TRS): Transparent Profile and Service (TRP/TRS) is the proprietary BLE service by microchip to establish data and control channel between BLE Central (Phone) and Peripheral (device) Transparent Profile (TRP) enables higher layer application to control and allow data exchange between TRP Client and Server devices Transparent Service (TRS) includes both Ctrl and Data Pipes which are custom 128-bit GATT characteristics The Transparent Server shall be a GATT Server The Transparent Client shall be a GATT Client Definition of Transparent Service and Characteristics UUID's Characteristic Name UUID Properties TRS Service 49535343-FE7D-4AE5-8FA9-9FAFD205E455 TRS TxD- Tx Data to Client role (Data pipe) 49535343-1E4D-4BD9-BA61-23C647249616 Notify Write TRS TxD - Client Characteristic Configuration Descriptor Read Write TRS RxD- Rx Data from Client role (Data pipe) 49535343-8841-43F4-A8D4-ECBE34729BB3 Write Write without response TRS Ctrl Pt - Command and Response (Ctrl pipe) 49535343-4C8A-39B3-2F49-511CFF073B7E Notify Write Write without response TRS Ctrl Pt - Client Characteristic Configuration descriptor Read Write 3 BLE Sensor Application over Transparent Service Control Point (TRS Ctrl Pt): BLE Sensor application uses TRS Control Point Characteristic of TRPS profile to exchange data between mobile phone and device The BLE Sensor application follows the below protocol format on TRS control point characteristic Item Opcode Length Sensor/Control ID Payload Size 1 Byte 1 Byte 1 Byte Variable The description of each element is as below: - The Opcode: (0x8A) is fixed 1 byte in size and related to BLE Sensor/Control commands - Length: 1 byte in size (size of Sensor/Control ID + size of Payload) - The Sensor/Control ID: 1 byte in size It could be divided into Control request Control response Sensor notify data described in detail in following sections - The Sensor/control data and payload size depends on the Sensor/Control ID as listed in the below table BLE sensor application control and sensor command/response Control Cmd Opcode Control Request ID Parameter Parameter Length (Byte) Control Response ID Control Response Payload Control Response Payload Length (Byte) Description RGB LED On/Off Set 0x8A 0x10 On/Off 1 0x20 Status code 1 Switch On/Off the RGB LED with the default/last set color RGB LED On/Off Get 0x8A 0x11 0x21 Status code + On/Off status 2 Send the RGB LED on/off status RGB Color Set 0x8A 0x12 Color value (HSV) 3 0x22 Status code 1 Set RGB color value in HSV format RGB Color Get 0x8A 0x13 0x23 Status code + RGB color value 4 Send RGB color value in HSV format Sensor Data Sensor ID Parameter Parameter Length (Byte) Description RGB LED On/Off status 0x8A 0x40 On/Off status 1 RGB LED On/Off Status Temperature data 0x8A 0x41 Temperature sensor data 2 Temperature value in Celsius with 0 1 resolution The MSB bit will be set when the negative temperature is reported 3 1 Control Command Request and Response The Control command request is used by mobile app to send the command to device The control request channel is opened only after Client Characteristic Configuration Descriptor of TRS Ctrl Pt Characteristic notification is enabled; it is closed when such notification is disabled The format of Control command is an 8bit Opcode an 8bit request ID followed by optional control payload Format of Control Command Item Op Code Length Control Request ID Control Payload Size (Octet) 1 1 1 Variable The control response is used by the device to send feedback to mobile app The format of Response is an 8bit Opcode an 8bit response ID and response status followed by optional Response payload Format of Control Response Data Item Op Code Length Control Response ID Status Control Response Payload Size (Octet) 1 1 1 1 Variable Status code 0x00 means successful execution of control command Any status code other than 0x00 means error code as shown in below Table An error status does not have optional control Response payload Definition of Status Code Status Code Definition Description 0x00 Success Response for successful operation 0x01 Op Code Not Supported Response if unsupported Op Code is received 0x02 Invalid Parameter Response if Parameter received does not meet the requirements of the service 0x03 Operation Fail Response for fail operation 0x04-0xFF Reserved for Future use 3 2 Sensor Notify Data The Sensor data is sent to mobile app periodically by WBZ451 device The sensor data channel is opened only after Client Characteristic Configuration Descriptor of TRS Ctrl Pt notification is enabled; it is closed when such notification is disabled The format of sensor data is an 8bit Opcode an 8bit Sensor ID followed by sensor data payload Format of Sensor Data Item Op Code Length Sensor ID Sensor Payload Size (Octet) 1 1 1 Variable ",
							" BLE Throughput This document is to illustrate the example of PIC32CXBZ2 BLE throughput evaluation using Microchip MBD APP At the same time the factors affecting the BLE throughput are also discussed 1 Introduction The purpose of this document is to illustrate the user-guide of the BLE_THROUGHPUT Application for PIC32CXBZ2 The BLE_THROUGHPUT Application is designed to demonstrate several functionalities including: Connection with mobile phone via BLE Data transmission between PIC32CXBZ2 and mobile phone via BLE and throughput evaluation Data transmission from PIC32CXBZ2 to mobile phone via BLE and throughput evaluation Data transmission from mobile phone to PIC32CXBZ2 via BLE and throughput evaluation 1 1 Data Format for Advertising - Advertising Data The Service Data type is used in advertising data The data format is shown as below: Advertisement Data Format *Note: 0xFEDA is a 16-bit Service UUID which is purchased by Microchip from Bluetooth SIG - Scan Response Data The device name is put in the scan response And the device name is set as \"BLE_UART_XXXX\" (XXXX are the last two bytes of the device address ) 1 2 Supported Services and Profiles The supported service and profile are listed in the below section - Services Transparent Service MCHP proprietary service see Reference [1] for the detail Device Information Service Bluetooth SIG standard service see Reference [3] for the detail - Profiles Transparent Profile (TRP) MCHP proprietary profile see Reference [4] for the detail 1 3 LED Indication The LED indication is defined as below based on the different role and state: Advertising State (No LE link existed) Green LED flashes one time every 500 ms Connected with peer device Green LED is solid on 2 Interaction with MBD App 2 1 Work with iOS MBD App - How to Scan and Connect to the Device The steps to scan and connect to the device via MBD app are described as below: Tap \"BLE UART\" in MBD App MBD App iOS Version Tap \"PIC32CXBZ\" BLE UART GUI Tap \"START\" PIC32CXBZ GUI Tap \"BLE_UART_XXXX\" (XXXX are the last two bytes of the device address) \"START\" Scanning GUI - Firmware Version After LE is connected tap the setting button: \"Connected\" GUI The firmware version is shown as the below screenshot: Firmware Revision in \"Setting\" GUI - Select Transparent Profile There are two profiles supported by the MBD \"BLE UART\" APP but \"BLE_THROUGHPUT\" firmware supports TRP only Legacy Transparent Profile (TRP) This is supported by \"BLE_THROUGHPUT\" firmware Transparent Credit Based Profile (TRCBP) This is NOT supported by \"BLE_THROUGHPUT\" firmware - Select GATT WriteType TRP profile supports both \"Write with Response\" and \"Write without Response\" which is much higher than the former GATT WriteType in \"Setting\" GUI - Demo Modes There are two demo modes: Burst Mode and Text Mode Burst Mode is designed for the throughput evaluation via massive data transmission Text Mode is designed for the simple text typing Demo Modes in \"Setting\" GUI A Burst Mode There are four data transfer modes supported in Burst Mode: Checksum mode MBD App to the device (Uni-direction) Fixed pattern mode Device to MBD App (Uni-direction) Loopback mode MBD App → Device → MBD App (Bi-direction) UART mode MBD App → Device → UART output to PC ; UART input from PC → Device → MBD App (Bi-direction) This mode is NOT supported by \"BLE THROUGHPUT\" firmware BLE UART Mode in \"Setting\" GUI B Text Mode There are two data transfer modes supported in Text Mode: Loopback mode MBD App → Device → MBD App (Bi-direction) UART mode MBD App → Device → UART output This mode is NOT supported by \"BLE THROUGHPUT\" firmware Text Mode \"Setting\" GUI 2 2 Work with Android MBD App The operation of Android MBD App is quite the same as the iOS version MBD App 3 Throughput Evaluation In this section we will describe the throughput evaluation steps and a list of throughput figures tested with a list of phone models for reference only Finally we also discuss the factors affecting the throughput 3 1 Throughput Evaluation Steps Connect a USB cable to a WBZ451 CURIOSITY board Download the BLE_THROUGHPUT firmware Run a terminal tool like \"Tera Term\" Open the serial port connecting to WBZ451 CURIOSITY and configure the setting as below: Serial Port Setup Press the reset button on the WBZ451 CURIOSITY board and the initialization string will be shown as below Initialization Output Connect the \"BLE UART\" of MBD APP to WBZ451 CURIOSITY board Select \"Burst mode\" Select \"Demo Mode\" in setting page Except UART mode all the other modes are supported by \"BLE_THROUGHPUT\" Select Text file size in setting page The TRP profile is automatically selected Select \"GATT WriteType\" \"Write without Response\" will achieve much higher throughput Tap \"Done\" and back to the previous page Tap \"START\" After sending the file the throughput is evaluated and shown as below: Throughput Evaluation GUI 3 2 Throughput Test Report The below tables show the throughput test result with iOS and Android devices with the configuration as Profile TRP GATT Write Type Write without Response Downlink Tested with \"Checksum\" data transfer mode Uplink Tested \"Fixed pattern\" data transfer mode iOS Devices Reference Throughput with iOS Devices Android Devices Reference Throughput with Android Devices 3 3 Factors affecting Throughput In BLE_THROUGHPUT example the WBZ451 is the GATT server while the MBD App is the GATT client There are 7 main factors affecting the throughput Some factors are negotiated and determined by the BLE stack of the GATT client and server And some factors can be modified or requested by the user level application code using the APIs exposed by underneath BLE stack ATT MTU size Larger MTU size achieves higher throughput Assuming the MTU size is x then the Max application data payload in one operation is of x minus 3( excluding 1byte of GATT operation code and 2 bytes of the attribute handle ) In PIC32CX1012BZ25048 BLE stack the Max MTU is set to 247 bytes The final MTU used by the GATT client and server will depends on the negotiation initiated by the GATT client For iOS the MTU size is determined by the underneath BLE stack while the user level application can use API to learn the determined MTU For Android the MTU size can be requested by the user level application code using API of \" requestMtu (int mtu) \" and the user application code should observe the result from \" onMtuChanged \" callback Operation Type For downlink operation the \"Write without Response\"(Write Command) is always faster than the \"Write with Response\"(Write Request) For uplink operation the Notify operation is always faster than the Indication operation which requires a confirm from peer device It's the responsibility of BLE_THROUGHPUT firmware to define the property of the GATT characteristics The property in turn defines the permitted operation type Data Length Extension(DLE) Link layer data packet length by default is 27 bytes From BLE 4 2 onward the link layer data packet length can be extended to as long as 251bytes This feature is called Data Length Extension(DLE) Note that some phone models might not support DLE while PIC32CX1012BZ25048 BLE stack supports it DLE negotiation is conducted by underneath BLE stack of both the client and the server User level application code has no API to modify the link layer data packet length Connection Interval(CI) The CI defines the frequency of the Connection Event Shorter CI causes higher frequency of the Connection Event Certain number of data packets can be sent during one connection event It is obvious that the shorter CI the lesser number of data packets can be sent in one Connection Event In contrast the longer CI the higher opportunity to send larger number of data packets in one Connection Event The iOS device might limit the CI parameter according to the peripheral type See reference[6] for more details PIC32CX1012BZ25048 BLE stack provides API of \" BLE_DM_ConnectionParameterUpdate \" to update the connection parameter The final connection parameter is decided by negotiation of both the client and the server stack On Android the equivalent API is \" requestConnectionPriority \" while there is no such similar API available on iOS Number of Data Packets per Connection Event The number varies from iOS to Android and from revision to revision There is no direct API available on either iOS or Android to define this number User can fine tune the CI to get ideal value and verify the result in the air log PHY Selection From BLE 5 0 onward LE 2M PHY is introduced It is 2x faster than the former LE 1M PHY Gradually the phone models in the market will embrace this new feature Either the GATT client or server might request to update the PHY to LE 2M according to PHY Update Procedure defined by SIG see reference [7] for details WBZ451 is born to support this feature and the API of \" BLE_GAP_SetPhy \" is available to user level application code to change the PHY selected PHY Update Procedure In BLE_THROUGHPUT example the API \" BLE_GAP_SetPhy \" is called on writing the handle of TRP TX characteristic CCCD(Client Characteristic Configuration Descriptor) operated by peer device illustrated as below image For more details on TRP see reference[1] PHY Update Procedure in Example Firmware A event of BLE_GAP_EVT_PHY_UPDATE will be generated on the completion of this procedure then the user can check the result in this event This event is handled by APP_BleGapEvtHandler( ) of GAP handler in this example The RF Factor The noisy RF environment can decrease the throughput The well designed RF circuit can achieve higher throughput Finally the casing condition of the end product containing the BLE device can also affect the throughput 4 The BLE_THROUGHPUT Example Firmware Diagram The BLE_THROUGHPUT firmware is designed for WBZ451 CURIOSITY board The firmware is based on TRP service There are 3 data transfer modes supported by the BLE_THROUGHPUT firmware including Checksum mode Fixed pattern mode and Loopback mode To simplify the UART mode is not implemented in this example The firmware diagram below illustrates the main part of the firmware Example Firmware Diagram References [1] Microchip Transparent Service_v1 1 [2] Microchip Transparent Credit Based Service v1 0 [3] https://www bluetooth com/specifications/gatt/ [4] Microchip Transparent Profile_v1 1 [5] Microchip Transparent Credit Based Profile_v1 0 [6] https://developer apple com/accessories/Accessory-Design-Guidelines pdf [7] https://www bluetooth com/specifications/specs/core-specification-5-3/ ",
							" BLE Virtual Sniffer This document explains how to use the MPLAB Code Configurator(MCC) framework to add BLE Virtual Sniffer system service component for capturing the HCI packets and feed it to the sniffer tool for debugging purposes Introduction The BLE Virtual Sniffer uses BLE LOG middleware available as part of BLE Stack (BLE stack dependency) for restructuring of the HCI protocol packets The BLE Virtual Sniffer has dependency of UART(To Output the HCI packet) which can be satisfied through Harmony CONSOLE system services Hardware Required Tool Qty WBZ451 Curiosity Board 1 Micro USB cable 1 SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Software Wireless Protocol Suite(WPS) Microchip_BLE_Sniffer_Tool Developing an Application with BLE SNIFFER component using MPLAB Code Configurator(MCC) This section explains the steps required by a user to integrate and use the BLE Virtual Sniffer component into any application Tip: New users of MPLAB Code Configurator (MCC) are recommended to go through the overview of MCC Users can add/remove different components like peripheral support and other wireless functionality by following steps mentioned here  Create a new MCC Harmony Project -- link for instructions Ensure that wireless_system_pic32cxbz2_wbz45 repo is available locally in the development repo Open MCC The Wireless System Service components will be displayed in available Device Resources -- Wireless -- System Services as shown in the below figure Drag BLE SNIFFER component from Device Resources to project graph area and accept all Dependencies or satisfiers(auto-activation components) select \"Yes\" BLE SNIFFER will automatically enable the BLE LOG FEATURE(Enable BLE Log option) inside Ble stack as shown in the figure Connect the BLE SNIFFER with one of instances of SERCOM to satisfy the \"UART\" dependency of BLE SNIFFER Ensure that the Transmit pinout and Receive pinout settings are configured properly inside SERCOM plib configuration options as shown in the figure NOTE: Please refer device data sheet for pin and pad configurations Generate the code Refer link for more details After generating the program source from MCC interface by clicking Generate Code the BLE LOG application service can be found in the following project directories Compile and Run the project in WBZ45x device Capturing and Parsing the HCI Sniffer Packets through Microchip BLE Sniffer Tool Make sure to install Wireless Protocol Suite open the WPS installed location and copy the following files as shown in the figure liveimport and LiveImportAPI dll (available inside Executables- core as part of WPS installation) Microchip_BLE_Sniffer_Tool (available in the link in software section) Open command prompt from the WPS installed location and run Microchip_BLE_Sniffer_Tool using the following command Microchip_BLE_Virtual_Sniffer_Tool exe \"com_port\" \"Baud_Rate\" (eg: Microchip_BLE_Virtual_Sniffer_Tool 23 921600) as shown in the figure NOTE: It is recommended to Configure the Virtual sniffer SERCOM at highest Baud Rate(921600) and is fixed to 921600 for efficient usage of the sniffer Open WPS tool and virtual sniffing data capture option in the startup page and start record as shown in the figure below Reset the WBZ451 device and the captured packet will appear in WPS Tool and the total number HCI packets captured will be displayed in the Microchip_BLE_Sniffer_Tool command prompt as shown in the figure ",
							" Getting Started with Zigbee Applications This is a generic document which gives the user an overview of few key Zigbee 3 0 protocol concepts and guidance on implementing these features on PIC32CX-BZ/WBZ using Microchip software It shows how the protocol configurations(such as application device types clusters commissioning) can be enabled/disabled configured in a step by step manner using Microchip's embedded software development framework tools Microchip Harmony Framework is a full-featured production grade embedded software development platform from Microchip It provides a framework for creating zigbee devices running on PIC32CX-BZ/WBZ family of device and modules Device Types and Clusters To allow interoperability among ZigBee products produced by various manufacturers the ZigBee Alliance has defined a set of standard device types These device types specify the functionality of a device This functionality is again dependent on independent functional entities called clusters which is a container of attributes which can be read/written through command/responses defined by Zigbee Device Profile(ZDP) The alliance also provides a library ZigBee Cluster Library (ZCL) is intended to act as a repository for cluster functionality A developer constructing a new application should use the ZCL to find relevant cluster functionality that can be incorporated into the new application so as not to “re-invent the wheel” Zigbee Device reference application implements behavior of Zigbee Lighting and Occupancy (ZLO) devices and Green power device for operation on a Zigbee network Supported Device Types The list of Application device types supported as part of reference applications are as follows: Combined Interface( Gateway / Coordinator) Light devices (OnOff / Dimmable / Color / Extended Color / Temperature Color Light) Thermostat Color scene controller Multi Sensor Intruder Alarm System(IAS) - ACE Zigbee Green Power (Proxy Sink) - An additional feature which is enabled on top of the above device types based on its capability For more details regarding Zigbee lighting and Occupancy device types please refer to Zigbee Lighting and Occupancy (ZLO) specification - Link to Zigbee Lighting and Occupancy (ZLO) device Specification by Zigbee Alliance Microchip Harmony framework allows users to create applications for above supported device types The MPLAB Code Configurator (MCC) is the GUI based configurator also allows user to select optional clusters as per their use case Below it can be observed that how the supported device types can be accessed using MPLAB Code Configurator (MCC) tool after launching MCC GUI [Follow the step by step procedure to generate a zigbee based project of any supported device type from MPLAB Code Configurator (MCC)]( #tasks_1 ) Supported Clusters The clusters in the ZigBee Cluster Library incorporate the concept of a client who initiates the transaction and the server who performs the work For example a light switch (color scene controller device type which implements on/off cluster in client role) initiates the transaction when someone taps the light switch One or more lights (OnOff device type which implements on/off cluster in server role) complete the transaction by turning on or off and perhaps reporting the status change to some monitoring device(s) (combined interface device type which implements on/off cluster in client role) The table below shows the client/server clusters available for various device types in Microchip Zigbee stack S No Device Type Server Clusters Client Clusters 1 Combined Interface Basic Identify Groups Tie IAS ACE Level Control Color Control Alarms Thermostat FanControl Occupancy Sensing Illuminance Measurement Temperature Measurement Thermostat UI IAS Zone Basic Identify Groups Scenes OnOnff 2 OnOff Light Basic Identify Groups Scenes OnOff Basic Identify Groups 3 Dimmable Light Basic Identify Groups Scenes OnOff Level Control Basic Identify Groups 4 Color Dimmable Light Basic Identify Groups Scenes OnOff Level Control Color Control Basic Identify Groups 5 Extended Color Light Basic Identify Groups Scenes OnOff Level Control Color Control Basic Identify Groups 6 Temperature Color Light Basic Identify Groups Scenes OnOff Level Control Color Control Basic Identify Groups 7 Thermostat Basic Identify Groups Scenes Alarms Thermostat Fan Control Occupancy Sensing Temperature Measurement Temperature UI Configuration Basic Identify Groups Time Fan Control Occupancy Sensing Illuminance Temperature Measurement 8 Color Scene Controller Basic Identify Groups Scenes OnOff Level Control Color Control Basic Identify Groups 9 Multisensor Basic Identify Groups Occupancy Sensing Illuminance Measurement Temperature Measurement Diagnostics Basic Identify Groups 10 Intruder Alarm System (IAS) ACE Basic Identify Groups IAS Zones Basic Identify Groups IAS ACE For more details regarding clusters please refer to the specification from Zigbee Alliance - Link to Zigbee Cluster Library Specification by Zigbee Alliance For more details regarding mandatory or optional clusters for specific device type please refer to the specification from Zigbee Alliance - Link to Zigbee Lighting and Occupancy Devices by Zigbee Alliance How the available clusters can be accessed for a combined interface device type using MPLAB Code Configurator (MCC) tool is shown below The optional clusters/attributes/commands as per zigbee device specification can be added/removed from the project through configuration as per custom use case Reference Examples The list of Application device types supported as part of reference applications are as follows: Combined Interface( Gateway / Coordinator) Light devices (OnOff / Dimmable / Color / Extended Color / Temperature Color Light) Thermostat Color scene controller Multi Sensor (with low power mode enabled) Intruder Alarm System(IAS) - ACE Zigbee Green Power (Proxy Sink) - An additional feature which is enabled on top of the above device types based on its capability Few sample application projects are available as reference in the zigbee folder Other device type projects can be created using MPLAB Code Configurator (MCC) tool by following very simple steps - Zigbee Project Generation There are different zigbee device types supported in Microchip Zigbee framework Few sample application projects are available as reference Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps zigbee The projects for other device types can be generated by following the step by step procedure in this document Demo Steps Detail demo steps of establishing zigbee network zigbee commissioning and data exchange between zigbee devices are explained Centralized Network Formation in Combined Interface Light control and Monitoring using Combined Interface Note: Though the demo step takes Combined interface and extended color light/multi-sensor the hardware setup network formation commissioning/joining procedures can be followed for other supported device types like Thermostat IAS ACE joining to combined interface network Serial Console Commands - Serial Console Commands Zigbee Serial console commands References IEEE Std 802 15 4™-2006 Part 15 4: Wireless Medium Access Control (MAC) and Physical Layer (PHY) Specifications for Low-Rate Wireless Personal Area Networks (WPANs) https://zigbeealliance org/ https://groups zigbee org/wg/progp-bg/document https://zigbeealliance org/wp-content/uploads/2019/11/docs-15-0014-05-0plo-Lighting-OccupancyDevice-Specification-V1 0 pdf https://zigbeealliance org/wp-content/uploads/2019/12/07-5123-06-zigbee-cluster-library-specification pdf ",
							" Zigbee Project Generation There are different zigbee device types supported in Microchip Zigbee framework Few sample application projects are available as reference Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps zigbee The projects for other device types can be generated by following the step by step procedure in this document   SDK Setup    Gettting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC    Generating Intended Device Type project using MCC    Create a new MCC Harmony Project -- link for instructions    Click on \"+\" symbol on the Intended Zigbee Device Type component from \"Device Resources\"   \"OnOffLight\" Device component is shown for example    \"Accept Dependencies or satisfiers select \"Yes\"\"        Add UART components needed for console logs and commands (optional) Verify the UART SERCOM configuration as here   Verify if the Project Graph window has all the expected MCC configurations   Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by MCC After generating the code from MCC tool by clicking Generate below is the project folder structure Zigbee Stack Initialization and Application callback registration The RF System ZIGBEE PERIPHERAL initialization routine executed during program initialization can be found in SYS_Initialize() of initialization c file Zigbee Stack provides various APIs for application and those APIs belong to the specific module within dedicated group The sequence of initialization is already taken care in the stack when Zigbee_Init() from initialization c is called   Zigbee Stack generate events to inform application if there is any status changed or activity Application may need to get the relevant information from Zigbee Stack and do the corresponding procedure Zigbee Stack application events handling app c file is autogenerated and has a state machine for application callback handling from Zigbee stacks User Application Development Compile MCC auto generated project   Edit device unique ID (zigbeeAppDeviceSelect h) All the zigbee devices/modules will hold their unique IEEE address purchased from IEEE For the demo purpose where UID is not present in internal NVM the pre-compiled fixed UID to be used Edit the CS_UID to user defined value and not matching with combined interface UID (default 0xbee) as below in zigbeeAppDeviceSelect h   Programming the Application using MPLABX IDE Build the project after doing all the above changes and program on Curiosity board Hints: Custom code modification (app_zigbee_handler c) There will be 3 major events which the stack would provide to the user application in app_zigbee_handler c file They are Zigbee Events which is defined as \"EVENT_ZIGBEE\" ZCL and Cluster Events defined as \"EVENT_CLUSTER\" For more details regarding clusters please refer to the specification from Zigbee Alliance - Link to Zigbee Cluster Library Specification by Zigbee Alliance ZCL specific cluster events are received in ZCL EVENT_CLUSTER Cluster_Event_Handler() in application layer For the all the supported device types most of the ZCL specific activities are automatically handled in middleware If user wish to take some action of ZCL events can do changes in this Cluster_Event_Handler() for the specific ZCL event Board Specific Package (BSP) Events defined as \"EVENT_BSP\" In addition to above ZCL event BSP event will also be called when specific ZCL command is received BSP_Event_Handler() API is called for EVENT_BSP event This will enable the user to write the board specific functionality code like switch on/off the on board LED controlling the thermostat Refer to Extended Light BSP Handling Hints: Zigbee Specific MCC Configuration Harmony3 based Microchip Zigbee stack framework allows user to do different configurations and generate the code based on that configurations Auto and Manual Configuration When the device type component is added in project graph the default will be auto configuration All the allowable configurations will take already defined default values in the generated code Enabling \"Manual Configuration\" will allow user to change the configurations Stack configuration Zigbee stack specific configurations like routing table size maximum allowable children to get joined in one parent etc can be changed based on the customer application use case The changed configurations will be reflected in stackConfig h  Tip:  The table size configurations will have impact on RAM memory size So care must be taken while choosing the values   Commissioning Configuration Commissioning is the process of initializing the devices to join a network and to work together The Zigbee Base Device Behaviour specification specifies the procedures for different commissioning mechanisms MCC configuration allows user to configure this from configurator The details of different commissioning procedure is explained in Zigbee Commissioning Commissioning is the process of initializing the devices to join a network and to work together The Zigbee Base Device Behaviour specification specifies the procedures for the following commissioning mechanisms which are executed in the order as given given below These configuration changes are reflected in zigbeeAppConfig h      Application Configuration Application specific configurations like enabling the console commands is done here The console based commands would be practically needed during development stage This may not be needed end product stage So this configuration gives flexibility to enable/disable based on the need \"Enable Zigbee Console Commands\" to be checked always When the console command is enabled make sure the required UART driver is configured as done in UART Component Addition There are different zigbee device types supported in Microchip Zigbee framework Few sample application projects are available as reference Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps zigbee The projects for other device types can be generated by following the step by step procedure in this document The details of manual commands and usage is explained Console commands Zigbee Serial console commands Another configuration is zigbee primary/secondary channel masks configuration Zigbee supports 16 channels (channel 11 to 26) in 2 4GHz frequency band These 16 channels are bit mapped to bits 11 to 26 For example in channel mask 0x0000800 bit 11 is set This means channel 11 is enabled These configuration changes are reflected in zigbeeAppConfig h and stackConfig h files   Cluster Configuration All the supported mandatory and optional clusters in specific device type as per specification are implemented The MCC configurator allows user to add/remove the optional clusters/attributes/commands   For more details regarding Zigbee lighting and Occupancy device types please refer to Zigbee Lighting and Occupancy (ZLO) specification - Link to Zigbee Lighting and Occupancy (ZLO) device Specification by Zigbee Alliance ",
							" Zigbee Console Commands Zigbee Serial console commands The ZigBee application support includes implementation of a serial console that allows control and monitoring of the ZigBee device over a serial connection using a terminal program (HyperTerminal Tera Term etc ) on a PC Note:- These commands are mainly used for testing or demonstration purpose only - The end customer application may or may not use this command based approach - But the code implementation used in these commands internally uses global zigbee stack API's which can be taken as reference for API usage Setup To enable the use of console In MPLAB Code Configurator (MCC) Connect \"Zigbee console\" in the Zigbee device component to USART Driver Component and to SERCM0 component (for WBZ Curiosity Board) as shown below Configure the SERCOM0 component as shown in the below figure to set the uart baud rate parity data bits and Sercom Tx and Rx pins   Select system component in project graph  Direct - Digital peripheral is enabled on the default dedicated pins and can operate with Maximum Clock Frequency  PPS - Digital peripheral is enabled on pins selected by the MCC pin configurator and can operate with Maximum Clock Frequency/2    The MCC configurator also gives the flexibility to select commands based on different Groups It is highly modularised  The MCC generated code for console can be seen in application folder:   On the PC side virtual COM port connection that corresponds to the board shall have following settings:BAUD RATE: 115200 (as configured in SERCOM configuration)- PARITY: None- DATA BITS: 8- STOP BITS: 1- FLOW CONTROL: None Additionally local echo and sending line ends with line feeds shall be enabled in the PC serial terminal application    Commands  Once the COM port is opened in the PC terminal application the console commands can be entered in terminal application Type ‘help’ to list the help commands type as shown in below figure    Help Command Syntax Response Description help Commands: zdoHelp commissioningHelp zclHelp Shows supported help sections The console commands are categorized into three sections commissioningHelp zdoHelp zclHelp commissioningHelp Commands:Refer Commissioning Help commissioningHelp list the command that are related to commissioning of the Zigbee device zdoHelp Commands: Refer ZDO Help zdoHelp list the group of commands that are categorized to zdo (zigbee device object) functionality zclHelp Commands: Refer ZCL Help zclHelp list the group of commands that are categorized to zcl (zigbee cluster library) functionality The clusters are specific to device type and the zclHelp list commands based on clusters that are supported in the device type of the project Commissioning Help When commissioningHelp is entered in the terminal application the device lists all the supported commands that are related to commissioning of the zigbee device         Command Syntax    Response    Description        invokeCommissioning mode gid  e g : invokeCommissioning 4 0    Nwk Formation: Success  CommissioningStatus = 0    Invokes commissioning with the groupid (bdbCommissioningGroupID) and input modes enabled  - 1 - Touchlink  - 2 - Steering  - 4 - Forming  - 8 - Finding and Binding  Multiple modes can be enabled Details of different commissioning methods is explained here      getAppDeviceType  e g : getAppDeviceType    HADeviceType = 0x0007    Request for Application Device Type  The response 7 indicate that the device is combined interface  Refer Application Device Type Responses table for more details      getDeviceType  e g : getDeviceType    DeviceType = 2    Request for Zigbee Device Type  The response 2 indicate that device is of type Zigbee Coordinator  Refer Zigbee Device Type table for more details      getExtAddr  e g : getExtAddr    0000000000000bee    Return the extended Address (MAC Address) of the Zigbee device  Here 0x0000000000000bee is the extended address      getNetworkAddress  e g : getNetworkAddress    0000    Return the network address / short address of the zigbee device  Here 0000 is the network address of the Zigbee device in hex format      getChannel  e g : getChannel    25    Return the current operational channel  Here the device is operating in channel 25      setExtAddr upper lower  eg(in hex): setExtAddr 0xaabbccdd 0x1122334  eg(in dec): setExtAddr 2864434397 287454020    -    Set the extended Address (MAC Address) of the Zigbee device  Here 0xaabbccdd11223344 is the extended address The extended address is IEEE address purchased from IEEE and will be programmed in OTP page of module So this setExtAddr is needed only for testing purpose      setPrimaryChannelMask mask  e g : setPrimaryChannelMask 0x2108800     Set Primary channel mask  Here the primary channel mask is set to channels to 11 15 20 25      setSecondaryChannelMask mask  e g : setSecondaryChannelMask 0x2108800     Set Secondary channel mask  Here the Secondary channel mask is set to channels to 11 15 20 25      powerOff  e g : powerOff     Emulates Power off of the device by disabling RF reset command or press the reset button of the device is required to return to power on status      reset  e g : reset    Zigbee Device Initialized: Type Help for Commands    Perform HW reset for the device Upon reset the device will attempt to restore data from NVM and apply it instead of starting as factory new      resetToFN  e g : resetToFN    Zigbee Device Initialized: Type Help for Commands    Resets the device to Factory New state by deleting network and application data from NVM However this command does not reset the outgoing NWK security counter and hence device is able to join its previous network      formAndSteer  e g : formAndSteer    Nwk Formation: Success  Steering: Success  CommissioningStatus = 0    Forms a network and steers This command is same as using invokeCommissioning 6 0      formSteerAndFB  e g : formSteerAndFB    Nwk Formation: Success  Steering: Success  Device joined: Address 0x256a MACID 0x000000000000aabb ExtendedPANID 0x0000000000000bee  addGroupResponseInd()  Finding Binding: Success  CommissioningStatus = 0    forms network steers and initiate Finding Binding This command is same as using invokeCommissioning 0xE 0      SetInstallCode ext_addr_upper ext_addr_lower code  e g : SetInstallCode 0xAABBCCDD 0x11223344 B5C305D51669B239C6A52397937A40D3FE83    Status = 0    Sets the install code  Here 0xAABBCCDD 0x11223344 is the for the extended address 0xaabbccdd11223344  Here the product key is “83FE D340 7A93 9723 A5C6 39B2 6916 D505 C3B5”      SetAllowRemoteTCpolicyChange type  e g : SetAllowRemoteTCpolicyChange 1    -    Enable/Disable Trust Center policy  1 – enables Remote Tust center Policy Change  0 - 1 – disables Remote Tust center Policy Change      SetInstallCodeDevice code  e g : SetInstallCodeDevice B5C305D51669B239C6A52397937A40D3FE83    Status = 0    Sets the install code  Here the product key is “83FE D340 7A93 9723 A5C6 39B2 6916 D505 C3B5”      setAllowTLResetToFN type  e g : setAllowTLResetToFN 1    -    Set the device to allow to accept Touch Link reset to FN  1 – allow Touch Link Reset To Factory New  0 – disallow Touch Link Reset To Factory New      SetTLRole initiator  e g : SetTLRole 1    -    Sets the Touchlink role  1 – initiator  0 - target      setTCLKExchangeMethod method    -    Set Touch Link exchange method     setTCLKMaxRetryAttempts attempt    Set Touchlink Max retry attempt      setTCRequireKeyExchange require  e g : setTCRequireKeyExchange 1    -    Enable or disable Trust Center Key exchange      setGlobalKey option  e g : setGlobalKey 1    -    Set Global Link (for testing)  0 - HA Link key will be used  [0x5a 0x69 0x67 0x42 0x65 0x65 0x41 0x6c 0x6c 0x69 0x61 0x6e 0x63 0x65 0x30 0x39]  1 – [0xd0 0xd1 … 0xdf]  2 – [0xc0 0xc1 … 0xcf]  3 – [0x66 0xB6 0x90 0x09 0x81 0xE1 0xEE 0x3C 0xA4 0x20 0x6B 0x6B 0x86 0x1C 0x02 0xBB]  Here in the example setGlobalKey 1 the key used will be [0xd0 0xd1 0xd2 0xd3 0xd4 0xd5 0xd6 0xd7 0xd8 0xd9 0xdA 0xdb 0xdc 0xdd 0xde 0xdf]      setPermitJoin duration  e g : setPermitJoin 180    setPermitJoinRsp 0    Allow other devices to join the network for the specified duration (in secs)  Here the zigbee device allow other devices to join the network for a duration of 180 sec  setPermitJoinRsp 0 - indicate that a ZDO MGMT_PERMIT_JOINING_CLID packet is send      ZDO Help When zdoHelp is entered in the terminal application the device lists all the supported commands that are related to network management and information gathering           Command Syntax    Response    Description        activeEpReq DstAddr nwkAddrOfInterest  e g : activeEpReq 0x7766 0x7766     This console command requests the list of all active endpoints on a  remote device  Here the DstAddr is the short / network address of the remote device to which Active_EP_req command (ClusterID=0x0005) will be send  nwkAddrOfInterest is the short address of the remote device for which the active endpoint list is required  This activeEpReq should be a unicast to the remote device itself or to an alternative device that contains the discovery information of the remote device      bindReq addrMode DstAddr extDstAddrHigh extDstAddrLow ClusterId    BindRsp 0    This console command requests a remote node to insert an entry to its binding table  Here addrMode specifies the format of DstAddr   Refer Address Mode table for more details  DstAddr is the short address of the remote device  extDstAddrHigh  extDstAddrLow is the extended address of the destination device  ep is the destination endpoint for the binding entry  ClusterId is the cluster on the source device that is bound to the destination      bindReq2 addrMode DstAddr extSrcAddrHigh extDstAddrHigh extDstAddrLow / GroupID ep_Src ep_Dst ClusterId    BindRsp 0    This console command requests a remote node to insert an entry to its binding table  Here addrMode specifies the format of DstAddr   DstAddr is the short address of the remote device  extSrcAddrHigh  extSrcAddrLow is the extended address of the source device extDstAddrHigh  extSrcAddrLow is the extended address of the destination device  Refer Address Mode table for more details  ep_Src is the source endpoint for the binding entry  ep_Dst is the destination endpoint for the binding entry  ClusterId is the cluster on the source device that is bound to the destination      ieeeAddrReq dstAddr nwkAddOfInt reqType  e g : ieeeAddrReq 0x7011 0x7011 0     This console command requests the IEEE (extended) address of a remote node with a given short (network) address  dstAddr is the short address of the remote device to which IEEE_addr_req command (ClusterID=0x0001) will be send  nwkAddOfInt is the short address of the remote device for which the extended address (IEEE address) is required  reqType is Request type for this command  0 - SINGLE_RESPONSE_REQUESTTYPE - Only the address of the target device is requested  1 - EXTENDED_RESPONSE_REQUESTTYPE - Address of all target's child nodes (only end devices) are also requested      macBanNode extAddrHigh extAddrLow shortAddr cost rssi  e g : macBanNode 0xaabbccdd 0x11223344 0x7011 0xFF -100     This console command bans any frame from the node or correct link cost for all the frames  extAddrHigh  extAddrLow - extended address of the node affected  shortAddr - short address of the node affected If the short address of banned node is unknown then pass 0xFFFE (MAC_NO_SHORT_ADDR)  cost - link cost value for all the frames received from the node If node shall be baned - use link cost value 0xFF (LINK_COST_VALUE_NODE_BANNED)      macResetBanTable  e g : macResetBanTable    Done    This console command reset the ban table and reloads from the config server      matchDescReq nwkAddr srcEp  e g : matchDescReq 0xFFFD 0x20     This Command launches a search for devices that have endpoints supporting at least one of the specified clusters  nwkAddr : is the short / network address of the remote device to which Match_Desc_req command (ClusterID=0x0006) will be send  srcEp is the endpoint to be found  Here 0xFFFD is the broadcast address of the device which have rx on idle enabled (RX_ON_WHEN_IDLE_ADDR)      NodeDescReq dstnwkAddr nwkAddrOfInt  e g : NodeDescReq 0xb389 0xb389     This console command requests the node descriptor of a remote device (Node descriptor contains information about the capabilities of the ZigBee node)  dstnwkAddr is the short address of the remote device to which Node_Desc_req command (ClusterID=0x0001) will be send  nwkAddrOfInt is the short address of the remote device or to an alternative device for which the node descriptor is required      nwkAddrReq dstAddr ieeeAddOfIntHigh ieeeAddOfIntLow reqType  nwkAddrReq 0xb670 0xaabbccdd 0x1223344 0     This console command requests the short address (network address) of a remote node with a given Extended address (IEEE address)  dstAddr is the short address of the remote device to which NWK_addr_req command (ClusterID=0x0000) will be send  ieeeAddOfIntHigh ieeeAddOfIntLow is the extended (IEEE) address to be matched by the Remote  Device  reqType is Request type for this command  0 - SINGLE_RESPONSE_REQUESTTYPE - Only the address of the target device is requested  1 - EXTENDED_RESPONSE_REQUESTTYPE - Addresses of all target's child nodes (only end devices) are also requested      sendBeaconReq  e g : sendBeaconReq     This console command sends a beacon request All other coordinators and routers will respond with a beacon      sendMgmtBindReq address startIndex  e g : sendMgmtBindReq 0x2de0 0    MgmtBindRsp 0    This console command retrieves the content of the binding table from a remote device  address is the short address of the remote device to which Mgmt_Bind_req command (ClusterID=0x0033) will be send  startIndex is the starting Index for the requested elements of the Binding Table  Here MgmtBindRsp 0 indicate success response      sendMgmtLeaveReq dstShortAddr devExtAddrHigh devExtAddrLow rejoin removeChildren  e g : sendMgmtLeaveReq 0xd108 0xaabbccdd 0x11223344 0 1    LeaveRsp 0    This console command requests network leave either for a current device or a remote device  dstShortAddr is the short address of the remote device to which Mgmt_Leave_req command (ClusterID=0x0034) will be send  devExtAddrHigh devExtAddrLow is the extended address of the device that should leave the network  rejoin = 1: the device being asked to leave from the current parent is requested to rejoin the network  rejoin = 0: the device being asked to leave will not rejoin the network  removeChildren = 1: the device being asked to leave the network is also being asked to remove its child devices Otherwise it has a value of 0  Here LeaveRsp 0 indicate success response      sendMgmtLqiReq address startIndex  e g : sendMgmtLqiReq 0xd108 0    MgmtLqiRsp 0    This console command obtains the list of a remote device’s neighbors  along with corresponding LQI values  address : is the short address of remote device to which Mgmt_Lqi_req command (ClusterID=0x0031) will be send  startIndex : is the Starting Index for the requested elements of the Neighbor Table      sendMgmtPermitJoin dstAddr dur tcSig  e g : sendMgmtPermitJoin 0xd108 60 0    setPermitJoinRsp 0    This console command configures the target node to allow other nodes to enter the network via MAC association (joining the network for the first time) through this node  dstAddr : is the short address of remote device to which Mgmt_Permit_Joining_req command (ClusterID=0x0036) will be send  dur : is time span in seconds during which the ZigBee coordinator or router will allow associations The value 0x00 or 0xff indicate that permission is disabled or enabled permanently respectively  tcSig = 1: indicating a request to change the Trust Center policy      sendNwkMgmtUpdateReq channel scanDuration nwkAddr  e g : sendNwkMgmtUpdateReq 20 0xfe 0xd108    Update Done    This console command sends a remote device about the update of network configuration parameters such as channel Scan duration network address etc  Channel : indicate which channels are to be scanned  scanDuration = 0 to 5: (ZDO_MGMT_ED_SCAN_DUR_0 to ZDO_MGMT_ED_SCAN_DUR_5)request to perform an ED scan with duration depending exponentially on the parameter value  scanDuration = 0xFE: request to change the working channel  scanDuration = 0xFF: request to change the device scanChannels and nwkManagerAddr values to those contained in the request  nwkAddr : is the short address of remote device to which Mgmt_NWK_Update_req command (ClusterID=0x0038) will be send  The example shows the sendNwkMgmtUpdateReq command which request remote device 0xd108 to change the channel      simpleDescReq nwkAddr dstEp  e g : simpleDescReq 0xb670 0x23     This console command requests the simple descriptor of the specified endpoint on a remote node The simple descriptor contains information specific to each endpoint contained in that node  nwkAddr : is the short address of remote device to which Simple_Desc_req (ClusterID=0x0004) will be send  dstEp: The endpoint on the destination      unbindReq addrMode DstAddr extDstAddrHigh extDstAddrLow ep ClusterId    UnBindRsp 0    Requests a remote node to remove an entry from its binding table with the specified сlusterID source and destination endpoint and extended address  Here addrMode specifies the format of DstAddr   Refer Address Mode table for more details  DstAddr : is the short address of the remote device  extDstAddrHigh  extDstAddrLow : is the extended address of the destination device  ep : is the destination endpoint for the binding entry  ClusterId : is the cluster on the source device that is bound to the destination      unbindReq2 addrMode DstAddr extSrcAddrHigh extDstAddrHigh extDstAddrLow / GroupID ep_Src ep_Dst ClusterId    UnBindRsp 0    Requests a remote node to remove an entry from its binding table with the specified сlusterID source and destination endpoint and extended address  Here addrMode specifies the format of DstAddr Refer Address Mode table for more details  DstAddr : is the short address of the remote device  extSrcAddrHigh  extSrcAddrLow : is the extended address of the source device  extDstAddrHigh  extDstAddrLow : is the extended address of the destination device  ep_Src : is the source endpoint for the binding entry  ep_Dst : is the destination endpoint for the binding entry  ClusterId : is the cluster on the source device that is bound to the destination       ZCL Help ZCL Help command lists the supported commands related to ZCL functionality As the clusters and attributes are specific to device type the list of commands also dependent on the device type of the project   General        Command Syntax    Description       readAttribute addrMode addr ep clusterId attId   Read value of specified attribute on specified cluster from remote device     writeAttribute addrMode addr ep ClusterId attrId type attrValue1 attrSize   Sends Write Attribute command for specified attribute and cluster     configureReporting addrMode addr ep min max   Configure reporting of the occupancy sensor with min and max values     configureReportingWRC addrMode addr ep ClusterId attrId type min max repChange   Configure reporting of the occupancy sensor with min and max values     resetToFactoryDefaults addrMode addr ep   reset all clusters to factory defaults         Supported Commands in Device Types which has Identify Basic and Group Cluster supported: All Devices        Command Syntax    Description       setTargetType type addr ep   Set as target(1)/initiator(0)     getGroupMembership addrMode addr ep count groupId1 groupId2 groupId3 groupId4 groupId5   Sends the Get Group Membership command (count)specifies how many group IDs following it should be considered but five values must be provided as group IDs always     identify addrMode addr ep idTime(secs)   Sends the Identify command to the specified node(s)     identifyQuery addrMode addr ep   Sends the Identify Query command     triggerEffect addrMode addr ep eftId eftVar   Sends trigger effect command     addGroup addrMode addr ep group   Sends the Addr Group command to the specified node(s)     addGroupIfIdentifying addrMode addr ep groupId   Sends the Addr Group If Identifying command(s)     removeGroup addrMode addr ep group   Sends the Remove Group command to the specified node(s)     viewGroup addrMode addr ep group   Sends the View Group command t     resetTargetToFN   reset the target to factory new        \"Lights\" Specific Commands   The device implements light specific client clusters supports below commands: Combined Interface Color Scene Controller         Command Syntax    Description       addScene addrMode addr ep groupId sceneId transitionTime onOff level   Sends the Add Scene command     viewScene addrMode addr ep groupId sceneId   Sends the View Scene command     removeScene addrMode addr ep groupId sceneId   Sends the Remove Scene command     removeAllScene addrMode addr ep groupId   Sends the Remove All Scene command     storeScene addrMode addr ep groupId sceneId   Sends the Store Scene command     recallScene addrMode addr ep groupId sceneId   Sends the Recall Scene command     addSceneToDL addrMode addr ep groupId sceneId transitionTime onOff level   Sends the Store Scene command     getSceneMembership addrMode addr ep groupId   Sends the Get Scene Membership command     onOff addrMode addr ep \"-on\"/\"-off\"   Turn the specified light device(s) on or off     offWithEffect addrMode addr ep effectId effectVariant   Sends off with effect command     onWithRecallGlobalScene addrMode addr ep   Sends on the Recall Global scene command     onWithTimedOff addrMode addr ep onOffCtrl onTime offWaitTime   Sends on with timed off     moveToLevel addrMode addr ep level transitionTime onOff optMask optOvrd   Send the Move to level (with On/Off) command     move addrMode addr ep rate onOff   Send the Move (with On/Off) command     step addrMode addr ep mode stepSize transitionTime onOff   Send the Step (with On/Off) command     stop addrMode addr ep onOff   Send the Stop (with On/Off) command        IAS ACE        Command Syntax    Description        IASACEArmCommand addrMode addr ep ArmMode Arm/Code Zone/Id    Sends IAS ACE Arm command to the CI(CIE) along with Arm mode with its code to the zoneId      IASACEBypassCommand addrMode addr ep zone_numbers zone_id1 zone_id2 zone_id3 arm_code_code    Sends IAS ACE Bypass command with the listof zoneIds along with the code to the CI (CIE)      IASACEEmergencyCommand addrMode addr ep    Sends IAS ACE Emergency command to the CI (CIE)      IASACEFireCommand addrMode addr ep    Sends IAS ACE Fire command to the CI (CIE)      IASACEPanicCommand addrMode addr ep    Sends IAS ACE Panic command to the CI (CIE)      IASACEGetZoneIdMapCommand addrMode addr ep    Sends IAS ACE Get Zone Id Map command to the CI (CIE)      IASACEGetZoneIdInformationCommand addrMode addr ep zone_id    Sends IAS ACE Get Zone Information Command to get the complete information of the zoneId      IASACEGetPanelStatusCommand addrMode addr ep    Sends IAS ACE Get Panel Status command to the CI(CIE) to get the Panel's status      IASACEGetZoneStatusCommand addrMode addr ep starting_zone_id max_number_zoneids zonestatus_maskflag zonestatus_mask    Sends IAS ACE Get Zone Status Command to get the Zone status The command would list the starting zoneId with the maximum number to read from there      ZoneEnrollReqCmd addrMode addr ep zone_type manuf_code    Sends IAS Zone Enroll Request Command to the CI (CIE) as part of Zone Enrollment      ZoneStatusChangeNotifiCmd addrMode addr ep zonestatus ext_status    Sends IAS Zone Status Change a notification to the CI(CIE)      ZoneStatusChange Device_Spec_Bits    To change the internal zone status to trigger a change notification to the CI(CIE)      GetByPassZoneList addrMode addr ep    Sends IAS ACE GetByPassZone list which were already bypassed and part of the bypass table        Thermostat        Command Syntax    Description        setOccupancy 0- UnOccupied/ 1- Occupied    Sets the Occupancy State either to Occupied / Unoccupied      clusterAttrInitDefault ClusterID    Inititalizes all Attributes to default value      setOccupancyState state    Sets the Occupancy state to either Occupied or Unoccupied      setOccupancySensorType sensorType    Sets the Occupancy Sensor Type      triggerAlarm ClusterId alarmCode Raise/Clear    Triggers Alarm either to Raise / Clear with the Alarm Code      setAlarmMask ClusterId alarmMask    Sets the Alarmmask      resetAlarms    Resets the alarm          Additional Commands Supported by the Coordinator/Combined Interface Device        Command Syntax    Description       readReporting addrMode addr ep clusterId attrId   Read reporting from specified cluster server      thermSetPointChange addrMode addr ep setPtmode amount    Sends thermostat Set Point Change Command along with the mode and amount      setUTCTime dd:mm:yr:hr:min:sec    Sets the UTC time      readTime    Reads the current time      setTimeZoneAndDST timeZone dstStart dstEnd dstShift    Sets the time zone and DST     setTimeStatus addrMode addr ep ClusterId alarmCode   Sets the time status of the device     resetAlarm addrMode addr ep ClusterId alarmCode   resets the alarm with its code      alarmCmd addrMode addr ep resetAllAlarm/getAlarm/resetAlarmLog    Alarm Command which could be resetAllAlarm/getAlarm/resetAlarmLog     IasAceGetPanelStatusChangedCommand addrMode addr ep panel_status seconds_remaining audible_noti alarmStatus   Sends Panel Status Changed Command to the Ace device with its status and seconds remaining for the change with actions to be taken w r t alarmstatus and its audible notification     IasAceZoneStatusChangedCommand addrMode addr ep zoneId zone_status audible zone_label   Sends Zone status Changed command to the Ace device with its status along with audible details and zone label     ZoneInitiateNormalOperatingModeCommand addrMode addr ep   Sends to initiate Normal Operating mode at the Ace device     ZoneInitiateTestModeCommand addrMode addr ep Test_Mode_Duration Current Zone Sensitiivity Level   Sends to initiate Test operating Mode at the Ace device with its duration for the same with its current zone sensitivity level               Command Syntax    Response    Description        readAttribute addrMode addr ep clusterId attrId  e g : readAttribute -s 0x24b8 0x23 0x0006 0x0000    Attribute operation response received: status = 0x00  -Read attribute (AttrId:0x0) response: success Attr value = 0    This console command read value of specified attribute on specified cluster from remote device using  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device for which the read attribute zcl command (ZCL_READ_ATTRIBUTES_COMMAND_ID) to be send  ep : The endpoint on the remote device that is to be read  clusterId : Unsigned 16-bit Cluster identifier whose attribute need to be read  attrId : Attribute ID of the Attribute that need to be read  Here in example command -s indicate that address mode is short address 0x24b8 is the short address of the remote device 0x23 is endpoint of the remote device i e extend color light 0x0006 is the OnOff ClusterID and 0x00 is the attributeID for OnOff attribute      writeAttribute addrMode addr ep clusterId attrId type attrValue1 2 attrSize  e g : writeAttribute -s 0x24b8 0x23 0x0006 0x4001 0x21 0x01 0x02    Attribute operation response received: status = 0x00  -Write attribute response: success    This console command sends Write Attribute command for specified attribute and cluster to a remote device  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device for which the writes attribute zcl command to be send (ZCL_WRITE_ATTRIBUTES_COMMAND_ID)  ep : The endpoint on the remote device that is to be written  clusterId : Unsigned 16-bit Cluster identifier whose attribute need to be written  attrId : Attribute ID of the Attribute that need to be written  type : Attribute Type  attrValue : attribute value that need to be written  attrSize : Size of the attribute data  Here in example command -s indicate that address mode is short address 0x24b8 is the short address of the remote device 0x23 is endpoint of the remote device i e extend color light 0x0006 is the OnOff ClusterID and 0x4001 is the attributeID for OnTime attribute 0x21 is the attribute type (ZCL_U16BIT_DATA_TYPE_ID refer ZCL_AttributeType_t in zigbee application for details)  0x01 is the attribute value and 0x02 is the size of attribute data      writeAttributeNoResp addrMode addr ep clusterId attrId type attrValue1 2 attrSize  e g : writeAttributeNoResp -s 0x24b8 0x23 0x0006 0x4001 0x21 0x01 0x02    No Response    This console command sends Write Attribute command for specified attribute and cluster to a remote device and specifies the remote devices not to send a response  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device for which the write attribute no response zcl command to be send (ZCL_WRITE_ATTRIBUTES_NO_RESPONSE_COMMAND_ID)  ep : The endpoint on the remote device that is to be written  clusterId : Unsigned 16-bit Cluster identifier whose attribute need to be written  attrId : Attribute ID of the Attribute that need to be written  type : Attribute Type  attrValue : attribute value that need to be written  attrSize : Size of the attribute data  Here in example command -s indicate that address mode is short address 0x24b8 is the short address of the remote device 0x23 is endpoint of the remote device i e extend color light 0x0006 is the OnOff ClusterID and 0x4001 is the attributeID for OnTime attribute 0x21 is the attribute type (ZCL_U16BIT_DATA_TYPE_ID refer ZCL_AttributeType_t in zigbee application for details)  0x01 is the attribute value and 0x02 is the size of attribute data      configureReporting addrMode addr ep clusterId attrId type min max  eg: configureReporting -s 0x1593 0x23 0x0006 0x00 0x10 0x01 0x02    Attribute operation response received: status = 0x00    This console command is used to change the reporting timeout on the remote device  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device for which the configure reporting zcl command to be send (ZCL_CONFIGURE_REPORTING_COMMAND_ID)  ep : The endpoint on the remote device that is to be written  clusterId : Unsigned 16-bit Cluster identifier whose attribute need to be configured  attrId : Attribute ID of the Attribute that need to be configured  type : Attribute Type  min : the minimum reporting interval in seconds between issuing reports of the specified attribute  max : the maximum reporting interval in seconds between issuing reports of the specified attribute  The min and max reporting interval field is 16 bits (Unsigned) in length  Here in example command -s indicate that address mode is short address* 0x1593* is the short address of the remote device 0x23 is endpoint of the remote device i e extend color light 0x0006 is the OnOff ClusterID and 0x00 is the attributeID for OnOff attribute 0x10 is the attribute type (ZCL_BOOLEAN_DATA_TYPE_ID refer ZCL_AttributeType_t in zigbee application for details) 1 in the min reporting interval (1 sec) 2 in the min reporting interval (2 sec)      configureReportingWRC addrMode addr ep clusterId attrId type min max repChange  eg: configureReportingWRC -s 0x1593 0x23 0x0006 0x00 0x10 0x01 0x02 0x00    Attribute operation response received: status = 0x00    This console command Sends configure reporting with reportable Change to specified cluster server  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device for which the configure reporting zcl command to be send (ZCL_CONFIGURE_REPORTING_COMMAND_ID)  ep : The endpoint on the remote device that is to be written  clusterId : Unsigned 16-bit Cluster identifier whose attribute need to be configured  attrId : Attribute ID of the Attribute that need to be configured  type : Attribute Type  min : the minimum reporting interval in seconds between issuing reports of the specified attribute  max : the maximum reporting interval in seconds between issuing reports of the specified attribute  The min and max reporting interval field is 16 bits in length  Here in example command -s indicate that address mode is short address* 0x1593* is the short address of the remote device 0x23 is endpoint of the remote device i e extend color light 0x0006 is the OnOff ClusterID and 0x00 is the attributeID for OnOff attribute 0x10 is the attribute type (ZCL_BOOLEAN_DATA_TYPE_ID refer ZCL_AttributeType_t in zigbee application for details) 1 in the min reporting interval (1 sec) 2 in the min reporting interval (2 sec)      readReporting addrMode addr ep clusterId attrId  eg: readReporting -s 0x1593 0x23 0x0006 0x00    Attribute operation response received: status = 0x00  -Read Reporting Attribute (0x0) response: success  min = 1 max = 2 direction = 0 attributeType = 16 reportableChange = 0    This console command read reporting configuration from specified cluster server  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device for which the read reporting zcl command to be send (ZCL_READ_REPORTING_CONFIGURATION_COMMAND_ID)  ep : The endpoint on the remote device of which reporting configuration need to be read  clusterId : Unsigned 16-bit Cluster identifier whose attribute need to be configured  attrId : Attribute ID of the Attribute that need to be configured  Here in example command -s indicate that address mode is short address* 0x1593* is the short address of the remote device 0x23 is endpoint of the remote device i e extend color light 0x0006 is the OnOff ClusterID and 0x00 is the attributeID for OnOff attribute      addGroup addrMode addr ep gid  e g : addGroup -s 0x1593 0x23 0x1234    addGroupResponseInd()    This console command sends zcl Add Group command to remote device which allows the sending device to add group membership in a particular group for one or more endpoints on the receiving device  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device to which addgroup zcl command to be send  ep : The endpoint on the remote device that needs to be added in the group  gid : Unsigned 16-bit identifier for a group  Here in example command -s indicate that address mode is short address* 0x1593* is the short address of the remote device 0x23 is endpoint of the remote device 0x1234 is theGroupID This command will create/add device 0x1593 into Group 0x1234 The device can be controlled using GroupID also e g : onOff -g 0x1234 0x23 -toggle       addGroupIfIdentifying addrMode addr ep gid  e g : addGroupIfIdentifying -s 0x1593 0x23 0xabcd    No Response    This console command sends the Add Group If Identifying zcl command to remote device which allows the sending device to add group membership in a particular group for one or more endpoints on the receiving device on condition that it is identifying itself Identifying functionality is controlled using the identify cluster  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device to which addgroup zcl command to be send  ep : The endpoint on the remote device that needs to be added in the group  gid : Unsigned 16-bit identifier for a group  Here in example command -s indicate that address mode is short address* 0x1593* is the short address of the remote device 0x23 is endpoint of the remote device 0xabcd is theGroupID      getGroupMembership addrMode addr ep count groupId1 groupId2 groupId3 groupId4 groupId5  e g : getGroupMembership -s 0x1593 0x23 1 0x1234 0 0 0 0    getGroupMembershipResponse()  groupCount = 1  groupId = 0x1234    This console command sends the Get Group Membership zcl command to remote device which allows the sending device to inquire about the group membership of the receiving device  specifies how many  group IDs following it should be  considered but five values must be  provided as group IDs always  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device to which get group membership zcl command to be send  ep : The endpoint on the remote device  count : specifies how many group IDs following it should be considered but five values must be  provided as group IDs always  groupId1 to groupId5 : Unsigned 16-bit identifier for a group  Here in example command -s indicate that address mode is short address* 0x1593* is the short address of the remote device 0x23 is endpoint of the remote device 1 is count 0x1234 0 0 0 0are the GroupID’s      removeAllGroups addrMode addr ep  e g : removeAllGroups -s 0x1593 0x23    No Response    This command sends Remove All Group zcl command to remote device which allows the sending device to direct the receiving device to remove all group associations  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device to which get remove all group zcl command to be send  ep : The endpoint on the remote device  Here in example command -s indicate that address mode is short address* 0x1593* is the short address of the remote device 0x23 is endpoint of the remote device      removeGroup addrMode addr ep gid  e g : removeGroup -s 0x1593 0x23 0x1234    removeGroupResponseInd(): groupId = 0x1234    This command sends remove group zcl command to remote device which allows the sender to request the receiving device to remove the membership from the specified group  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device to which get remove group zcl command to be send  ep : The endpoint on the remote device  gid : Unsigned 16-bit identifier for a group  Here in example command -s indicate that address mode is short address* 0x1593* is the short address of the remote device 0x23 is endpoint of the remote device 0x1234 is theGroupID      viewGroup addrMode addr ep gid  e g : viewGroup -s 0x1593 0x23 0x1234    viewGroupResponse(): status = 0x00 groupId = 0x1234    This command sends view group zcl command to remote device which allow the sending device to request that the receiving device to respond  with a view group response command containing the information of the requested GroupID  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device to which get view group zcl command to be send  ep : The endpoint on the remote device  gid : Unsigned 16-bit identifier for a group  Here in example command -s indicate that address mode is short address* 0x1593* is the short address of the remote device 0x23 is endpoint of the remote device 0x1234 is theGroupID      resetTargetToFN  e g : resetTargetToFN    Status = 1    Reset the Touchlink target to factory new      setTargetType type  e g : setTargetType 1    Done    This console commands set touchlink device type as target / initiator  1 – target  0 – initiator      SetbdbJoinUsesInstallCodeKey value  e g : SetbdbJoinUsesInstallCodeKey 1    No Response    This console command sets the install code usage at the trust center  1 - TC will allow only install code devices to join  0 – otherwise      resetToFactoryDefaults addrMode addr ep  e g : resetToFactoryDefaults -s 0xcbb4 0x23    No Response    This console command reset all cluster attributes to factory defaults      disableDefaultResp value  e g : disableDefaultResp 1    No Response    This console command Disable/Enable default response for ZCL command  0 – enable  1 –disable      addSceneToDL addrMode addr ep groupId sceneId transitionTime onOff level  e g : addSceneToDL -s 0x8d7f 0x23 0x1234 0x10 60 1 0xff    Add scene response: status = 0x00  groupId = 0x1234  sceneId = 0x11    This console command sends scene zcl command to dimmable light device which allow the sending device to request that the dimmable light device to add an entry in its Scene Table with the given sceneID  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  groupId : Unsigned 16-bit identifier for a group  sceneId : 8-bit unique identifier within group groupId which is used to identify this scene  transitionTime : Unsigned 16-bit time value which will take for the device to change from its current state to the requested state  onOff : 1-bit onOff value 1 or 0  level : 8-bit light brightness level (0 - 0xff where 0xff is max brightness)  Here in example command -s indicate that address mode is short address* 0x1593* is the short address of the remote device 0x23 is endpoint of the remote device 0x1234 is theGroupID 0x10 is the sceneID 60 is the transitionTime 1 is the onOff value and 0xff is the light level  Note: Ensure that a group with ID 0x1234 is created before executing this command (eg: addGroup -s 0x8d7f 0x23 0x1234 )      addSceneToTH addrMode addr ep groupId sceneId transitionTime occupiedCoolingSetpoint occupiedHeatingSetpoint systemMode    No Response    This console command sends Add Scene zcl command to Thermostat device to add an entry in its Scene Table with the given sceneID  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  groupId : Unsigned 16-bit identifier for a group  sceneId : 8-bit unique identifier within group groupId which is used to identify this scene  transitionTime : Unsigned 16-bit time value which will take for the device to change from its current state to the requested state  occupiedCoolingSetpoint : signed 16-bit Occupied Cooling Setpoint Attribute specifies the cooling mode setpoint when the room is occupied  occupiedHeatingSetpoint : signed 16-bit occupied Heating Setpoint Attribute specifies the heating mode setpoint when the room is occupied  systemMode : (Unsigned 8-bit) System Mode attribute specifies the current operating mode of the thermostat  Note: Ensure that a group is created before executing this command (using addGroup console command)      getSceneMembership addrMode addr ep groupId  e g : getSceneMembership -s 0x8d7f 0x23 0x123    Note: No Response    This console command sends Get Scene Membership zcl command to remote device The Get Scene Membership command can be used to find an unused scene number within the group  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  groupId : Unsigned 16-bit identifier for a group  Here in example command -s indicate that address mode is short address* 0x1593* is the short address of the remote device 0x23 is endpoint of the remote device 0x1234 is theGroupID      move addrMode addr ep mode rate onOff optMask optOvrd  e g Down: move -s 0x3bb6 0x23 1 0x7f 0 0 0  e g Up: move -s 0x3bb6 0x23 0 0x7f 1 0 0    Observe the change in LED level in light (dimmable) device    This console command sends Move zcl command to remote light device  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  mode : move up or down  0x00 – Up  0x01 – Down  rate : specifies the rate of movement in units per second  onOff : 1-bit onOff value 1 - On or 0 - Off  optMask : options mask  optOvrd : options override  Here in first example command -s indicate that address mode is short address* * 0x3bb6* is the short address of the remote device 0x23 is endpoint of the remote device 1 is the down mode 0x7f is the rate 1 indicates on/off and 0 0 are options mask and options override      moveToLevel addrMode addr ep level transitionTime onOff optMask optOvrd  e g : moveToLevel -s 0xe015 0x23 0x7f 0x000c 1 0 0    Observe the change in LED level in light (dimmable) device    This console command sends Move to level zcl command to remote device which request the remote light (dimmable) to move from its current level to the given level  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  level : unsigned 8-bit value which holds brightness level of the light(dimmable) device  transitionTime : unsigned 16-bit value which specifies time taken to move to the new level  onOff : 1-bit onOff value 1 - On or 0 - Off  optMask : options mask  optOvrd : options override  Here in example command -s indicate that address mode is short address 0xe015 is the short address of the remote device 0x23 is endpoint of the remote device 0x7f is the new brightness level for the light (dimmable) 0x000c is the transition time 1 indicates on/off and 0 0 are options mask and options override      offWithEffect addrMode addr ep effectId effectVariant  e g: offWithEffect -s 0xe015 0x23 0x01 0x00   Observe the change in LED level in light (dimmable) device   This console command sends Off With Effect zcl command to remote light device request the devices to be turned off using enhanced ways of fading  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  effectId : unsigned 8-bits in length and specifies the fading effect to use when switching the device off  0 - Delayed All Off  1 - Dying Light  effectVariant : unsigned 8-bits in length and is used to indicate which variant of the effect           effectID    effectVariant    Description      0x00    0x00    Fade to off in 0 8 Secs      0x00    0x01   No fade     0x00    0x02   50% dim down in 0 8 seconds then fade to off in 12 secs     0x01    0x00   20% dim up in 0 5s then fade to off in 1 sec       Here in example command -s indicate that address mode is short address 0xe015 is the short address of the remote device 0x23 is endpoint of the remote device 0x01 is the effectId      onWithRecallGlobalScene addrMode addr ep  e g : onWithRecallGlobalScene -s 0xbaf4 0x23   Observe the change in LED level in light (dimmable) device   This console command sends on with Recall Global sceneI zcl command to remote device which request remote device to recall the settings when the device was turned off  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  Here in example command -s indicate that address mode is short address 0xbaf4 is the short address of the remote device 0x23 is endpoint of the remote device      onWithTimedOff addrMode mode ep onOffCtrl onTime offWaitTime  e g : onWithTimedOff -s 0xbaf4 0x23 0 300 0   Observe the light get turned on immediately and turns off after 30 sec   This console command sends on with Timed Off scene zcl command which request the remote devices to be turned on for a specific duration (as specified in onTime duration) with a guarded off duration (offWaitTime)  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  onOffCtrl : Control field specifies whether the On with Timed Off command is to be processed unconditionally or only when the OnOff attribute is equal to 0x01  0 - command shall be processed unconditionally  1 – command shall accepted if the OnOff attribute is equal to 0x01  onTime : unsigned 16-bit value which specifies the length of time (in 1/10ths second) that the device is to remain “on”  offWaitTime : duration prevent turning back on the device for On with Timed Off commands received during this time  Here in example command -s indicate that address mode is short address 0xbaf4 is the short address of the remote device 0x23 is endpoint of the remote device 0 is onOffCtrl which means On with Timed Off command is processed unconditionally 300 is onTime of 30 seconds and 0 is the offWaitTime      recallScene addrMode addr ep groupId sceneId transitionTime  e g : recallScene -s 0xbaf4 0x23 0x1234 0x10 3     This console command sends recall scene zcl command which request the remote devices to locate the entry in its Scene Table with the Group ID and Scene ID and then set the corresponding scene  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  groupId : Unsigned 16-bit identifier for a group  sceneId : 8-bit unique identifier within group groupId which is used to identify this scene  transitionTime : Unsigned 16-bit time value which will take for the device to change from its current state to the requested state  Here in example command -s indicate that address mode is short address 0xbaf4* is the short address of the remote device 0x23 is endpoint of the remote device 0x1234 is the GroupID 0x10 is the sceneID and 3 is the transition time      removeAllScenes addrMode addr ep groupId  e g : removeAllScenes -s 0x666e 0x23 0x1234    Remove all scenes response: status = 0x00  groupId = 0x1234    This console command sends remove all scene zcl command which request the remote devices to remove from its Scene Table all entries with this Group ID  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  groupId : Unsigned 16-bit identifier for a group  Here in example command -s indicate that address mode is short address 0x666e is the short address of the remote device 0x23 is endpoint of the remote device 0x1234 is the GroupID      removeScene addrMode addr ep groupId sceneId  eg: removeScene -s 0x666e 0x23 0x1234 0x10    Remove scene response: status = 0x00  groupId = 0x1234  sceneId = 0x10    This console command sends remove scene zcl command which request the remote devices to remove from its Scene Table the entry with this  Scene ID and group ID  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  groupId : Unsigned 16-bit identifier for a group  sceneId : unsigned 8-bit unique identifier within group  Here in example command -s indicate that address mode is short address 0x666e is the short address of the remote device 0x23 is endpoint of the remote device 0x1234 is the GroupID 0x10 is the sceneID      step addrMode addr ep mode stepSize transitionTime onOff optMask optOvrd  e g : step -s 0x6776 0x23 0x00 0x0f 300 1 0 0   Observe the change in brightness of the light   This console command sends step zcl command which request the remote devices to move from its current level in an up or down direction ( mode ) in stepSize Each step command will increment / decrement brightness of the light device till reaches the maximum / minimum level allowed for the device  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  mode : move up or down  0x00 – Up  0x01 – Down  stepSize : unsigned 8-bit value stepsize is a change in the CurrentLevel by step size value  transitionTime : Unsigned 16-bit time value in tenths of a second which will take for the device to change from its current state to the requested state  onOff : 1-bit onOff value 1 or 0  optMask : options mask  optOvrd : options override  Here in example command -s indicate that address mode is short address 0x6776 is the short address of the remote device 0x23 is endpoint of the remote device 0x00 indicates up mode 0x0f is the stepsize the brightness of the light will increase by 15(0x0f) units 300 is the transition time 1 is the onOff value 0 0 is the options mask and options override value      stop addrMode addr ep onOff optMask optOvrd  e g : stop -s 0x6776 0x23 0 0 0     This console command sends stop zcl command which request the remote devices to terminate any Move to Level Move or Step command  (and their 'with On/Off' variants) currently in process  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  mode : move up or down  onOff : 1-bit onOff value 1 or 0  optMask : options mask  optOvrd : options override      storeScene addrMode addr ep groupId sceneId  e g : storeScene -s 0x6776 0x23 0x1234 0x10    Store scene response: status = 0x00  groupId = 0x1234  sceneId = 0x10    This console command sends store scene zcl command which request the remote devices to add an entry in the Scene Table with the SceneID and Group ID given in the command and all extension field sets corresponding to the current state of other clusters on the device  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  groupId : Unsigned 16-bit identifier for a group  sceneId : unsigned 8-bit unique identifier within group  Here in example command -s indicate that address mode is short address 0x6776 is the short address of the remote device 0x23 is endpoint of the remote device 0x1234 is the GroupID 0x10 is the sceneID      triggerEffect addrMode addr ep effectId effectVariant  e g: triggerEffect -s 0x6776 0x23 0x01 0   Observe the change in Light device   This console command sends trigger effect zcl command to remote device which allows the support of feedback to the user such as a certain light effect It is used to allow an implementation to provide visual feedback to the user under certain circumstances such as a color light turning green when it has successfully connected to a network  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  effectId : 8-bits in length and specifies the identify effect to use  effectVariant : 8-bits in length and is used to indicate which variant of the effect indicated in the effect identifier field           Effect Identifier    Effect    Description      0x00    link   Light is turned on/off once     0x01    Breathe   Light turned on/off over 1 second and repeated 15 times     0x02    Okay   Colored light turns green for 1 second; noncolored light flashes twice     0x0b    Channel Change    Colored light turns orange for 8 seconds  noncolored light switches to maximum brightness for 0 5s and then minimum brightness for 7 5s      0xfe    Finish Effect   Complete the current effect sequence before terminating     0xff    Stop Effect    Terminate the effect as soon as possible        Here in example command -s indicate that address mode is short address 0x6776 is the short address of the remote device 0x23 is endpoint of the remote device 1 is the Breath effectId and 0 is the effectVariant      viewScene addrMode addr ep groupId sceneId  e g : viewScene -s 0x6776 0x23 0x1234 0x10    View scene response: status = 0x00  groupId = 0x1234  sceneId = 0x10  transitionTime = 0x0000    This console command sends view scene zcl command to remote device On receipt of this command the remote device checks for the entry in scene table for specified sceneID and responds the scene information  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  groupId : Unsigned 16-bit identifier for a group  sceneId : unsigned 8-bit unique identifier within group  Here in example command -s indicate that address mode is short address 0x6776 is the short address of the remote device 0x23 is endpoint of the remote device 0x1234 is the GroupID 0x10 is the sceneID      onOff addrMode addr ep onOff_ID  e g : onOff -s 0x6776 0x23 -toggle   Observe the light The light gets toggled (on or off)   This console command sends on off or toggle zcl command which request the remote devices to turn off or turn on or toggle the light  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  onOff_ID : hold on off or toggle parameter  -on : Turns on the light  -off : Turns off the light  -toggle: Toggle the light  Here in example command -s indicate that address mode is short address 0x6776 is the short address of the remote device 0x23 is endpoint of the remote device ‘*-toggle*’ toggles the current state of the light      identify addrMode addr ep idTime  e g : identify -s 0x6776 0x23 10   Observe the light The light flashes for 10 seconds   This console command sends identify zcl command to remote devices which request to the remote to start / stop identifying procedure The identifying procedure consists of flashing a light with a period of 0 5 seconds which helps an observer to identify the device from several devices  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  idTime : specifies identification duration (in seconds) which device continues to identify  Here in example command -s indicate that address mode is short address 0x6776 is the short address of the remote device 0x23 is endpoint of the remote device 10 is the identify time in seconds      identifyQuery addrMode addr ep  e g : identifyQuery -s 0x6776 0x23     This console command sends identify query zcl command to remote devices which allows the sending device to request the target or targets to respond if they are currently identifying themselves  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device      moveToHue addrMode addr ep hue direction transitTime optMask optOvrd  e g : moveToHue -s 0x6776 0x23 0x5A 1 50 0 0     This console command sends move to hue zcl command to remote devices which request the remote device to move its current hue to the value given in the Hue field  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  hue : unsigned 8-bit hue value of light ranges from 0 - 254  direction : direction of the hue movement          Direction    Description      0x00    Shortest Distance      0x01    Longest Distance      0x02    Up      0x03    Down        transitTime : Unsigned 16-bit time value which will take for the device to change from its current hue to the requested hue (1/10ths of a second)  optMask : options mask  optOvrd : options override  Here in example command -s indicate that address mode is short address 0x6776 is the short address of the remote device 0x23 is endpoint of the remote device 0x5A is new hue value 1 is the direction to hue to fade (longest distance) 50 is the transition time i e seconds 0 0 is the options mask and options override value      moveHue addrMode addr ep moveMode rate optMask optOvrd   e g : moveHue -s 0x6776 0x23 1 5 0 0   Observe change in light color continuously   This console command sends move hue zcl command to remote devices which request the remote device to move its current hue in an up or down direction in a continuous fashion  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  moveMode : up or down direction of hue attribute          Move Mode    Description      0x00    Stop      0x01    Up      0x02    Reserved      0x03    Down        rate : rate of movement of hue in steps per second  optMask : options mask  optOvrd : options override  Here in example command -s indicate that address mode is short address 0x6776 is the short address of the remote device 0x23 is endpoint of the remote device 1 is the moveMode for moving the hue attribute in up direction 5 is the rate of change of hue in seconds 0 0 is the options mask and options override value       stepHue addrMode addr ep stepMode stepSize transitTime optMask optOvrd   e g : stepHue -s 0x6776 0x23 1 0x1f 10 0 0   Observe change in light color   This console command sends step Hue zcl command which request the remote devices to move from its current hue (color) in an up or down direction (mode) in stepSize Each step command will increment / decrement hue of the light device till reaches the maximum / minimum hue value allowed for the device  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  stepMode: move up or down  0x01 – Up  0x03 – Down  stepSize : unsigned 8-bit value stepsize is a change in the CurrentHue by step size value  transitTime : Unsigned 8-bit time value in tenths of a second which will take for the device to change from its current state to the requested state  optMask : options mask  optOvrd : options override  Here in example command -s indicate that address mode is short address 0x6776 is the short address of the remote device 0x23 is endpoint of the remote device 1 is the Up direction 0x1f (31) is the step size 10 is the transition time 0 0 is the options mask and options override value      moveToSaturation addrMode addr ep saturation transitTime optMask optOvrd  e g : moveToSaturation -s 0x1984 0x23 0xef 10 0 0    Observe change in light saturation   This console command sends move to saturation zcl command which request the remote devices to move from its current saturation to the value given in the Saturation field  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  saturation : unsigned 8-bit saturation value of light which ranges from range 0 to 254  transitTime : Unsigned 16-bit time value which will take for the device to change from its current saturation to the requested saturation (1/10ths of a second)  optMask : options mask  optOvrd : options override  Here in example command -s indicate that address mode is short address 0x1984 is the short address of the remote device 0x23 is endpoint of the remote device 0xef is new hue value 10 is the transition time 0 0 is the options mask and options override value      moveSaturation addrMode addr ep moveMode rate optMask optOvrd  eg : moveSaturation -s 0x1984 0x23 1 0x05 0 0   Observe change in light saturation   This console command sends move saturation zcl command to remote devices which request the remote device to move its current saturation in an up or down direction in a continuous fashion  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  moveMode : up or down direction of hue attribute          Move Mode    Description      0x00    Stop      0x01    Up      0x02    Reserved      0x03    Down        rate : unsigned 8-bit rate of movement of hue in steps per second  optMask : options mask  optOvrd : options override  Here in example command -s indicate that address mode is short address 0x1984 is the short address of the remote device 0x23 is endpoint of the remote device 1 is the Up moveMode for moving the saturation in up direction 0x05 is the rate of change of hue in seconds 0 0 is the options mask and options override value      stepSaturation addrMode addr ep stepMode stepSize transitTime optMask optOvrd  e g : stepSaturation -s 0x1984 0x23 1 0x1f 10 0 0   Observe change in light saturation   This console command sends step Saturation zcl command which requests the remote devices to move from its current saturation in an up or down direction (mode) in stepSize Each step command will increment / decrement saturation of the light device till reaches the maximum / minimum saturation value allowed for the device  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  stepMode: move up or down  0x01 – Up  0x03 – Down  stepSize : unsigned 8-bit value stepsize is a change in the CurrentHue by step size value  transitTime : Unsigned 16-bit time value in tenths of a second which will take for the device to change from its current state to the requested state  optMask : options mask  optOvrd : options override  Here in example command -s indicate that address mode is short address 0x1984 is the short address of the remote device 0x23 is endpoint of the remote device 1 is the Up direction 0x1f (31) is the step size 10 is the transition time 0 0 is the options mask and options override value      moveToHueAndSaturation addrMode addr ep hue saturation transitTime optMask optOvrd  e g : moveToHueAndSaturation -s 0x1984 0x23 0x1f 0xef 10 0 0   Observe change in light hue and saturation   This console command sends move to hue and saturation zcl command to remote devices which request the remote device to move its current hue and saturation to the value given in the Hue and Saturation field  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  hue : unsigned 8-bit hue value of light ranges from 0 – 254  saturation : unsigned 8-bit saturation value of light which ranges from range 0 to 254  transitTime : Unsigned 16-bit time value which will take for the device to change from its current saturation to the requested saturation (1/10ths of a second)  optMask : options mask  optOvrd : options override  Here in example command -s indicate that address mode is short address 0x1984 is the short address of the remote device 0x23 is endpoint of the remote device 0x1f is new hue value and 0xef is the new saturation value 10 is the transition time 0 0 is the options mask and options override value      moveToColor addrMode addr ep colorX colorY transitTime optMask optOvrd  e g : moveToColor -s 0x1984 0x23 0xa501 0xca53 10 0 0   Observe change in light color   This console command sends move to hue and saturation zcl command to remote devices which request the remote device to move from its current color to the color given in the ColorX and ColorY fields  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  colorX : color given in the ColorX across the CIE xyY Color Space range from 0 to 65279  colorY : color given in the ColorY across the CIE xyY Color Space range from 0 to 65279  transitTime : Unsigned 16-bit time value in tenths of a second which will take for the device to change from its current state to the requested state  optMask : options mask  optOvrd : options override  Here in example command -s indicate that address mode is short address 0x1984 is the short address of the remote device 0x23 is endpoint of the remote device 0xa501 0xca53 is the xy color 10 is the transition time 0 0 is the options mask and options override value      moveColor addrMode addr ep rateX rateY optMask optOvrd  e g : moveColor -s 0xfd3d 0x23 10 12 0 0   Observe change in light color   This console command sends move color zcl command to remote devices which request the remote device to move its current color in an up or down direction in a continuous fashion  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  rateX : signed 16-bit rate of movement in steps per second for colorX  rateY: signed 16-bit rate of movement in steps per second for colorY  optMask : options mask  optOvrd : options override      stepColor addrMode addr ep stepX stepY transitTime optMask optOvrd  e g : stepColor -s 0xfd3d 0x23 0x1f 0x1f 100 0 0   Observe change in light color   This console command sends step Color zcl command which request the remote devices to move from its current color by the color step indicated  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  stepX : signed 16-bit specify the change to be added to the device's CurrentX attribute  stepY : signed 16-bit specify the change to be added to the device's CurrentY attribute  transitTime : Unsigned 16-bit time value which will take for the device to change from its current state to the requested state  optMask : options mask  optOvrd : options override      moveToColorTemperature addrMode addr ep colorTemp transitTime optMask optOvrd  e g : moveToColorTemperature -s 0xfd3d 0x23 0x1fff 10 0 0   Observe change in light color   This console command sends move to color temperature zcl command which request the remote devices to move from its current color to the color given by the Color Temperature  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  colorTemp : unsigned 16-bit color temperature value ranges from range 1 to 65279  transitTime : Unsigned 16-bit time value which will take for the device to change from its current saturation to the requested saturation (1/10ths of a second)      enhancedMoveToHue addrMode addr ep enhancedHue direction transitTime optMask optOvrd  e g : enhancedMoveToHue -s 0xbc3c 0x23 0x7f00 1 500 0 0   Observe change in light color   This console command sends move to enhanced move to hue zcl command which requests light to be moved in a smooth continuous transition from their current hue to a target hue  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  enhancedHue : unsigned 16-bit value represents non-equidistant steps along the CIE 1931 color triangle ranges (0x0000 to 0xffff)  direction: direction of the hue movement          Direction    Description      0x00    Shortest Distance      0x01    Longest Distance      0x02    Up      0x03    Down        transitTime : Unsigned 16-bit time value which will take for the device to change from its current hue to the requested hue (1/10ths of a second)  optMask : options mask  optOvrd : options override      enhancedMoveHue addrMode addr ep moveMode rate optMask optOvrd  e g : enhancedMoveHue -s 0x7db6 0x23 1 5 0 0   Observe change in light color   This console command sends enhanced move hue zcl command to remote devices which request the light to move from its current enhanced hue in an up or down direction in a continuous fashion  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  moveMode : up or down direction of hue attribute      Move Mode    Description      0x00    Stop      0x01    Up      0x02    Reserved      0x03    Down      rate : unsigned 16-bit rate of movement of hue in steps per second  optMask : options mask  optOvrd : options override      enhancedStepHue addrMode addr ep stepMode stepSize transitTime optMask optOvrd  e g : enhancedStepHue -s 0xbc3c 0x23 0 0x1f 10 0 0    Observe change in light color   This console command sends enhanced step Hue zcl command which request the remote devices to move from its current enhanced hue in an up or down direction (mode) in stepSize Each step command will increment / decrement hue of the light device till reaches the maximum / minimum enhanced hue value allowed for the device  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  s tepMode : move up or down  0x01 – Up  0x03 – Down  stepSize : unsigned 16-bit value stepsize is a change in the enhanced current Hue by step size value  transitTime : Unsigned 16-bit time value in tenths of a second which will take for the device to change from its current state to the requested state  optMask : options mask  optOvrd : options override      enhancedMoveToHueAndSaturation addrMode addr ep enhancedHue saturation transitTime optMask optOvrd  e g : enhancedMoveToHueAndSaturation -s 0xbc3c 0x23 0x3fff 0xef 10 0 0   Observe change in light color   This console command sends enhanced move to hue and saturation zcl command to remote devices which request the remote device to move its enhanced current hue and saturation to the value given in the enhanced Hue and Saturation field  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  enhancedHue : unsigned 16-bit value represents non-equidistant steps along the CIE 1931 color triangle ranges (0x0000 to 0xffff)  saturation : unsigned 8-bit saturation value of light which ranges from range 0 to 254  transitTime : Unsigned 16-bit time value which will take for the device to change from its current saturation to the requested saturation (1/10ths of a second)  optMask : options mask  optOvrd : options override      colorLoopSet addrMode addr ep updateFlags action direction time startHue optMask optOvrd  e g : colorLoopSet -s 0xbc3c 0x23 0x0f 0x01 0x01 30 0xefff 0 0   Observe change in light color   This console command sends color loop set zcl command to remote devices which allows remote light to cycle through its  range of hues  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  updateFlags : unsigned 8-bit value that specifies which color loop attributes to update before the color loop is started  * Bit 0 – Update Action  * Bit 1 - Update Direction  * Bit 2 - Update Time  * Bit 3 - Update Start Hue  * Bit 4-7 - Reserved  action : unsigned 8-bit value which specifies the action to take for the color loop if the Update Action sub-field of the Update Flags field is set to 1  * 0x00 - De-activate the color loop  * 0x01 - Activate the color loop from the value in the ColorLoopStartEnhancedHue field  * 0x02 - Activate the color loop from the value of the EnhancedCurrentHue attribute  direction : specifies the direction for the color loop if the Update Direction  field of the Update Flags field is set to 1  * 0x00 - Decrement the hue in the color loop  * 0x01 - Increment the hue in the color loop  time : unsigned 16-bit value that specifies the number of seconds over which to perform a full color loop if the Update Time field of the Update Flags field is set to 1  startHue : unsigned 16-bit value that specifies the starting hue to use for the color loop if the Update Start Hue field of the Update Flags field is set to 1  optMask : options mask  optOvrd : options override      stopMoveStep addrMode addr ep optMask optOvrd  e g : stopMoveStep -s 0xbc3c 0x23 0 0   Observe change in light color get stops   This console command sends stop move step zcl command to remote devices to terminate any Move to Move or Step command currently in process  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  optMask : options mask  optOvrd : options override      moveColorTemperature addrMode addr ep moveMode rate colorTempMin colorTempMax optMask optOvrd  eg: moveColorTemperature -s 0xbc3c 0x23 0x01 60 0x000f 0xfe00 0 0   Observe change in light color   This console command sends stop move step zcl command to remote devices which request the remote device to move from its current color temperature in an up or down direction in a continuous fashion  addrMode: specifies the format of DstAddr Refer Address Mode table for more details addr: is the short address of the remote device ep: The endpoint on the remote device moveMode: up or down direction of hue attribute        Move Mode    Description      0x00    Stop      0x01    Up      0x02    Reserved      0x03    Down       rate: unsigned 16-bit value that holds the rate of movement of color temperature in steps per second colorTempMin: unsigned 16-bit value that specifies the lower bound on the ColorTemperature attribute (range 1 to 65279) colorTempMax: unsigned 16-bit value that specifies the upper bound on the ColorTemperature attribute (range 1 to 65279) optMask: options mask optOvrd: options override      stepColorTemperature addrMode addr ep stepMode stepSize transitTime colorTempMin colorTempMax optMask optOvrd  e g: stepColorTemperature -s 0xbc3c 0x23 0x00 0x01ff 10 0x000f 0xfe00 0 0   Observe change in light color   This console command sends step color temperature zcl command which request the remote devices to move its current color temperature in an up or down direction by one step  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  stepMode : move up or down  0x01 – Up  0x03 – Down  stepSize : unsigned 16-bit value that specifies the change to be added / subtracted from the current value of the device’s color temperature  transitTime : Unsigned 16-bit time value in tenths of a second which will take for the device to change from its current state to the requested state  colorTempMin : unsigned 16-bit value that specifies the lower bound on the ColorTemperature attribute (range 1 to 65279)  colorTempMax : unsigned 16-bit value that specifies the upper bound on the ColorTemperature attribute (range 1 to 65279)  optMask : options mask  optOvrd : options override      enhancedAddScene addrMode addr ep group scene trTime onOff level X Y enHue sat colorLoopActv colorLoopDir colorLoopTime colorTemp    This console command sends enhanced add scene zcl command which allow the sending device to request that the light device to add an entry in its Scene Table with the given sceneID and parameter in the payload  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  group : Unsigned 16-bit identifier for a group  scene : 8-bit unique identifier within group which is used to identify this scene  trTime : Unsigned 16-bit time value which will take for the device to change from its current state to the requested state  onOff : 1-bit onOff value 1 or 0  level : 8-bit light brightness level (0 - 0xff where 0xff is max brightness)  X : color given in the ColorX across the CIE xyY Color Space range from 0 to 65279  Y : color given in the ColorY across the CIE xyY Color Space range from 0 to 65279  enHue : unsigned 16-bit value represents non-equidistant steps along the CIE 1931 color triangle ranges (0x0000 to 0xffff)  sat : unsigned 8-bit saturation value of light which ranges from range 0 to 254  colorLoopActv: unsigned 8-bit value which specifies the action to take for the color loop (refer colorLoopSet command-action parameter)  colorLoopDir : specifies the direction for the color loop  colorTemp: unsigned 16-bit color temperature value ranges from range 1 to 65279     enhancedAddSceneToTH addrMode addr ep groupId sceneId transitionTime occupiedCoolingSetpoint occupiedHeatingSetpoint systemMode    This console command sends Enhanced Add Scene zcl command to Thermostat device to add an entry in its Scene Table with the given sceneID and parameter in the payload  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  groupId : Unsigned 16-bit identifier for a group  sceneId: 8-bit unique identifier within group which is used to identify this scene  transitionTime : Unsigned 16-bit time value which will take for the device to change from its current state to the requested state  occupiedCoolingSetpoint : signed 16-bit Occupied Cooling Setpoint Attribute specifies the cooling mode setpoint when the room is occupied  occupiedHeatingSetpoint : signed 16-bit occupied Heating Setpoint Attribute specifies the heating mode setpoint when the room is occupied  systemMode : (Unsigned 8-bit) System Mode attribute specifies the current operating mode of the thermostat      copyScene addrMode addr ep mode groupFrom sceneFrom groupTo sceneTo  e g : copyScene -s 0xbc3c 0x23 0x1234 0x10 0xabcd 0xa1   Copy scene response: status = 0x00   This console command sends copy scene zcl command to a remote device and request it to copy scenes from one group/scene identifier pair to  another group/scene identifier pair  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  mode : specify how the scene copy is to proceed  1 - all scenes are to be copied  0 – otherwise  groupFrom : Unsigned 16-bit value which specifies the identifier of the group from which the scene is to be copied  sceneFrom : Unsigned 8-bits value which specifies the identifier of the scene from which the scene is to be copied  groupTo : Unsigned 16-bit value which specifies the identifier of the group to which the scene is to be copied  sceneTo: Unsigned 8-bits value which specifies the identifier of the scene to which the scene is to be copied      enhancedViewScene addrMode addr ep groupId sceneId  e g : enhancedViewScene -s 0xbc3c 0x23 0x1234 0x10    Enhanced view scene response: status = 0x00  groupId = 0x1234  sceneId = 0x10  transitionTime = 0x0258    This console command sends enhanced view scene zcl command to remote device On receipt of this command the remote device checks for the entry in scene table for specified sceneID and responds the scene information  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  groupId : Unsigned 16-bit identifier for a group  sceneId : unsigned 8-bit unique identifier within group      sendEndpointInfo shortAddr ep  e g : sendEndpointInfo 0xbc3c 0x23     This console command sends endpoint information zcl command The endpoint information command is used to inform the remote endpoint about the general information of the local endpoint  shortAddr : is the short address of the remote device  ep : The endpoint on the remote device      getGroupIdentifiers shortAddr ep startIndex  e g : getGroupIdentifiers 0xbc3c 0x23 0    getGroupIdentifiersResponseInd()  total=1 startIndex=0 count=1  group id=0x1234 type=0x00    This console command sends Get Group Identifiers zcl command The get group identifiers request command is used to retrieve the actual group identifiers that the endpoint is using in its multicast communication in controlling different (remote) devices  shortAddr : is the short address of the remote device  ep : The endpoint on the remote device  startIndex is the starting Index for the requested elements of the Group Table      getEndpointList shortAddr ep startIndex  e g : getEndpointList 0xbc3c 0x23 0    getEndpointListResponseInd()  total=1 startIndex=0 count=1  endpoint networkAddress=0xbc3c endpointId=0x23 profileId=0x0104 deviceId=0x010d version=0x01    This console command sends Get endpoint list zcl command The get endpoint list request command is used to retrieve addressing information for each endpoint the device is using in its unicast communication in controlling different (remote) devices  shortAddr : is the short address of the remote device  ep : The endpoint on the remote device  startIndex is the starting Index for the requested elements      setTimeStatus master synchronized masterZoneDst superseding  e g : setTimeStatus 1 1 1 0     This console command set the time status of this device  master : This parameter set the master bit of the TimeStatus attribute The Master bit specifies whether the real time clock corresponding to the Time attribute is internally set to the time standard  1 – master clock  0 – not master clock  synchronized : This parameter set the synchronized bit of the TimeStatus attribute The Synchronized bit specifies whether Time has been set over the ZigBee network to synchronize it to the time standard  1 – synchronized  0 – not synchronized  masterZoneDst : This parameter set the masterZoneDst bit of the TimeStatus attribute The MasterZoneDst bit specifies whether the TimeZone DstStart DstEnd and DstShift attributes are set internally to correct values for the location of the clock  1 – master for Time Zone and DST  0 – not master for Time Zone and DST  superseding : This parameter set the Superseding bit of the TimeStatus attribute  1 – time synchronization should be superseded  0 - time synchronization should not be superseded     IasAceGetPanelStatusChangedCommand addrMode addr ep panel_status seconds_remaining audible_noti alarmstatus    This command updates ACE clients in the system of changes to panel status recorded by the ACE server  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  panel_ status : 8-bit enum as described in below table          Panel Status Enum    Description      0x00    Panel disarmed(all zones disarmed) and ready to arm      0x01    Armed Stay      0x02    Armed night      0x03    Armed Away      0x04    Exit Delay      0x05    Entry delay      0x06    Not ready to arm      0x07    In Alarm      0x08    Arming Stay      0x09    Arming Night      0x0a    Arming away        seconds_remaining : Indicates the number of seconds remaining for the server to be in the state indicated in the Panel Status  parameter  audible_noti : Provide the ACE client with information on which type of audible notification it should make for the zone  status change         Audible Notification    Description      0x00    Mute      0x01    Default Sound      0x80-0xff    Manufacturer specific      alarmstatus : 8-bit enum that provides the ACE client with information on the type of alarm the panel          Alarm Status    Description      0x00    No Alarm      0x01    Burglar      0x02    fire      0x03    Emergency      0x04    Police Panic      0x05    Fire Panic      0x06    Emergency Panic (i e medical issue)            IasAceZoneStatusChangedCommand addrMode addr ep zoneId zone_status audible zone_label     This command updates ACE clients in the system of changes to zone status recorded by the ACE server  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  zoneId : unsigned 8-bit parameter which is used to store information for each Zone enrolled by the CIE  zone_status : unsigned 8-bitvparameter which hold the current value of the ZoneStatus attribute  audible : Provide the ACE client with information on which type of audible notification it should make for the zone status change         Audible Notification    Description      0x00    Mute      0x01    Default Sound      0x80-0xff    Manufacturer specific      zone_label : string parameter which provides the Zone Label stored in the IAS CIE     ZoneInitiateNormalOperatingModeCommand a name=\"_\"ZoneInitiateNormalOperatingModeCommand addrMode addr ep    This console command sends initiate Normal Operating mode at the Ace device  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device     ZoneInitiateTestModeCommand a name=\"_\"ZoneInitiateTestModeCommand addrMode addr ep Test_Mode_Duration Current_Zone_Sensitivity Level    Sends to initiate Test operating Mode at the Ace device with its dutaion for the same with its current zone sensitivity level  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  Test_Mode_Duration : Specifies the duration in seconds for which the IAS Zone server will operate in its test mode  Current_Zone_Sensitivity_Level : Specifies the sensitivity level the IAS Zone server will use for the duration of the Test Mode and with which it must update its CurrentZoneSensitivityLevel attribute     setPointChange addrMode addr ep setpointmode amount   Sends thermostat Set Point Change Command along with the mode and amount    resetAlarm addrMode addr ep alarmId clusterID    This console command sends reset alarm zcl command to a remote device and request to resets a specific alarm This is needed for some alarms that do not reset automatically  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device  alarmId : specfies the alarm condition when alarm is generated     Alarm ID    Description      0    Supply voltage too low      1    Supply voltage too high      2    Power missing phase      3    System Pressure too low      4    System Pressure too high      5    Dry running      6    Motor temperature too high      7    Pump motor has fatal failure      8    Electronic temperature too high      9    Pump blocked      10    Sensor failure      11    Electronic non fatal failure      12    Elctronic fatal failure      13    General fault    clusterID : is the cluster on the source device that is bound to the destination     resetAllAlarms addrMode addr ep    This console command sends reset all alarm zcl command to a remote device and request to resets a all alarm  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device     resetAlarmLog addrMode addr ep    This console command sends reset alarm log zcl command to a remote device and request it to clear the alarm table  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device     getAlarm addrMode addr ep    This console command sends reset alarm log zcl command to a remote device and request it to clear the alarm table  addrMode : specifies the format of DstAddr Refer Address Mode table for more details  addr : is the short address of the remote device  ep : The endpoint on the remote device      onOffQ  e g : onOffQ    0   The console command shows the current on/off status of light     currentLevelQ  e g : currentLevelQ    127   The console command shows the current level of light      Important Notes Parameters: The command parameters has the dependency on ZCL specification like intended cluster ID attribute ID Below few examples show how the user can get these dependent parameter details from MCC configurator or from header file or through some other commands By typing any command will show the details on what parameters it expects The parameters values can be sent as hex value with 0x prefixed or as decimal values without any prefix [addrMode] - Address mode  Address Mode table        Allowed Values    Description        -g   Group address The group ID which was used while commissioning command ref     -e   Extended/MAC address command ref     -b    No address      -sor Any other values   Network Short address command ref       [ep] - Each device will have application end point This value can be taken from MCC configurator    [clusterId] - Each device type supports number of mandatory and optional clusters as per zigbee device specification The intended cluster ID can be taken from MCC configurator     [attrId] - Each cluster supports number of mandatory and optional attributes as per zigbee device specification The intended attribute ID can be taken from MCC configurator     [type][attrSize] - Attribute type and size is ZCL spec defined and is little tricky part This has to be get from the specific cluster include file from code     Examples  Read the attribute of on/off cluster and on/off attribute using network address mode from CI From the above screen shots for different parameters for destination device (on/off light device)  Command: readAttribute - Read Attribute for specified cluster: readAttribute [addrMode][addr][ep][clusterId][attrId]  e g : readAttribute 0x0 0xfe38 0x20 0x0006 0x0000 -Read attribute (AttrId:0x0) response: success Attr value = 0  OnOff command Command: onOff Sends On/Off command: onOff [addrMode][addr][ep][onOff: -on for On -off for Off] e g: onOff 0x0 0xfe38 0x20 -on    Application Device Type Responses         Device ID    Device ID Type    Description        0x0006    HA_REMOTE_CONTROL_DEVICE_ID    Remote Control device      0x0007    HA_COMBINED_INTERFACE_ID    Combined Interface      0x0100    HA_ON_OFF_LIGHT_DEVICE_ID    Home Automation On/Off Light      0x0101    HA_DIMMABLE_LIGHT_DEVICE_ID    Home Automation Dimmable Light      0x0103    HA_ON_OFF_LIGHT_SWITCH_DEVICE_ID    Home Automation On/Off Light Switch      0x0104    HA_DIMMER_SWITCH_DEVICE_ID    Home Automation Dimmer Switch      0x0106    HA_LIGHT_SENSOR_DEVICE_ID    Home Automation Light Sensor      0x0107    HA_OCCUPANCY_SENSOR_DEVICE_ID    Home Automation Occupancy Sensor      0x0301    HA_THERMOSTAT_DEVICE_ID    Home Automation Thermostat device      0x0302    HA_TEMPERATURE_SENSOR_DEVICE_ID    Home Automation Temperature Sensor      0x0400    HA_IAS_CIE_DEVICE_ID    Home Automation IAS Control and Indicating Equipment      0x0401    HA_IAS_ACE_DEVICE_ID    Home Automation IAS Ancillary Control Equipment      0x0402    HA_IAS_ZONE_DEVICE_ID    Home Automation IAS Zone      0x0403    HA_IAS_WD_DEVICE_ID    Home Automation IAS Warning Device      0x0100    ZLO_ON_OFF_LIGHT_DEVICE_ID    ZLO (ZigBee Lighting Occupancy)On/Off Light      0x0101    ZLO_DIMMABLE_LIGHT_DEVICE_ID    ZLO Dimmable Light      0x0102    ZLO_COLOR_DIMMABLE_LIGHT_DEVICE_ID    ZLO Color Dimmable Light      0x0103    ZLO_ON_OFF_LIGHT_SWITCH_DEVICE_ID    ZLO On/Off Light Switch      0x0104    ZLO_DIMMER_SWITCH_DEVICE_ID    ZLO Dimmer Switch      0x0105    ZLO_COLOR_DIMMER_SWITCH_DEVICE_ID    ZLO Color Dimmer Switch      0x0106    ZLO_LIGHT_SENSOR_DEVICE_ID    ZLO Light Sensor      0x0107    ZLO_OCCUPANCY_SENSOR_DEVICE_ID    ZLO Occupancy Sensor      0x0108    ZLO_ON_OFF_BALLAST_DEVICE_ID    ZLO On/Off Ballast      0x0109    ZLO_DIMMABLE_BALLAST_DEVICE_ID    ZLO Dimmable Ballast      0x010A    ZLO_ON_OFF_PLUG_IN_UNIT_DEVICE_ID    ZLO On/off Plug-in unit      0x010B    ZLO_DIMMABLE_PLUG_IN_UNIT_DEVICE_ID    ZLO Dimmable Plug-in unit      0x010C    ZLO_COLOR_TEMPERATURE_LIGHT_DEVICE_ID    ZLO Color Temperature light      0x010D    ZLO_EXTENDED_COLOR_LIGHT_DEVICE_ID    ZLO Extended Color light      0x010E    ZLO_LIGHT_LEVEL_SENSOR_DEVICE_ID    ZLO Light level Sensor      0x0800    ZLO_COLOR_CONTROLLER_DEVICE_ID    ZLO Color Controller      0x0810    ZLO_COLOR_SCENE_CONTROLLER_DEVICE_ID    ZLO Color Scene Controller      0x0820    ZLO_NON_COLOR_CONTROLLER_DEVICE_ID    ZLO Non Color Controller      0x0830    ZLO_NON_COLOR_SCENE_CONTROLLER_DEVICE_ID    ZLO Non-color scene remote      0x0840    ZLO_CONTROL_BRIDGE_DEVICE_ID    ZLO Control bridge      0x0850    ZLO_ON_OFF_SENSOR_DEVICE_ID    ZLO On/off Sensor      0x0401    ZLO_IAS_ACE_DEVICE_ID    ZLO On/off Sensor      0x0F00    ZLO_CUSTOM_DEVICE_ID    ZLO custom device      0x0060    GP_PROXY_DEVICE_ID    Green Power Advanced proxy      0x0061    GP_PROXY_BASIC_DEVICE_ID    Green Power Proxy basic      0x0062    GP_TARGET_PLUS_DEVICE_ID    Green Power Sink      0x0063    GP_TARGET_DEVICE_ID    Green Power Sink Basic      0x0064    GP_COMMISSIONING_TOOL_DEVICE_ID    Green Power Commissioning tool      0x0065    GP_COMBO_DEVICE_ID    Green Power Combo(sink proxy)      0x0066    GP_COMBO_BASIC_DEVICE_ID    Green Power Combo basic        Zigbee Device Type         Device ID    Device ID Type    Description        0x02    TEST_DEVICE_TYPE_ZIGBEE_COORDINATOR    Zigbee Coordinator      0x03    TEST_DEVICE_TYPE_ZIGBEE_ROUTER    Zigbee Router      0x04    TEST_DEVICE_TYPE_ZIGBEE_END_DEVICE    Zigbee End Device      0x07    TEST_DEVICE_TYPE_ZGP_TH    Combo basic Device with certification support      0x08    TEST_DEVICE_TYPE_ZGP_COMBO_BASIC    Combo basic Device      ",
							" Zigbee Commisioning Procedure Commissioning is the process of initializing the devices to join a network and to work together The Zigbee Base Device Behaviour specification specifies the procedures for the following commissioning mechanisms which are executed in the order as given given below Link to Base Device Behavior Specification by Zigbee Alliance Sequence Commissioning Aspect Details 1 Touchlink A node may support the proximity based commissioning mechanism If touchlink commissioning is supported the node shall support touchlink as an initiator a target or both - Initiator -- Will be a member of an existing network or (if not) will create a new network - Target -- Gets added to network by Initiator 2 Network Steering All nodes shall support network steering - Node not on a network - Action of searching for and joining an open network - Node on a network - It is the action of opening the network to allow new nodes to join 3 Network Formation The ability of a node to form a network with its network security model It shall be dependent on the logical device type of the node - Zigbee coordinator -- Forms a Centralized security networks - Zigbee router -- Forms a Distributed security network 4 Finding Binding Initiator Endpoint - Automatically searches and establishes application connections with target endpoint by using the identify cluster with matching cluster - Target Endpoint - Handles finding and binding requests from initiator endpoint Here Touchlink Steering and Formation decides zigbee network joining procedure Finding binding is not related to joining procedure but involves application level connections for cluster data transaction to be done in any joining procedure Default Mapping of Commissioning to zigbee device types : This is configurable from MPLAB Code Configurator (MCC) while generating the project: The commissioning procedure can be automatically started when the device is first powered on based on the 4 Commissioning Aspects (Touchlink steering formation finding binding) chosen in above MPLAB Code Configurator (MCC) This is referred as auto commissioning The application can also choose invoking this commisioning procedure manually through user input In Microchip zigbee reference applications this is demonstrated through sending console commands through UART This way of commissioning is referred as manual commissioning Auto commissioning Auto-commissioning/commissioning on startup is the easiest way of commissioning which involves automatic commissioning of devices It allows for minimal (or no) human intervention since most of the startup parameters are pre-configured The flowchart for the commissioning mode based on 4 commissioning aspect flags in Zigbee Application is described below : Flowchart for Commissioning Procedure This type of commissioning can be enabled by user using the MPLAB Code Configurator (MCC) as shown below : Below is the example of auto commissioning procedure between Combined Interface and Thermostat applications After Combined Interface application is programmed on the device automatically device starts the commissioning procedure and creates the network Program another device with Thermostat application After that the device joins the joiner(Thermostat) starts reporting attribute data back to the Combined Interface device Here there is no user input needed to initiate the commissioning It can be observed below in the console logs : Note:  \"resetToFN\" console command is used to bring the device to factory default state and reset the device This step is needed only if the UART terminal is not setup before the device gets power on first and if logs are missed in terminal Manual Commissioning (when UART is enabled) Manual mode of commissioning is configured using the following MPLAB Code Configurator (MCC) : To trigger the commissioning procedures manually the user has to issue the following console commands as given below: Touchlink – “invokeCommissioning 1 0” (The device starts touchlink as an initiator) Network Steering – “invokeCommissioning 2 0” (the device starts to search for a network to join If device is already part of the network and has the \"Router\" capability it will open the network for other devices to join) Network Formation – “invokeCommissioning 4 0” (If the device is a router or a coordinator forms the network) Finding Binding - “invokeCommissioning 8 0” (this command shall be given for any the devices which needs to be bound for clusters) - SetFBRole 1 (this command to be given on application endpoint acts as initiator which initiates the binding procedure by sending identify query request) - SetFBRole 0 (this command to be given on application endpoint acts as target) Note:  Permit Join flag is enabled for 180 secs after forming a network and opens up the network for a finite duration to allow other nodes to join To allow the joining even after 180 secs give \"setPermitJoin 180\" or “invokeCommissioning 2 0” command from the console The above mentioned note holds good for both Commissioning on Startup (auto) and manual commissioning procedure The below table shows the list of manual commissioning command sequences to be followed between 2 joining devices  Manual Commissioning command sequences          S No    Coordinator    Router/End device    Commands        1    Combined interface    Thermostat    1 Combined Interface and Thermostat - resetToFN  2 Combined Interface - invokeCommissioning 4 0  3 Combined Interface - invokeCommissioning 2 0  4 Thermostat - invokeCommissioning 2 0 (After this Thermostat joins Combined Interface)  5 Combined Interface - SetFBRole 0  6 Thermostat - SetFBRole 1  7 Combined Interface - invokeCommissioning 8 0  8 Thermostat - invokeCommissioning 8 0  9 Thermostat Device will start reporting periodically      2    Combined interface    Multi Sensor    1 Combined Interface and Multi Sensor - resetToFN  2 Combined Interface - invokeCommissioning 4 0  3 Combined Interface - invokeCommissioning 2 0  4 Multi Sensor - invokeCommissioning 2 0 (After this Multi Sensor joins Combined Interface)  5 Combined Interface - SetFBRole 0  6 Combined Interface - invokeCommissioning 8 0  7 Multi Sensor - setSrcSensorType -ls  8 Multi Sensor - SetFBRole 1  9 Multi Sensor - invokeCommissioning 8 0 (After this Light Sensor Finding and Binding happens)  10 Multi Sensor - setSrcSensorType -os  11 Multi Sensor - SetFBRole 1  12 Multi Sensor - invokeCommissioning 8 0 (After this Illuminance Measurement Finding and Binding happens)  13 Multi Sensor - setSrcSensorType -ts  14 Multi Sensor - SetFBRole 1  15 Multi Sensor - invokeCommissioning 8 0 (After this Temperature Measurement Finding and Binding happens)  16 Multi Sensor - setSrcSensorType -hs  17 Multi Sensor - SetFBRole 1  18 Multi Sensor - invokeCommissioning 8 0 (After this Relative Humidity Measurement Finding and Binding happens)  19 Multi Sensor Device will start reporting periodically      3    Combined interface    Lights    1 Combined Interface and Light - resetToFN  2 Combined Interface - invokeCommissioning 4 0  3 Combined Interface - invokeCommissioning 2 0  4 Light - invokeCommissioning 2 0 (After this Light joins Combined Interface)  5 Combined Interface - SetFBRole 0  6 Light - SetFBRole 1  7 Combined Interface - invokeCommissioning 8 0  8 Light - invokeCommissioning 8 0 (After this all the Finding and Binding happens)  9 Light Device will start reporting peridically      Note:  invokeCommissioning 8 0 has to be executed first on target device then on initiator device  SetFBRole 0 sets device as Target SetFBRole 1 sets the device as Initiator A single device can act as initiator and/or target  Combined interface and Thermostat Combined interface and Multi-sensor Combined interface and Extended Lights Touchlink Commissioning The zigbee protocol provides special commissioning called Touchlink which is an easy-to-use proximity mechanism for commisioning a device to a network This method works by the Touchlink 'initiator' determining the proximity of the target device (to be commissioned) and negotiating/transferring network parameters Touchlink commissioning can be used to form a new network and/or join a node to an existing network Touchlink is initiated on a node called the ‘initiator’ Touchlink is provided as a cluster in the ZigBee Cluster Library (ZCL) The initiator must support the Touchlink cluster as a client and the target node must support the cluster as a server If it is required on a node Touchlink commissioning must be enabled via the ZigBee Base Device attribute bdbCommissioningMode Wireshark Sniffer logs Let us look into an example Here a ColorSceneController which is an end device type will bring the light into the network and by asking light to form the distributed network via Touchlink For touchlink a color scene controller shall be brought close to a target( Light) device around like 20-30cms range It can be done in the following 2 ways :   Auto-commissioning : In order to establish touchlink via auto-commissioning each of the application e g extended lights and color scene controller MPLAB Code Configuration (MCC) has to be updated as shown below :    During auto commissioning mode the device would perform touchlink by default To initiate the process input \"resetToFN\" console command on the light device first followed by the color scene controller After that the device joins via touchlink the Light device starts reporting attribute data back to the ColorSceneController device It can be observed below in :   Console Logs      Manual commisioning : In order to establish touchlink commissioning manually each of the application e g extended lights and color scene controller MPLAB Code Configurator (MCC) has to be updated as shown below :      During manual commissioning mode we need to issue console commands on the color scene controller device to perform touchlink In order to initiate the process input resetToFN console comand on the light device first followed by the color scene controller Follow the below sequence of commands   Light and CSC - resetToFN    CSC - invokeCommissioning 1 0 (Touchlink commisioning wait for touchlinking to be completed)    CSC - SetFBRole 0    Light - SetFBRole 1    CSC - invokeCommissioning 8 0    Light - invokeCommissioning 8 0    Light Device will start reporting periodically     Console Logs       For more details regarding the commisioning procedures please refer to the Commisioning section(8) of the base device behaviour specification from Zigbee Alliance - Link to Base Device Behaviour Specification by Zigbee Alliance ",
							" Zigbee Network Security Models To satisfy a wide range of applications while maintaining low cost and power Zigbee offers two network architectures and corresponding security models: distributed and centralized  They basically differ in how they admit new devices into the network The security model controls how a network key is distributed; and may control how network frame counters are initialized The security model does not affect how messages are secured Distributed security model :   Provides a less-secured and simpler system    It has two device types    Routers    End Devices      Here a router can form a distributed security network when it can’t ﬁnd any existing network    Each router in the network can issue network keys As more routers and devices join the network the router will share the network keys to the device joining the network    To participate in distributed security networks all router and end devices must be pre-conﬁgured with a link key that is used to encrypt the network key when passing it from a router parent to a newly joined node    All the devices in the network encrypt messages with the same network key   Centralized security model : Provides higher security and is also more complicated It includes a third device type the Trust Center (TC) which is usually also the network coordinator The Trust Center forms a centralized network conﬁgures and authenticates routers and end devices to join a network The TC establishes a unique TC Link Key for each device on the network as they join and link keys for each pair of devices as requested The TC also determines the network key To participate in a centralized security network model all entities must be pre-conﬁgured with a link key that is used to encrypt the network key when passing it from the TC to a newly joined entity Only TC can share the network key with the newly joining device All non coordinator ZigBee nodes shall be able to join a network supporting either model and adapt to the security conditions of the network they are joining Zigbee Security Model ",
							" Key Exchange Process: Centralised Network The diagram below shows how a device is allowed to join Zigbee 3 0 network via the key exchange process in a centralized security model based network : The joiner device begins the join procedure by transmitting an unsecured beacon request frame (depending on whether the scan is an active or passive scan) It receives beacons from nearby routers and the NWK layer primitives parameter i e NetworkList will indicate all of the nearby PANs The joiner device shall decide which PAN to join and shall issue an association request command to the router Upon receipt of an association request command the router shall issue an association response command to be sent to the joiner If the router is the Trust Center it shall begin the authorization procedure by simply operating as a Trust Center If the router is not the Trust Center it shall begin the authorization procedure immediately by issuing an update device command request to the Trust Center The Trust Center role in the authorization procedure shall be activated upon receipt of an incoming update-device command It shall determine whether or not to allow the device onto the network This decision will be based on its own security policies If it decides to allow the device onto the network it shall send the device the active network key Once the network-level security is set-up application-level security needs be setup for more secure communication which is mandated in Zigbee 3 0 and will be used for all ongoing APS-layer communication Centralized Network ",
							" Key Exchange Process: Distributed Network The diagram shows how a device is allowed to join Zigbee 3 0 network in a distributed security model based network The joiner device begins the join procedure by transmitting an unsecured beacon request frame (depending on whether the scan is an active or passive scan) It receives beacons from nearby routers and the NWK layer primitives parameter i e NetworkList will indicate all of the nearby PANs The joiner device shall decide which PAN to join and shall issue an association request or rejoin request command to the router Upon receipt of an association request command the router shall issue an association response command to be sent to the joiner The router itself shall begin the authorization procedure It shall determine whether or not to allow the device onto the network This decision will be based on its own security policies If it decides to allow the device onto the network it shall send the device the active network key Once the network-level security is set-up application-level security needs be setup for more secure communication which is mandated in Zigbee 3 0 and will be used for all ongoing APS-layer communication Distributed Network For more details regarding the network security models please refer to the Security section of the base device behaviour specification from Zigbee Alliance - Link to Base Device Behaviour Specification by Zigbee Alliance ",
							" Example Logs Let us realize the concept of centralized network with the help of Combined Interface device (Zigbee Coordinator) and Thermostat(Zigbee router) Once the coordinator is powered-on it forms a centralized network The router which is powered on later will join the already existing network Now the router is capable of supporting other new end devices to join the network via association process etc Shows the console output from a Combined Interface Application which is a Zigbee coordinator device type and a Thermostat application which is a Zigbee router device type The ZLO lights has the capability of forming its own network though they are routers If Extended Lights(Zigbee router) was powered-on earlier to the coordinator it wouldn't be able to find any network to join In the absence it will create a distributed network Any end device/router shall be able to join the network via appropriate authentication process Shows the console output from a Extended Light Application (Zigbee router) establishes a Distributed Network A Color Scene controller (Zigbee end device) joins the network : ",
							" Zigbee Green Power Green Power is a feature of Zigbee that allows for energy-harvesting technology to be used directly with the Zigbee stack Green Power is the global wireless standard for large installations where changing batteries and accessing devices becomes costly Green Power Infrastructure Device Types Green Power Proxy (GPP) or Proxy: A fully compliant Zigbee device which in addition to the core zigbee specification also implements proxy functionality of the Green Power feature basic or advanced The proxy is able to handle GPDFs (Green Power Data Frame) and tunnel the received GPDF to the sink on the zigbee network Green Power Sink (GPS) or Sink: A fully compliant Zigbee device which in addition to a core zigbee specification also implements the sink functionality of the Green Power feature basic or advanced The sink is thus capable of receiving processing and executing GPD commands tunneled and optionally also directly received Since all the Zigbee Routers supports proxy functionality Sink exists always in combination with proxy as Green power combo which is explained below Green Power Combo (GPC) or Combo A fully compliant Zigbee device which in addition to a core zigbee specification also implements both the proxy and the sink functionality of the Green Power feature A Combo can thus receive process and execute both tunneled and directly received GPD commands (in its sink role) as well as forward them to other GP nodes (in its proxy role) The serial console commands supported by combo-basic are listed in Serial Console Commands doc Zigbee Serial console commands to verify Application / Stack behavior Green Power End Device (GPD) Type A Green Power device may be considered a fourth logical device type They are designed to be used in very low power operation where they are intended to only send very simple commands These small commands are called GPDFs which is short for Green Power Data Frames Note:  Currently Green power infrastructure device types alone supported in Microchip zigbee stack The Green power end device type is expected to be supported in upcoming Microchip zigbee stack Green Power Device Commissioning Commissioning is done between a GPD and sink/Combo basic Once commissioning is done the sink will process the frames received from the particular GPD which got commissioned To commission a green power device (GPD) with the endpoint on a target sink (present as a combo on Zigbee device) the sink has to be put in commissioning mode If no endpoint in sink that supports the GPD device type commissioning will fail If the GPD is not in the vicinity of the sink commissioning can happen via a proxy device Commissioning mode is enabled in proxy by broadcasting proxy commissioning mode command from console of sink On receipt of GP Proxy Commissioning Mode command the proxy enters or exits the commissioning mode based on the options field in the command Commissioning commands from GPD are verified in proxy and gets forwarded to sink via GPCommissioningNotification command Note that GPD always sends messages in Green power frame format whereas the commands that are transferred between proxy and sink are always in zigbee frame format as ZCL Green power cluster commands Sink/Proxy can also send commands to GPD but only when GPD indicates that it is available for reception This will be indicated in RxAfterTx bit in the data sent by GPD Zigbee Green Power Operation Based on the device type of a GPD it can act as OnOff switch Temperature sensor illuminance sensor etc After commissioning the GPD might send different commands and attribute reporting according to the device type The data reaches the sink either directly or via proxy by GP notification command Both proxy and sink performs security processing on the data sent by the GPD The GP cluster endpoint of sink receives this GPD data first and forwards it to the appropriate endpoint implemented in sink device For more details regarding the Zigbee Green Power Feature please refer to the specification from Zigbee Alliance - Link to Zigbee PRO Green Power feature Specification by Zigbee Alliance MPLAB Code Configurator (MCC) allows to configure the Zigbee Green Power feature as below ",
							" ZigBee Applications Documentation describing steps to test and develop the precompiled Zigbee application examples  The Zigbee Application examples are simple precompiled examples that can be tested using more than one WBZ451 curiosity board These precompiled examples do not require you to set up the full toolchain Therefore programming and testing them should not take more than a few minutes    The Zigbee examples are provided here to understand our BitCloud stack based on ZigBee specification various ZigBee device types and supported device clusters These examples are explained to handle the single and multiple clusters supported device types specified by ZigBee specification The provided examples demonstrate features of ZigBee lights thermostats various sensors etc Also ZigBee supported various device types which were used to form ZigBee compliance network devices This is recommended for users who are new to the Microchip BLE stack and other toolchains like MPLAB Code Configurator    ",
							" Zigbee Application Demo: Light control and Monitoring using Combined Interface  WBZ451 Curiosity Board  Devices (Device): | PIC32CX1012BZ25048 (MCU) on WBZ451 module |  Peripherals (Used On-Board): | RGB LED | User Button | UART-USB Converter |   Introduction  This page describes the demo steps for Light control and Monitoring using Combined Interface on WBZ451 Curiosity boards An overview of the demo is shown below   Hardware Required         Tool    Qty       WBZ451 Curiosity Boards  2    Micro USB cable  2    Personal Computer  1       SDK Setup Gettting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC  Software  TeraTerm   Programming the precompiled hex file or Application Example  To run the demo we need 2 devices One is the Combined Interface and the other is extended color light    One of the WBZ451 Curiosity board is programmed with Combined Interface which can act as Zigbee Gateway/Coordinator Program the CI pre-compiled hex image by following steps on one curiosity board    Another WBZ451 Curiosity board is programmed with Extended Lights application which can act as Zigbee Router Follow the below step for programming Extended Lights application on another curiosity board    Programming the hex file using MPLABX IPE    Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps zigbee ext_light\" folder    Follow the steps mentioned here    Caution: Users should choose the correct Device and Tool information  Programming the Application using MPLABX IDE    Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document    Open and program the Application Example \"ext_light x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps zigbee ext_light firmware\" using MPLABX IDE    Harmony Content Path  how to find what is my Harmony Content Path   Demo Description  The demo applications demonstrates the Zigbee protocol functionality of PIC32CXBZ/WBZ family of devices and modules It consists of a ZigBee 3 0 Coordinator and Router implemented as shown below :          Application    Zigbee Logical Device Type    Functionality       Combined Interface  Coordinator  Device capable of controlling and monitoring other devices It is typically a mains-powered device like a personal computer    Extended Lights  Router  Is a lighting device that can be switched on/off brightness color of the light can be adjusted via the color commands      Zigbee device commissioning:    The Zigbee router i e Extended Lights can be commissioned and brought to the existing zigbee network formed by Zigbee coordinator i e Combined Interface or can create new zigbee Distributed network (if there is no nearby network)    Zigbee Light control:    Extended light RGB LED can be controlled from Zigbee Gateway of the same network    When the light status is changed the light change report will be sent to zigbee gateway through Zigbee communication    Demo Steps: The Zigbee light can be connected to any zigbee network Joining Light with WBZ451 Combined Interface (CI) Coordinator Hardware Software Setup  Supply power to WBZ451 Curiosity Board consisting of Combined Interface application by connecting a USB cable Power Supply (PS) Green LED will turn on when connect to PC  The application activity is shown as \"Console Log\" through on board UART-USB converter    Open Terminal(eg: Tera Term) with the setup as shown below to look for these logs    On the PC side virtual COM port connection that corresponds to the board shall have following settings:  BAUD RATE: 115200 (as configured in SERCOM configuration) PARITY: None DATA BITS: 8 STOP BITS: 1 FLOW CONTROL: None   Additionally local echo and sending line ends with line feeds shall be enabled in the PC serial terminal application Network Formation (Coordinator - (Combined Interface)) Follow the steps explained in Network Formation (Coordinator - (Combined Interface)) to open up the network in CI Commissioning (Router - Extended Light) The Extended Lights can be connected to any zigbee gateway (Combined interface running on WBZ451 Curiosity Board in the previous step)   Supply power to another WBZ451 Curiosity Board programmed with \"Extended Light\" by connecting a USB cable Power Supply (PS) Green LED will turn on when connect to PC    Follow step 2 in \"Hardware Software Setup\" for UART terminal Setup    Input command : resetToFN and look for the below logs for successful joining with CI    Success logs : When extended light successfully commissioned with Combined Interface below log will be seen   Light Control RGB LED on WBZ451 curiosity board is tied with Zigbee functionality The LED color and brightness can be changed through Zigbee network  The RGB color can be controlled from Combined Interface through console commands   RGB color is changed from Combined Interface will be reflected in next received light attribute report in combined Interface  The network address of the light is needed to send light control commands to light  This network address can be got from Combined interface console log while commissioning was done Refer to the above success log for light network address   Another way to get the network address from light is executing the below command in light side Command: getNetworkAddress Response: f088   The table below shows few commands for light control(on /off brightness hue saturation) Refer to doc Serial Console Commands to get to know the different parameters of the commands          Command Type  Commands  Parameter Details      RGB LED ON  onOff 0x0 0xf088 0x23 -on  0x23 zigbee end-point number used for Light    RGB LED OFF  onOff 0x0 0xf088 0x23 -off  0x23 zigbee end-point number used for Light    RGB LED brightness change  moveToLevel 0x0 0xf088 0x23 0x45 0x0 0x1 0x0 0x0  0x45 is the configurable brightness value    RGB LED color change  moveToHueAndSaturation 0x0 0xf088 0x23 0x45 0x67 0x0 0x0 0x0  0x45 and 0x67 are the configurable Hue and Saturation values     Other Functionalities   On board button actions:    When the on board \"User Button ( SW2 )\" is pressed for more than 10sec it can delete all the networking information and will bring the device to factory default state This functionality is available in both combined interface and light devices      Persistent Data Storage (PDS): The RGB light status (On/Off) and brightness values are stored in non-volatile memory called PDS So power off/on of extended light these values persist and RGB LED will reflect accordingly This PDS storage is tied to zigbee network    The light On/Off status colour and light brightness is being stored in non-volatile memory in this case So power off/on the LED will be updated with light on/off color and brightness values retrieved from previous transaction      Creating Application Device Types From Scratch Using MCC  All the supported device types including this Extended Colour light projects can be generated by following the steps in Generating project from MCC There are different zigbee device types supported in Microchip Zigbee framework Few sample application projects are available as reference Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps zigbee The projects for other device types can be generated by following the step by step procedure in this document   ",
							" Zigbee Application Demo: Light control and Monitoring using Alexa Echo Plus WBZ451 Curiosity Board Devices (Device): | PIC32CX1012BZ25048 (MCU) on WBZ451 module | Peripherals (Used On-Board): | RGB LED | User Button | UART-USB Converter | Introduction This page describes the demo steps for WBZ451 Curiosity board Extended Light control and Monitoring using Amazon Echo Plus (zigbee gateway) An overview of the demo is shown below Hardware Required  Tool  Qty WBZ451 Curiosity Boards 1 Micro USB cable 1 Amazon Echo Plus (Built-in Zigbee smart home hub) 1 Smart Phone with Alexa app installed 1 Personal Computer 1 SDK Setup Gettting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Software  TeraTerm Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps zigbee ext_light\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"ext_light x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps zigbee ext_light firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description The demo applications demonstrates the Zigbee protocol functionality of PIC32CXBZ/WBZ family of devices and modules It consists of a ZigBee 3 0 Coordinator and Router implemented as shown below :  Application  Zigbee Logical Device Type  Functionality Amazon Echo Plus Coordinator Device capable of controlling and monitoring other devices Extended Lights Router Is a lighting device that can be switched on/off brightness color of the light can be adjusted via the color commands Zigbee device commissioning: The Zigbee router i e Extended Lights can be commissioned and brought to the existing zigbee network formed by Zigbee gateway i e Amazon Echo Plus or can create new zigbee Distributed network (if there is no nearby network) Zigbee Light control: Extended light RGB LED can be controlled from Zigbee Gateway of the same network When the light status is changed the light change report will be sent to zigbee gateway through Zigbee communication Demo Steps: Hardware Software Setup Supply power to WBZ451 Curiosity Board consisting of Extendted light application by connecting a USB cable Power Supply (PS) Green LED will turn on when connect to PC The application activity is shown as \"Console Log\" through on board UART-USB converter Open Terminal(eg: Tera Term) with the setup as shown below to look for these logs On the PC side virtual COM port connection that corresponds to the board shall have following settings: BAUD RATE: 115200 (as configured in SERCOM configuration) PARITY: None DATA BITS: 8 STOP BITS: 1 FLOW CONTROL: None Additionally local echo and sending line ends with line feeds shall be enabled in the PC serial terminal application Commissioning (Router - Extended Light) Light can be added to Alexa's Zigbee network by voice commands or by using Alexa mobile app Voice Commands: Open Alexa to discover the Light device Say “Discover my devices” or  Alexa App: Launch Alexa app from the menu select the Add Device Select the type of smart home device “Light” and select \"Other\" Initiate Discover Devices Input command : resetToFN on light device The Light will be discovered and shown as light in Alexa app as shown below Note: Echo Plus is in discovery mode for 45 secs Devices wanting to join Echo Plus should initiate joining/connecting procedure within this time limit for a successful join RGB color control from Alexa Either through voice commands like \"Alexa Turn on my first light\" \"Alexa Change color of my first light to \"GREEN\"\" \"Alexa increase the brightness of my first light\" or from Alexa app the RGB LED can be controlled through Zigbee network ---- Other Functionalities On board button actions: When the on board \"User Button ( SW2 )\" is pressed for more than 10sec it can delete all the networking information and will bring the device to factory default state This functionality is available in both combined interface and light devices Persistent Data Storage (PDS): The RGB light status (On/Off) and brightness values are stored in non-volatile memory called PDS So power off/on of extended light these values persist and RGB LED will reflect accordingly This PDS storage is tied to zigbee network The light On/Off status colour and light brightness is being stored in non-volatile memory in this case So power off/on the LED will be updated with light on/off and brightness values retrieved from previous transaction Creating Application Device Types From Scratch Using MCC All the supported device types including this Extended Colour light projects can be generated by following the steps in Generating project from MCC There are different zigbee device types supported in Microchip Zigbee framework Few sample application projects are available as reference Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps zigbee The projects for other device types can be generated by following the step by step procedure in this document  ",
							" Zigbee Centralised Network Formation by Combined Interface WBZ451 Curiosity Board Devices (Device): | PIC32CX1012BZ25048 (MCU) on WBZ451 module | Peripherals (Used On-Board): | User Button | UART-USB Converter | Introduction This page describes the zigbee network formation in Combined Interface on WBZ451 Curiosity boards In zigbee centralized network the network is formed by zigbee co-ordinator Other routers and end-devices can enter into the network once it is formed The demo steps explained here can be followed for any devices like light thermostat etc to bring into the CI formed network Hardware Required  Tool  Qty WBZ451 Curiosity Boards 1 Micro USB cable 1 Personal Computer 1 SDK Setup Gettting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Software  TeraTerm Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps zigbee combinedInterface\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"combinedInterface x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps zigbee combinedInterface firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description  Application  Zigbee Logical Device Type  Functionality Combined Interface Coordinator Device capable of controlling and monitoring other devices It is typically a mains-powered device like a personal computer WBZ451 Curiosity board is programmed with Combined Interface which can act as Zigbee Gateway/Coordinator Demo Steps: Network Formation in CI Hardware Software Setup Supply power to WBZ451 Curiosity Board consisting of Combined Interface application by connecting a USB cable Power Supply (PS) Green LED will turn on when connect to PC The application activity is shown as \"Console Log\" through on board UART-USB converter Open Terminal(eg: Tera Term) with the setup as shown below to look for these logs On the PC side virtual COM port connection that corresponds to the board shall have following settings: BAUD RATE: 115200 (as configured in SERCOM configuration) PARITY: None DATA BITS: 8 STOP BITS: 1 FLOW CONTROL: None Additionally local echo and sending line ends with line feeds shall be enabled in the PC serial terminal application Network Formation (Coordinator - (Combined Interface)) Once the board is powered on and serial terminal setup is done the board is ready to be operated as a coordinator It is responsible for initially forming the network and then via the Trust Centre functionality managing which other devices are allowed to join the network and distributing security keys to those that are allowed to join Input command : resetToFN and look for the below logs for successful zigbee network formation on CI It will open up the network for other zigbee devices to join for first 180 seconds from the first powerON Case1 : If a near by device is trying to join a network and sees CI then will join the network as shown in below log Case2 : The commissioning procedure will last for 180 seconds In case no other devices are there in vicinity and at the end of 180 seconds the below log is observed : Case3 : To open up the network after 180 seconds to allow other devices to join we have to input the below commands in CI before commissioning is initiated in another device setPermitJoin 180 - This command opens up the network for next 180sec invokeCommissioning 8 0 - This command opens up the network for \"finding and binding procedure\" Success logs : When another device for example \"Extended Light\" successfully commissioned with \"Combined Interface\" below log will be seen Zigbee OTAU handshake logs: \"CombinedInterface\" has been enabled OTAU client feature when it is working it keeps sending command to handshake with OTAU PC tool it is ISD_DRIVER_INIT_REQUEST command as values of 2A 03 00 01 00 55 so user may see a lot of \"*U*U\" message in the log When this message keep printing user can still input any command without being interfered Other Functionalities On board button actions: When the on board \"User Button ( SW2 )\" is pressed for more than 10sec it can delete all the networking information and will bring the device to factory default state Creating Application Device Types From Scratch Using MCC All the supported device types including this CI projects can be generated by following the steps in Generating project from MCC There are different zigbee device types supported in Microchip Zigbee framework Few sample application projects are available as reference Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps zigbee The projects for other device types can be generated by following the step by step procedure in this document ",
							" Zigbee Application Demo: Multi-Sensor with Low Power Functionality WBZ451 Curiosity Board Devices (Device): | PIC32CX1012BZ25048 (MCU) on WBZ451 module | Peripherals (Used On-Board): | UART-USB Converter | Introduction This tutorial will help users to create a low power enabled multi sensor application Prerequisites : Hardware Required  Tool  Qty WBZ451 Curiosity Boards 2 Micro USB cable 2 Personal Computer 1 SDK Setup - Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Terminal Software - TeraTerm Demo Description This application demonstrate the Zigbee Multi-Sensor end device joining to Zigbee Coordinator (Combined Interface or third-party gateway's such as Amazon Echo plus can also be used instead of CI ) After joining multisensor device will start ZCL attribute reporting of sensor data such as temperature occupancy light and humidity after connecting to the network  Application  Zigbee Logical Device Type  Functionality Combined Interface Coordinator Device capable of controlling and monitoring other devices It is typically a mains-powered device like a personal computer Multi-Sensor End Device Reports sensor data such as temperature occupancy light and humidity periodically to gateway To run the demo we need 2 devices One is the Combined Interface and the other is multi sensor One of the WBZ451 Curiosity board is programmed with Combined Interface which can act as Zigbee Gateway/Coordinator Program the CI pre-compiled hex image by following steps on one curiosity board Another WBZ451 Curiosity board is programmed with Multi sensor application which can act as Zigbee end device Program the pre-compiled hex image by following Programming the precompiled hex file using MPLABX IPE on another curiosity board If want to do changes in the demo code and would like to program/debug the customized code follow the instruction in Build and Program The Application If want to generate an application from scratch refer: Creating New Application Device Types The steps for adding low power functionality is also explained here Demo Steps: Commissioning The Zigbee Multi-Sensor can be connected to any zigbee network The steps explained in Joining Multi-Sensor with Amazon Echo can be followed to connect Zigbee Multi-Sensor to Amazon Echo if Amazon Echo has Built-in Zigbee smart home hub The steps explained in Joining Multi-Sensor with WBZ451 Combined Interface (CI) Coordinator can be followed to connect with WBZ451 based combined interface which acts as Zigbee Coordinator Joining Multi-Sensor with Amazon Echo Multi-Sensor can be added to Alexa's Zigbee network by voice commands or by using Alexa mobile app Voice Commands: Open Alexa to discover the Multi-Sensor device Say “Discover my devices” or  Alexa App: Launch Alexa app from the menu select the Add Device Select the type of smart home device “Motion Sensor” and select other Initiate Discover Devices Power on the Multi-Sensor device The Multi-Sensor will be discovered and shown as motion sensor in Alexa app as shown below Note: Echo Plus is in discovery mode for 45 secs Devices wanting to join Echo Plus should initiate joining/connecting procedure within this time limit for a successful join Joining Multi-Sensor with WBZ451 Combined Interface (CI) Coordinator # Hardware Software Setup Supply power to WBZ451 Curiosity Board consisting of Combined Interface application by connecting a USB cable Power Supply (PS) Green LED will turn on when connect to PC The application activity is shown as \"Console Log\" through on board UART-USB converter Open Terminal(eg: Tera Term) with the setup as shown below to look for these logs On the PC side virtual COM port connection that corresponds to the board shall have following settings: BAUD RATE: 115200 (as configured in SERCOM configuration) PARITY: None DATA BITS: 8 STOP BITS: 1 FLOW CONTROL: None Additionally local echo and sending line ends with line feeds shall be enabled in the PC serial terminal application # Network Formation (Coordinator - (Combined Interface)) Follow the steps either case1 or case2 explained in Network Formation (Coordinator - (Combined Interface)) to open up the network in CI # Commissioning (End Device - Multi-Sensor) Supply power to WBZ451 Curiosity Board which is programmed with Multi-Sensor image by connecting a USB cable The Multi-Sensor will search for Zigbee coordinator device and will join to network and intiate Finding Binding Once Multi-Sensor finishes Finding Binding procedure it will start attribute reporting The Combined interface terminal log will print the received attribute information as shown below Programming the precompiled hex file using MPLABX IPE Precompiled Hex file Extended light is located Multi Senso Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Follow the steps for running the demo Build and Program The Application The source code of demo application is available here Multi Sensor The source code implements the low power application as well and the configuration details are explained here for reference If want to do changes in the demo code and would like to program/debug the customized code follow the below instruction Open the \"firmware/Zigbee_MultiSensor_wbz451_curiosity X\" MPLABX project from MPLABX Do your changes in the code Clean and build your application by clicking on the Clean and Build button as shown below Program your application to the device by clicking on the Make and Program button as shown below Creating Application Device Types From Scratch Using MCC All the supported device types including this Multi Sensor projects can be generated by following the steps in Generating project from MCC Multi sensor is zigbee end device type So the low power sleep functionality can be enabled for this application Follow the steps in low power configuration doc Compile and Run the project in WBZ45x device ",
							" Getting Started With Multiprotocol Applications Documentation describing steps to test and develop the precompiled BLE and Zigbee coexistence application examples The Multiprotocol applications provide to demonstrate the capability of our PIC32CXBZ2 device The device supports both BLE and ZigBee technologies in the 2 4 GHz frequency range Our software stacks handle both technologies as specified in the respective specifications Mainly our software stack is capable to handle both technologies together in a coexistence mode This is recommended for users who are new to the Microchip BLE stack and other toolchains like MPLAB Code Configurator These multiprotocol applications demonstrate the Provisioning through BLE for Zigbee commissioning parameters control and monitoring the Zigbee devices from mobile apps etc ",
							" Multiprotocol (BLE+ZIGBEE) Concurrent Application - Tutorial This tutorial will help users to create multiprotocol (BLE+ZIGBEE) example project using Mplab code configurator The step by step procedure will help the user to generate the multiprotocol project from scratch and will guide in understanding few API calls needed for data transaction between 2 protocols The project created at end of this tutorial will look the sample project available here Hardware Required  Tool  Qty WBZ451 Curiosity Board 2 Micro USB cable 2 Android/iOS Mobile 1 SDK Setup  SDK Setup Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Software  TeraTerm Smartphone App Microchip Bluetooth Data (MBD) iOS/Android app available in stores Demo Description This application demonstrate the Zigbee On/Off light joining to Zigbee gateway (Combined Interface) and the Microchip Proprietary Transparent Service based BLE peripheral running concurrently with zigbee protocol connects with mobile app When the Zigbee light gets the light on/off command from CI will be displayed in mobile app Hence the simple concurrent operation of multiprotocol is demonstrated here Lights and Bridge (CI) devices are the interest of this tutorial where the WIFI/Ethernet gateway is not scope of this application The third party gateway like Amazon Echo plus can also be used instead of CI Developing this Application from scratch using MPLab Code Configurator The following steps will help to understand the PIC32CXBZ2 device ZIGBEE and BLE stack programming structure We recommend to follow the steps If wish to have Out-of-Box experience with the precompiled hex file Go Here Pull-in MCC Components Create a new MPLAB Code Configurator Project -- link for instructions Drag and Drop the Zigbee components from \"Available\" components to Project Graph OnOffLight Device component \"Accept Dependencies or satisfiers select \"Yes\"\" Drag and Drop the BLE components BLE Stack component - Transparent Profile and Service components \"Add Dependencies or satisfiers\" Add UART components needed for console logs Verify the Project Graph window has all the expected components Edit BLE Stack Specific Configurations Select BLE_Stack component in project graph and edit as below Select Transparent Profile component in project graph and edit as below Edit Zigbee Stack Specific Configurations Edit Onoff Light component in project graph The \"Commissioning Configuration\" is edited to enable only Steering option Edit Peripheral Specific Configurations Edit SERCOM0 component in project graph for UART pin map and Baud rate Edit Pin Configuration in project graph for RED LED GPIO configuration Generate Code link for instructions Files and Routines Automatically generated by the MCC After generating the code from MCC interface by clicking Generate Code below is the project folder structure BLE Zigbee Stack Initialization and Application callback registration: The RF System BLE System ZIGBEE PERIPHERAL initialization routine executed during program initialization can be found in SYS_Initialize() of initialization c file Zigbee Stack provides various APIs for application and those APIs belong to the specific module within dedicated group The sequence of initialization is already taken care in the stack when Zigbee_Init() from initialization c is called The BLE stack initialization routine executed during Application Initialization can be found in APP_BleStackInit() in app c This call initializes and configures different BLE layers like GAP GATT SMP L2CAP and BLE middleware layers and registers the application layer callbacks The event callbacks from BLE stack BLE middleware and Profile/service layer are registered Also the MCC configured advertisement data payload can be seen in APP_BleConfigBasic() Similar to BLE Zigbee Stack also generate events to inform application if there is any status changed or activity Application may need to get the relevant information from Zigbee Stack and do the corresponding procedure BLE Zigbee Stack application events handling: app c file is autogenerated and has a state machine for application callback handling from BLE Zigbee stacks User Application Development 1 Compile MCC auto generated project Compile the MCC auto generated project as below Addressing the mandatory error: User action required in app_idle_task c Follow the steps mentioned in the note and do the necessary changes Then comment the #error message as below 2 BLE specific code addition 1 Start Advertisement (app c) Advertisement payload is already auto generated based on MCC configuration as mentioned in Edit BLE Stack Specific Configurations It is only required to start the advertisement by adding the below API in APP_STATE_INIT state BLE_GAP_SetAdvEnable(true 0); void APP_Tasks ( void ) { APP_Msg_T appMsg[1]; APP_Msg_T *p_appMsg; p_appMsg=appMsg; ZB_AppGenericCallbackParam_t cb; /* Check the application's current state */ switch ( appData state ) { /* Application's initial state */ case APP_STATE_INIT: { bool appInitialized = true; //appData appQueue = xQueueCreate( 10 sizeof(APP_Msg_T) ); APP_BleStackInit(); BLE_GAP_SetAdvEnable(true 0); 2 Connected Disconnected Events (app_ble_handler c) The BLE application specific callbacks from BLE stack is handled in app_ble_handler c file Few events needed for this application to be handled by the user code as below Connection Handler In app_ble_handler c BLE_GAP_EVT_CONNECTED event will be generated when a BLE peripheral is connected with Central (mobile app) Connection handle associated with the peer central device needs to be saved for data exchange after a BLE connection Add the below code in APP_BleGapEvtHandler()  Console log is also added to print the connected message and respective #include file is also added #include app_zigbee/zigbee_console/console h void APP_BleGapEvtHandler(BLE_GAP_Event_T *p_event) { switch(p_event- eventId) { case BLE_GAP_EVT_CONNECTED: { /* TODO: implement your application code */ appSnprintf(\"[BLE} Connected n r\"); conn_hdl = p_event- eventField evtConnect connHandle; linkState = APP_BLE_STATE_CONNECTED; } break; In app_ble_handler h add the below definitions which are used in above step // ***************************************************************************** // ***************************************************************************** // Section: Type Definitions // ***************************************************************************** // ***************************************************************************** uint16_t conn_hdl; uint8_t linkState; #define APP_BLE_STATE_CONNECTED 0x01 #define APP_BLE_STATE_STANDBY 0x00 Disconnection Handler In app_ble_handler c BLE_GAP_EVT_DISCONNECTED event will be generated when BLE peripheral is disconnected from Central (mobile app) Advertisement can be started again to enable another connection Console log is also added to print the disconnected message case BLE_GAP_EVT_DISCONNECTED: { /* TODO: implement your application code */ appSnprintf(\"[BLE} DisConnected n r\"); BLE_GAP_SetAdvEnable(true 0); linkState = APP_BLE_STATE_STANDBY; } break; 3 Zigbee specific code addition (app_zigbee_handler c) There will be 3 major events which the stack would provide to the user application in app_zigbee_handler c file They are Zigbee Events which is defined as \"EVENT_ZIGBEE\" ZCL and Cluster Events defined as \"EVENT_CLUSTER\" Board Specific Package (BSP) Events defined as \"EVENT_BSP\" 1 ZCL EVENT_CLUSTER event handling for on/off Light cluster  ZCL (Zigbee cluster library) ZCL is a repository for cluster functionalities Regularly updated with new functionality added Not to “re-invent the wheel” for new application development  Cluster Cluster is a set of attributes and commands which are defined for a particular application functionality/feature Attributes and their data types are defined Uses client/server model of communication Standard commands/messages ensure interoperability abstracts the commands for developers Ex: On/Off cluster Attributes: OnOff OnTime OffWaitTime Commands: Off On Toggle OffWithEffect OnWithRecallGlobalScene OnWithTimedOff   -Explore  For more details regarding clusters please refer to the specification from Zigbee Alliance - Link to Zigbee Cluster Library Specification by Zigbee Alliance This project uses On/Off device type Hence uses On/Off light cluster from Zigbee defined cluster library When the On/Off command to control the light is received from Combined Interface gateway CMD_ZCL_ON CMD_ZCL_OFF of ZCL EVENT_CLUSTER will be received on light device A simple console print is already added in those event callbacks as below void Cluster_Event_Handler(APP_Zigbee_Event_t event) { switch(event eventId) { case CMD_ZCL_ON: { /* ZCL Command ON received */ //Access - event eventData zclEventData addressing; //Access - event eventData zclEventData payloadLength; //Access - event eventData zclEventData payload; appSnprintf(\"On r n\"); uint8_t onCmd; onCmd = 0x01; if(linkState == APP_BLE_STATE_CONNECTED) BLE_TRSPS_SendVendorCommand(conn_hdl 0x8F 0x01 onCmd); } break; case CMD_ZCL_OFF: { /* ZCL Command Off received */ //Access - event eventData zclEventData addressing; //Access - event eventData zclEventData payloadLength; //Access - event eventData zclEventData payload; appSnprintf(\"Off r n\"); uint8_t offCmd; offCmd = 0x00; if(linkState == APP_BLE_STATE_CONNECTED) BLE_TRSPS_SendVendorCommand(conn_hdl 0x8F 0x01 offCmd); } break; 2 EVENT_BSP event handling for on/off Light control In addition to above ZCL event BSP event will also be called when On/Off command is received This will enable the user to write the board specific functionality code like switch on/off the on board LED CMD_LED_BRIGHTNESS single event is called for both On or Off since On/Off cluster is added in many other device types like dimmable light color control light where light functionality is also mapped to brightness/color and not simple On/Off Add below code to control on board RED LED void BSP_Event_Handler(APP_Zigbee_Event_t event) { // User to handle board Support package events switch(event eventId) { case CMD_LED_BRIGHTNESS: { /* Set the given LED brightness */ //Access - event eventData value; //appSnprintf(\"Led Brightness r n\"); if(event eventData value == 255)// MAX_BRIGHTNESS_LEVEL for On RED_LED_Set(); else if (event eventData value == 0) //MIN_BRIGHTNESS_LEVEL for Off RED_LED_Clear(); } break; Add the include file needed for LED GPIO functionality in app_zigbee_handler c #include \"peripheral/gpio/plib_gpio h\" 3 Edit device unique ID (zigbeeAppDeviceSelect h) All the zigbee devices/modules will hold their unique IEEE address purchased from IEEE For the demo purpose where UID is not present in internal NVM the pre-compiled fixed UID to be used Edit the CS_UID to user defined value and not matching with combined interface UID (default 0xbee) as below in zigbeeAppDeviceSelect h 4 Data Transaction between BLE to ZIGBEE protocol and vice versa Transparent Profile and Service (TRP/TRS) is the proprietary BLE service by microchip to establish data and control channel between BLE Central (Phone) and Peripheral (device) The custom 128-bit GATT characteristics are defined under this service  Definition of Transparent Service and Characteristics UUID's Characteristic Name UUID Properties TRS Service 49535343-FE7D-4AE5-8FA9-9FAFD205E455 TRS TxD- Tx Data to Client role (Data pipe) 49535343-1E4D-4BD9-BA61-23C647249616 Notify Write TRS TxD - Client Characteristic Configuration Descriptor Read Write TRS RxD- Rx Data from Client role (Data pipe) 49535343-8841-43F4-A8D4-ECBE34729BB3 Write Write without response TRS Ctrl Pt - Command and Response (Ctrl pipe) 49535343-4C8A-39B3-2F49-511CFF073B7E Notify Write Write without response TRS Ctrl Pt - Client Characteristic Configuration descriptor Read Write 1 Send data over BLE (app_zigbee_handler c) When the On/Off command is received from CI send single byte of data to mobile app using Transparent service We use TRS Ctrl Pt characteristic in this example project to send and receive data from mobile app BLE_TRSPS_SendVendorCommand(conn_hdl 0x8F 0x01 onCmd) is the API to be used for sending data towards the central device Here 0x8F is any custom command value for identification and 0x01 is length of the command data Add this API call in Zigbee On/Off ZCL event callbacks as below void Cluster_Event_Handler(APP_Zigbee_Event_t event) { switch(event eventId) { case CMD_ZCL_ON: { /* ZCL Command ON received */ //Access - event eventData zclEventData addressing; //Access - event eventData zclEventData payloadLength; //Access - event eventData zclEventData payload; appSnprintf(\"On r n\"); uint8_t onCmd; onCmd = 0x01; if(linkState == APP_BLE_STATE_CONNECTED) BLE_TRSPS_SendVendorCommand(conn_hdl 0x8F 0x01 onCmd); } break; case CMD_ZCL_OFF: { /* ZCL Command Off received */ //Access - event eventData zclEventData addressing; //Access - event eventData zclEventData payloadLength; //Access - event eventData zclEventData payload; appSnprintf(\"Off r n\"); uint8_t offCmd; offCmd = 0x00; if(linkState == APP_BLE_STATE_CONNECTED) BLE_TRSPS_SendVendorCommand(conn_hdl 0x8F 0x01 offCmd); } break; Add the include file needed for the above BLE API's in app_zigbee_handler c #include \"app_ble_handler h\" #include \"ble/profile_ble/ble_trsps/ble_trsps h\" 2 Send data over ZIGBEE (app_trsps_handler c) When the On/Off single byte data is received from mobile app using Transparent service change the global variable which holds the On/Off attribute value On/Off attribute data is sent periodically at defined MAX interval to CI When the On/Off attribute value is changed by BLE an additional report will be sent at MIN report interval with the changed value The reporting interval is configured in auto generated Zigbee middleware include file firmware src config default zigbee z3device light include lightOnOffCluster h (unit in seconds) /****************************************************************************** Definition(s) section ******************************************************************************/ #define ONOFF_VAL_MIN_REPORT_PERIOD 30 #define ONOFF_VAL_MAX_REPORT_PERIOD 120 When the non zero value is sent from mobile app using TRPS Ctrl pt characteristic the LED is switched ON and for zero value LED is switched OFF in BLE_TRSPS_EVT_VENDOR_CMD event callback Add the below code to update the On/Off attribute Value and to change RED LED Status ZCL_ReportOnChangeIfNeeded() API is called to initiate the additional report at ONOFF_VAL_MIN_REPORT_PERIOD interval lightOnOffClusterServerAttributes onOff is the global variable defined in Zigbee middleware which holds the OnOFF attribute value void APP_TrspsEvtHandler(BLE_TRSPS_Event_T *p_event) { switch(p_event- eventId) { case BLE_TRSPS_EVT_VENDOR_CMD: { /* TODO: implement your application code */ if(p_event- eventField onVendorCmd length) { if(p_event- eventField onVendorCmd p_payLoad[1]) { lightOnOffClusterServerAttributes onOff value = 1; RED_LED_Set(); appSnprintf(\"[BLE} On Command n r\"); } else { lightOnOffClusterServerAttributes onOff value = 0; RED_LED_Clear(); appSnprintf(\"[BLE} Off Command n r\"); } ZCL_ReportOnChangeIfNeeded( lightOnOffClusterServerAttributes onOff); } } break; Add the include file needed for the above ZIGBEE API and GPIO in app_trsps_handler c #include app_zigbee/zigbee_console/console h #include z3device/light/include/lightOnOffCluster h #include \"peripheral/gpio/plib_gpio h\" Note: The sample project with all the above code changes is available in ble_zigbee_basic for your reference Programming the Application using MPLABX IDE Build the project after doing all the above changes and program on Curiosity board Program the combined interface hex image on another curiosity board for Zigbee gateway by following below steps Programming the precompiled hex file using MPLABX IPE Precompiled Hex file is located here Follow the steps mentioned here Program the combined interface hex image on another curiosity board for Zigbee gateway by following same procedure Caution: Users should choose the correct Device and Tool information Testing This section assumes that user has already programmed multiprotocol Application Example and combined interface example on 2 WBZ451 Curiosity boards  Demo Experience when using a Smartphone (MBD App) as Central Device Reset the Combined Interface programmed WBZ451 Curiosity board Open Terminal emulator like Tera Term select the right COM port@ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none enable CR+LF for RX TX in Terminal setup) send command: resetToFN and look for the below logs for successful zigbee network formation on CI Reset combo device and send command: resetToFN Look for combo device joined with combined Interface The on/off light cluster search and binding between 2 devices is successful and combo device on/off light attributes reports are seen in CI This would take about 180sec Open Microchip Bluetooth Data (MBD) App on your smartphone Search and select the advertisement with Device Name \"Combo\" Connect with the combo device Enable Notify/Indicate to receive data from combo device Write 8F01 to switch on RED LED and look for on/off attribute value changing to 0x01 in CI and also RED LED is getting ON Similarly write * 8F00 to switch off RED LED and look for attribute value changing to 0x00 in CI As mentioned previously it would take MIN report interval for the changed report value to appear in CI By sending on/off command from CI the RED LED can be switched On/Off The value can be seen in MBD app as well The network address of the combo device is needed to send light control commands to combo device from CI This network address can be got from Combined interface console log while joining was done Another way to get the network address from combo device is executing the below command in combo light side Command: getNetworkAddress Response: 9bfa On/off command: onOff 0x0 0x9bfa 0x20 -on onOff 0x0 0x9bfa 0x20 -off 0x20 is zigbee end point number used for light can be taken from MCC configurator Where to go from here Advanced Multiprotocol Application with Zigbee Provisioning over BLE by following the similar implementation The guide also explains the wrapper protocol written on top of BLE Transparent service for BLE provisioning and light control The on board RGB colour is controlled in this example which can be referenced for PWM functionality ",
							" Multiprotocol Application Demo: Zigbee light and Zigbee commissioning through BLE WBZ451 Curiosity Board Devices (Device): | PIC32CX1012BZ25048 (MCU) on WBZ451 module | Devices (Used On-Board): | Analog Temperature Sensor | RGB LED | User Button | User LED | UART-USB Converter | BLE-Top Hardware Block Diagram - Curiosity Board BLE-Mapped Hardware Required  Tool  Qty WBZ451 Curiosity Board** 2 Micro USB cable 2 Android/iOS Mobile 1 Amazon Echo Plus** 1 **Amazon Echo Plus acts as gateway / WBZ451 curiosity board programmed with “Combined interface” example if Echo Plus is not available Software  TeraTerm Smartphone App Microchip Bluetooth Data (MBD) iOS/Android app available in Stores Alexa App installed on android/iOS mobile phone if Amazon Echo plus is used as Gateway Demo Description This application demonstrates the multi-protocol (concurrent operation of both Zigbee and BLE stacks) functionality of PIC32CXBZ2 family of devices and modules The Zigbee commissioning over BLE uses Bluetooth Low Energy (BLE) link to exchange Zigbee commission data and run both Zigbee and BLE tasks simultaneously under FreeRTOS The local zigbee lights (on board RGB LED) can be controlled over BLE or from Zigbee network Multi-protocol can also be referred as \"combo\" for ease of readability in this doc BLE light control (Zigbee device is not yet commissioned): If the combo device is not yet commissioned and not connected to Zigbee network still would be able to control the RGB LED through BLE using “BLE sensor” sub app of MBD (Microchip Bluetooth Data) mobile app Zigbee device commissioning: By connecting the device to the “BLE provisioner” sub app of MBD mobile app the Zigbee part of combo device can be commissioned and brought to the existing zigbee network or can create new zigbee network (if there is no nearby network) Zigbee local light control (Zigbee device is commissioned): Combo light RGB LED can be controlled from Zigbee Gateway of the same network RGB LED can also be controlled through BLE using \"BLE sensor\" MBD app When the light status is changed from BLE the light change report will be sent to zigbee gateway through Zigbee communication When the light status is changed from zigbee gateway through Zigbee communication the light status will be notified to \"BLE sensor app\" if it is connected Any third-party gateway like Amazon Echo Plus can also be used as Zigbee Gateway If Amazon Echo plus is not available one of the WBZ451 Curiosity board can be programmed with Combined Interface pre-compiled image which acts as zigbee gateway Amazon Echo Plus Gateway as well as WBZ451 Curiosity based Combined Interface Gateway solutions are explained in the following demo steps Programming the precompiled hex file or Application Example To run the demo we would need a zigbee network formed by co-ordinator/zigbee gateway Any third-party gateway like Amazon Echo Plus can also be used as Zigbee Gateway If Amazon Echo plus is not available one of the WBZ451 Curiosity board can be programmed with Combined Interface pre-compiled image which acts as zigbee gateway Amazon Echo Plus Gateway as well as WBZ451 Curiosity based Combined Interface Gateway solutions are explained in the following demo steps To run the demo using Combined Interface as gateway we need 2 devices One is the Combined Interface and the other is combo light One of the WBZ451 Curiosity board is programmed with Combined Interface which can act as Zigbee Gateway/Coordinator Program the CI pre-compiled hex image by following steps on one curiosity board Another WBZ451 Curiosity board is programmed with combo light application which can act as Zigbee Router Follow the below step for programming combo light application on another curiosity board Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps multiprotocol ble_zigbee_light_prov precompiled_hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"ble_zigbee_light_prov x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps multiprotocol ble_zigbee_light_prov firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path On-board Resource Usage  Sensor  Peripheral Used  I/O Pin  Comment LED Control TC2 (WO0 WO1) TC3 (WO0) in PWM Mode PB0 PB3 PB5 RGB LED color control Switch EXTINT0 PB4 SW1 button in curiosity board to do Reset To Factory new Temperature Sensor ADC PB6 Read the room temperature from the MCP9700A sensor available in curiosity board Timer RTOS Systick Timer Periodic timer functionality to initiate the sensor read operation and for Adv User LED control User LED GPIO PB7 User LED in curiosity board To indicate BLE advertisement/connect status Demo Steps Hardware Software Setup Supply power to WBZ451 Curiosity Board consisting of Combo light application by connecting a USB cable Power Supply (PS) Green LED will turn on when connect to PC The application activity is shown as \"Console Log\" through on board UART-USB converter Open Terminal(eg: Tera Term) with the setup as shown below to look for these logs On the PC side virtual COM port connection that corresponds to the board shall have following settings: BAUD RATE: 115200 (as configured in SERCOM configuration) PARITY: None DATA BITS: 8 STOP BITS: 1 FLOW CONTROL: None Additionally local echo and sending line ends with line feeds shall be enabled in the PC serial terminal application Demo Steps: commissioning The combo light can be connected to any zigbee gateway The steps explained in Discovery of Combo Light from Amazon Echo Plus can be followed if Amazon Echo Plus acts as Zigbee gateway available The steps explained in Discovery of Combo Light from WBZ451 Combined Interface (CI) gateway can be followed for WBZ451 based combined interface acts as Zigbee gateway Discovery of Combo Light from Amazon Echo Plus Voice Commands: Open Alexa to discover the Light device Say “Discover my devices” or  Alexa App: Launch Alexa app from the menu select the Add Device Select the type of smart home device “Light” and select \"Other\" Initiate Discover Devices Input command : resetToFN on light device The Light will be discovered and shown as light in Alexa app as shown below Echo Plus is in discovery mode for 45 secs Devices (Lights/other) wanting to join Echo Plus should initiate joining/connecting procedure within this time limit for a successful join Discovery of Combo Light from WBZ451 Combined Interface (CI) gateway Supply power to another WBZ451 Curiosity Board which is programmed with Combined interface image by connecting a USB cable Power Supply (PS) Green LED will turn on when connect to PC Follow step 2 of Hardware Software Setup for UART terminal Setup Send command: resetToFN and look for the below logs for successful zigbee network formation on CI CI will open up the network for other zigbee devices to join for first 180sec from the first powerON If commissioning of combo light is initiated after this 180sec combo light will not get joined This is same as Alexa saying \"Discovering and put the device is pairing mode\" To open up the network after 180sec send the below commands in CI before commissioning is initiated in combo device setPermitJoin 180 - This command opens up the network for next 180sec invokeCommissioning 8 0 - This command opens up the network for \"finding and binding procedure\"  Connecting Combo Light to Zigbee Gateway (Echo plus or combined interface) through BLE commissioning Launch MBD Microchip Bluetooth Data app from mobile Open \"BLE Provisioner\" sub app and scan for the devices The device name \"COMBO_LIGHT_XXXX\" is seen when Scanned from mobile app 'XXXX' is a unique number associated with this combo device Connect to device and follow the below screenshots for the commissioning procedure Observe that the Blue \"User LED\" will be solid On when device is connected to mobile app Observe that RGB LED will be blinking when the device joins/forms a network at the interval of 1sec for next 180sec This indication is required as per zigbee specification The combo light is configured with default primary channel mask (11 15 20 25) as per zigbee specification The channel configuration from mobile app is needed only when the Gateway channel is not in any of the default channels Tips: If commissioning procedure does not find the nearby network (eg: Echo Plus) try to find the channel of the network and configure the same channel while commissioning ---- When the combo light is joined to an existing network/formed its own network the device state can be seen as \"Commissioned\" Success log on combo light when commissioned with Echo plus Success log on combo light when commissioned with Combined Interface Status messages during commissioning: Below status messages can be observed during the commissioning procedure based on the conditions Device Joined to an existing network Device formed its own network When the commissioning procedures is initiated the combo device search for any nearby network to get joined If it does not find any network then it form its own new network since Zigbee light has the capability of forming its own distributed network Fail Status -Commissioning has failed (Did not join/create own network)  Other Features in \"BLE Provisioner\" App Info page shows some useful information like device type current channel device IEEE address and device state (Commissioned Not-Commissioned) Device name can be changed to any user preference name While the device is scanned from MBD app this device name will be seen in the scanned list The name can be changed irrespective of commissioning state Re-Commissioning : If the combo light already joined to a network and wanting to recommission to new network the current networking related information to be deleted from NVM (Non volatile memory) Connect the combo device from \"BLE Provisioner\" app and press on \"FACTORY RESET\" This will delete networking information and the device will reset Connect with combo light again and do the commissioning by following the steps 3 and 4 If the combo light was joined to an Echo Plus previously remember to remove the light info from Alexa app before initiating the recommissioning Demo Steps: Light Control RGB LED on WBZ451 curiosity board is tied with Zigbee and BLE functionality The LED color and brightness can be changed through Zigbee network as well as from mobile app through BLE The RGB color is synced with both Zigbee and BLE network RGB color control from MBD \"BLE Sensor\" mobile app Launch MBD Microchip Bluetooth Data app from mobile Open \"BLE Sensor\" sub app and scan for the devices The device name \"COMBO_LIGHT_XXXX\" when Scanned from mobile app Connect to device and follow the below screenshots for the light control Observe that the Blue \"User LED\" will be solid On when device is connected to mobile app The BLE Sensor mobile app will show the temperature (deg C) and LED status received from device as well as allow the user to vary the RGB color and brightness ---- ---- ---- ---- RGB color control from Alexa Either through voice commands like \"Alexa Turn on my first light\" \"Alexa Change color of my first light to \"GREEN\"\" \"Alexa increase the brightness of my first light\" or from Alexa app the RGB LED can be controlled through Zigbee network When the color is changed from Alexa if combo light is connected with \"BLE Sensor\" mobile app the changed color can be seen in mobile app as well If color is changed from \"BLE Sensor\" it will be reflected in Alexa app There may be delay in syncing since it depends on read attribute request from Alexa as explained in the below note and hence expect max 20sec of delay Echo Plus does the zigbee binding only for On/Off and Level Control Clusters The color control cluster binding is not done from Echo Plus Also Echo Plus send the configure reporting command to combo light to disable periodic reporting of light attributes Hence combo light will not report periodically Instead Echo plus send the read attribute command to combo light every ~20sec and get the light values Also the read attribute command for color values will start only when the first color change is initiated from Alexa Hence it is required to do first color change from Alexa before changing from BLE sensor app for color synchronization to take place When the LED color is controlled from Alexa there are 2 color control options available One is temperature color control (SHADES of WHITE in below figure) and another is HueSaturation (colors in below figure) color control BLE light is synced only for HueSaturation color control So if the color is changed for temperature color control the RGB LED will be changed but the values will not be updated on BLE app ---- ---- RGB color control from Combined Interface The RGB color can be controlled from Combined Interface through console commands Similar to Alexa when the RGB color is changed from Combined Interface will be reflected in \"BLE Sensor\" app if connected Changing from \"BLE Sensor\" app will be seen in next received report in combined Interface The network address of the combo light is needed to send light control commands to combo light This network address can be got from Combined interface console log while commissioning was done Or the network address can be got using below command on the combo light device Command: getNetworkAddress Response: f088 0x23 in the below commands is zigbee end point number used for light RGB LED On/off command onOff 0x0 0xf088 0x23 -on onOff 0x0 0xf088 0x23 -off RGB LED brightness change command moveToLevel 0x0 0xf088 0x23 0x45 0x0 0x1 0x0 0x0 0x45 is the configurable brightness value RGB LED color change command moveToHueAndSaturation 0x0 0xf088 0x23 0x45 0x67 0x0 0x0 0x0 0x45 and 0x67 are the configurable Hue and Saturation values Demo Steps: Other Features On board button actions: When the on board \"User Button ( SW2 )\" is pressed for more than 10sec it can delete all the networking information and will bring the device to factory default state GREEN LED will be ON for a short time to indicate the successful factory reset state When the on board \"User Button ( SW2 )\" is pressed for more than 5sec it can start the commisioning procedure if not already commisioned This is same as \"BLE provisioner\" mobile app initiating the commisioning procedure Persistent Data Storage (PDS): The RGB light status (On/Off) and brightness values are stored in NVM So power off/on of combo light these values persist and RGB LED will reflect accordingly This PDS storage is tied to zigbee network Combo device is not yet commissioned: Light values are not stored in NVM in this Scenario So power Off/On the light values will default to Off Status and default color (white HSV = 0 0x7F 0x7F) Combo device is commissioned: The light On/Off status and light brightness is being stored in non-volatile memory in this case So power off/on the LED will be updated with light on/off and brightness values retrieved from previous transaction Extended Fucntionalites This application also implements device firmware over BLE link (Over-The-Air upgrade) and Serial device firmware upgrade through serial UART interface BLE DFU: Refer to Device firmware update over BLE for details on code configuration and running OTA demo procedure Serial DFU: Refer to Device firmware update over serial for details on upgrading the device over serial interface Protocol Exchange The communication protocol exchange between BLE Provisioner mobile app/ BLE sensor mobile app (BLE central) and WBZ451 module (BLE peripheral) is explained here ",
							" Multiprotocol Device Firmware Upgrade over BLE Link  The multiprotocol device firmware can be upgraded through Bluetooth Low Energy link The BLE OTA profile service and the exchange between BLE OTAU Target device and OTAU Manager (Mobile app) are same as BLE only device  Zigbee light with BLE application is the sample project which implements OTA over BLE link The current image \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps multiprotocol ble_zigbee_light_prov precompiled_hex ble_zigbee_light_prov X production signed unified_1 0 0 0 hex\" with OTA capability and new upgrdable bin (ble_zigbee_light_prov_1 0 0 1_ota bin) is also available in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps multiprotocol ble_zigbee_light_prov precompiled_hex\" for your reference  Follow the steps as explained in Device Firmware Upgrade Over BLE for upgrading the multiprotocol device using BLE link  ",
							" Zigbee commissioning through BLE - Protocol Exchange  Protocol Exchange  The communication protocol exchange between BLE Provisioner mobile app/ BLE sensor mobile app (BLE central) and WBZ451 module (BLE peripheral) is explained here  1 Advertising Beacon:       Advertisement Data:    Service UUID: 16-bit Service UUID 0xFEDA is purchased by Microchip from Bluetooth SIG    Other Info: 0x40+Light ON/Off status (1 Byte)+ 0x41+Temperature data (2 bytes)      Scan Response Data:    The device name is part of the scan response Device name is set as \"COMBO_LIGHT_XXXX” by default (XXXX means the last two bytes of the device address) This device name can be changed using \"BLE Provisioner\" app as described in demo step #5      Transparent Profile and Service (TRP/TRS) is the proprietary BLE service by microchip to establish data and control channel between BLE Central (Phone) and Peripheral (device)       Transparent Profile (TRP) enables higher layer application to control and allow data exchange between TRP Client and Server devices    Transparent Service (TRS) includes both Ctrl and Data Pipes which are custom 128-bit GATT characteristics    The Transparent Server shall be a GATT Server    The Transparent Client shall be a GATT Client   Definition of Transparent Service and Characteristics UUID's          Characteristic Name  UUID  Properties      TRS Service  49535343-FE7D-4AE5-8FA9-9FAFD205E455      TRS TxD- Tx Data to Client role (Data pipe)  49535343-1E4D-4BD9-BA61-23C647249616  Notify Write    TRS TxD - Client Characteristic Configuration Descriptor    Read Write    TRS RxD- Rx Data from Client role (Data pipe)  49535343-8841-43F4-A8D4-ECBE34729BB3  Write Write without response    TRS Ctrl Pt - Command and Response (Ctrl pipe)  49535343-4C8A-39B3-2F49-511CFF073B7E  Notify Write Write without response    TRS Ctrl Pt - Client Characteristic Configuration descriptor    Read Write          3 \"BLE Sensor\" and \"BLE Provisioner\" Application over Transparent Service Control Point (TRS Ctrl Pt):  The combo application uses TRS Control Point Characteristic of TRPS profile to exchange data between \"BLE Sensor\" and \"BLE Provisioner\" mobile app and device     The combo application follows the below protocol format on TRS control point characteristic           Item  Opcode  Length  Sensor/Provisioning/Control ID  Payload      Size  1 Byte  1 Byte  1 Byte  Variable      The description of each element is as below:  - The Opcode: - (0x81) is fixed 1 byte in size and related to Provisioning commands - (0x8A) is fixed 1 byte in size and related to BLE Sensor/Control commands - Length: 1 byte in size (size of Sensor/Control ID + size of Payload) - The Sensor/Control ID: 1 byte in size It could be divided into Control request Control response Sensor/Provisioning notify data described in detail in following sections - The Sensor/Provisioning/control data and payload size depends on the ID as listed in the below table   BLE sensor specific control and sensor command/response                 Control Cmd    Opcode    Control Request ID    Parameter    Parameter Length (Byte)    Control Response ID    Control Response Payload    Control Response Payload Length (Byte)    Description       RGB LED On/Off Set  0x8A  0x10  On/Off  1  0x20  Status code  1  Switch On/Off the RGB LED with the default/last set color    RGB LED On/Off Get  0x8A  0x11      0x21  Status code + On/Off status  2  Send the RGB LED on/off status    RGB Color Set  0x8A  0x12  Color value (HSV)  3  0x22  Status code  1  Set RGB color value in HSV format    RGB Color Get  0x8A  0x13      0x23  Status code + RGB color value  4  Send RGB color value in HSV format     Sensor Data            Sensor ID    Parameter    Parameter Length (Byte)    Description     RGB LED On/Off status  0x8A        0x40  On/Off status  1  RGB LED On/Off Status    Temperature data  0x8A        0x41  Temperature sensor data  2  Temperature value in Celsius with 0 1 resolution The MSB bit will be set when the negative temperature is reported    RGB Color Values  0x8A        0x42  RGB Color Values  3  RGB color values in HSV Format       BLE Provisioning specific control and command/response                 Commissioning Cmd    Op Code    Commission Request ID    Parameter    Parameter Length (Byte)    Commission Response ID    Commission Response Payload    Commission Response Payload Length (Byte)    Description       GetDeviceType  0x81  50      A0  Device Type  2  Get Zigbee device type (Device type see table 8)    GetSWVersion  0x81  51      A1  Software Version  Up to 16 bytes  Get Software Version    SetDeviceName  0x81  52  Device Name  Up to 16 bytes  A2      Get Network State    GetDeviceName  0x81  53      A3  Device Name  Up to 16 bytes  Get Device State    SetChannelMap  0x81  54  Channel map  4  A4      Set Zigbee channel bit map    GetChannelMap  0x81  55      A5  Channel map  4  Get Zigbee channel bit map    GetDeviceState  0x81  56      A6  Device State  1  Set Zigbee MAC ID    GetMACID  0x81  57      A7  MAC ID  8  Get Zigbee MAC ID    GetCommisionStatus  0x81  58      A8  commissioning Status  1  Get commissioning Status    GetCurrentChannel  0x81  59      A9  Current Channel  1  Get Zigbee install code    StartCommission  0x81  5E      AE      Start Commission    ResetFactoryNew  0x81  5F      AF      Reset to Factory New state     Commissioning Cmd            Commission Response ID    Commission Response Payload    Commission Response Payload Length (Byte)    Description     commissioningStatus  0x81        60  commissioning Status  1        3 1 Control Command Request and Response  The Control command request is used by mobile app to send the command to device The control request channel is opened only after Client Characteristic Configuration Descriptor of TRS Ctrl Pt Characteristic notification is enabled; it is closed when such notification is disabled  The format of Control command is an 8bit Opcode an 8bit request ID followed by optional control payload   Format of Control Command             Item   Op Code  Length  Control Request ID  Control Payload       Size (Octet)   1  1  1  Variable      The control response is used by the device to send feedback to mobile app The format of Response is an 8bit Opcode an 8bit response ID and response status followed by optional Response payload   Format of Control Response Data              Item   Op Code  Length  Control Response ID  Status  Control Response Payload       Size (Octet)   1  1  1  1  Variable      Status code 0x00 means successful execution of control command Any status code other than 0x00 means error code as shown in below Table An error status does not have optional control Response payload   Definition of Status Code           Status Code    Definition    Description        0x00   Success  Response for successful operation     0x01   Op Code Not Supported  Response if unsupported Op Code is received     0x02   Invalid Parameter  Response if Parameter received does not meet the requirements of the service     0x03   Operation Fail  Response for fail operation     0x04-0xFF   Reserved for Future use       3 2 Sensor/Provisioning Notify Data  The Sensor data is sent to mobile app periodically by WBZ451 device Similarly the commissioning status is sent to \"BLE provisioner\" during the commissioning procedure The data channel is opened only after Client Characteristic Configuration Descriptor of TRS Ctrl Pt notification is enabled; it is closed when such notification is disabled  The format of sensor data is an 8bit Opcode an 8bit ID followed by notify data payload   Format of Sensor/Provisioning Data             Item   Op Code  Length  Sensor/Provisioning ID  Sensor/Provisioning Payload       Size (Octet)   1  1  1  Variable       Application Flow Diagram        ",
							" BLE ZigBee Provisioning Low Power Application Demo: Zigbee Multi-Sensor and Zigbee commissioning through BLE This tutorial will help users to create a low power enabled multiprotocol (BLE+ZIGBEE) example project using Mplab code configurator The step by step procedure will help the user to generate a Zigbee Multi-Sensor application and commission the Multi-Sensor to a Zigbee network through BLE from scratch Hardware Required  Tool  Qty WBZ451 Curiosity Board 1 Micro USB cable 1 Android/iOS Mobile 1 SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Smartphone App Microchip Bluetooth Data (MBD) iOS/Android app available in stores Demo Description This application demonstrate the Zigbee Multi-Sensor end device joining to Zigbee Coordinator (Combined Interface The thirdparty gateway's like Amazon Echo plus can also be used instead of CI ) by receiving the commissioning parameters from user using a mobile phone through BLE Link The mobile application uses Microchip Proprietary Transparent Service to send and receive data PIC32CX-BZ2/ WBZ451 device The BLE provisioner in the MBD App (available in Google Play Store and Apple Store) is utilized to demo the provisioning functionality Developing this Application from scratch using Mplab Code Configurator The following steps will help to understand the PIC32CXBZ2 device ZIGBEE and BLE stack programming structure Ensure that wireless_system_pic32cxbz2_wbz45 repo is available locally as documented in Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Following are recommended steps Pull-in H3 Components Create a new MPLAB Code Configurator Project -- link for instructions Open MPLABx Code Configurator The Wireless System Service components will be displayed in available components Select BLE ZIGBEE PROVISIONING from Device Resouces -- Wireless -- System Services as shown in the below figure Accept all dependencies by selecting \"Yes\" Click on the Zigbee Device dependency on the BLE ZIGBEE PROVISIONING select MultiSensor The project graph will appear as shown in the figure below Select the Multi Sensor Zigbee device component by click on the component in the project graph Now the Configuration Options tab will list the Configurations for the selected Zigbee device Ensure that the Manual Configuration is selected and Network Formation Commissioning Enable and AUTOMATIC COMMISSIONING ON STARTUP is deselected as shown in below figure Select the BLE Stack component by clicking on the component In the Configuration Options tab Expand Generic Access Profile (GAP) -- Advertising and then expand Advertising Data and Scan Response Data In Advertising Data menu ensure that Local Name is deselected and selected in Scan Response Data -- Local Name In Advertising Data menu ensure that Service Data is selected Service UUID is selected as 0xFEDA and Service Data is set as 0xFF03 as shown in below figure Note : 0xFEDA is a 16-bit Service UUID which is purchased by Microchip from Bluetooth SIG In order to list the device while scanning in Microchip Bluetooth Data (MBD) mobile application the device should advertise with Service UUID as 0xFEDA and Service Data as 0xFF03 Low power Configuration Enable Sleep Mode in BLE stack H3 component configuration after enabling this dependent component like RTC (Timer source during sleep) will be requested to be enabled For Zigbee applications the System Sleep mode is only enabled when using the following device types - Multisensor Intruder Alarm System and Color Scene controller as per the Zigbee End Device Spec There is no separate configuration that a user has to select to enable the System Sleep like for BLE Sleep Upon enabling sleep mode FreeRTOS related settings will be set automatically Tick Mode will be set to Tickless_Idle Expected idle time before sleep will be set to 5 (ms) Tick Hook will be enabled (For user to add any custom code needed to be executed within each tick interrupt) RTC peripheral library will be added and configured Note: RTC counter should not be reset (RTC_Timer32CounterSet()) arbitrarily when the system is running RTC clock source should be set manually there are 4 options to choose from FRC (±1% offset) LPRC ( with larger offset ±5%) POSC - Candidate of the clock source (better clock accuracy) SOSC - Candidate of the clock source (better clock accuracy) Users can select POSC or SOSC as the RTC clock source Choosing FRC and LPRC as clock sources for RTC will impact BLE connection stability In this example SOSC is configured as RTC clock source In Mplab Code Configurator Click Plugins select \"Clock Configuration\" from drop down menu In Clock Diagram Enable Secondary Oscillator (SOSC) by setting SOSCEN to ON Select SOSC as clock source for VBKP_32KCSEL and set LPCLK_MOD to DIV_1_024 as hown in below below All Unused pins in the application needs to be set in input mode and the pulldown should be enabled for these pins This can be configured inside ports available in system component confguration options The Pin PB5 functionality should be changed to GPIO to disable the JTAG functionality for reduced power consumption The PMU mode can be set to BUCK_PWM mode to attain less power consumption and the settings is available as part of Device Support as shown in the figure Below BLE Zigbee Provisioning Manual Code Configuration Open app c file and include the header file app_prov h as shown in below figure #include \"app_prov/app_prov h\" In app c Add the following code after APP_BleStackInit() in APP_Tasks function APP_Prov_TRPS_Init(); Open app_ble_handler c file located in app_ble project folder In APP_BleGapEvtHandler() function add the below code as shown in figure extern void APP_BleGapConnEvtHandler(BLE_GAP_Event_T *p_event); APP_BleGapConnEvtHandler(p_event); Open app_trsps_handler c file In APP_TrspsEvtHandler() function add the below code as shown in figure extern void APP_TRPS_EventHandler(BLE_TRSPS_Event_T *p_event); APP_TRPS_EventHandler(p_event); Open app_zigbee_handler c file located in app_zigbee project folder In Zigbee_Event_Handler() function add the below code as shown in figure extern void BZ_Prov_Zigbee_Event_Handler(APP_Zigbee_Event_t event); BZ_Prov_Zigbee_Event_Handler(event); Open app_user_edits c file Comment out or remove the #error line Update the freertos_hooks c as mentioned in app_user_edits c file Compile and Run the project in WBZ451 Demo Steps: commissioning To Commission the Zigbee Multi-Sensor device follow the step mentioned here Protocol Exchange The communication protocol exchange between BLE Provisioner mobile app and WBZ451 module (BLE peripheral) is explained here ",
							" Getting Started with IEEE 802 15 4 P2P Phy Application  This document provides setup details and configuration for P2P PHY Application This is an application built on top of Standalone IEEE 802 15 4 PHY layer It enables two PIC32CXBZ2 devices to communicate and exchange data wirelessly The application receives the data from UART and sends them over the air and similarly send the data to UART which is received by the transceiver  ",
							" Reference Documentation    Standalone 802 15 4 PHY API Guide  WBZ451 Curiosity Board User Guide  IEEE Std 802 15 4™-2006    ",
							" Software Requirements   Software Tools:       Software Tools Device Specific Support Packages  Version      MPLAB X IDE  v6 05    PIC32CX-BZ2 DFP( WBZ451 )  v1 1 218    XC32 COMPILER  v4 20    MCC (Plugin in MPLAB X IDE)  v5 2 2    MCC Core (Plugin in MPLAB X IDE)  v5 4 14    Harmony 3 Lib (Plugin in MPLAB X IDE)  v1 2 0      H3 FRAMEWORK Dependencies:  H3 Framework Packages       Package Name  Version      csp  v3 13 1    bsp  v3 13 0    core  v3 11 1    dev_packs  v3 13 0    CMSIS-FreeRTOS  v10 3 1    mhc  v3 8 3    wireless_pic32cxbz_wbz  v1 1 0    wireless_15_4_phy  v1 0 0    wireless_system_pic32cxbz_wbz  v1 2 0    wireless_apps_pic32cxbz2_wbz45  v1 2 0        The Package versions mentioned in the above tables are minimum required dependencies    The working application demo and precompiled hex is available in wireless_apps_pic32cxbz2_wbz45 repo v1 2 0 which can be directly flashed to the WBZ451 for reference purpose    ",
							" Hardware Requirements         Hardware Components  No of Items Required (minimum)      WBZ451 Curiosity Board  2    Micro USB Cable  2      ",
							" Creating a New MCC Harmony Project    Create a new 32-bit MPLAB MCC Harmony Project  MCC project creation    MCC project creation    Select the Framework Path (Framework path must match H3 Framework Dependencies listed in Software Requirements section) and select Next   MCC project creation    Choose Project Folder location name and select Next   MCC Project creation    Select the device and click Finish  Device Family and Target Device options can be selected as per the user preference (if the corresponding device is supported by the application) Here the application is demonstrated with WBZ451 device  MCC project creation    MPLABx Code Configurator will be launched automatically  Select \"Next\"  MCC Project Creation    Select \"MPLAB Harmony\"   MCC project creation    Select \"Finish\"   MCC project creation    If the H3 Framework folder is created for the first time then the H3 framework dependency packages listed under software requirements section needs to be downloaded installed Those packages will be available under optional content as in the following figure The checkbox should be selected and installed  H3 Framework     Project Graph window of the Configurator may have predefined components  MCC Project Creation    Select the P2P PHY APP under Project and Device resources under “Wireless/System Services/” tab All the necessary components will be auto populated Accept all Dependencies or satisfiers by selecting \"Yes\"  MCC Project Creation - project graph    MCC Project Graph    MCC Project Graph    After the auto population of all the components the following dependencies needs to be selected manually  CONSOLE component should be manually connected to its consumer SYS COMMAND   MCC Project Graph    CONSOLE component should be connected to it's dependency component SERCOM0 UART  SERCOM 0 UART is specific to WBZ451 curiosity board other SERCOMs can be selected as per the device selection  MCC Project Graph    Dependencies like timer for IEEE 802 15 4 PHY component needs to be added (explained in API guide/user guide for the PHY component)  MCC Project Graph      The following image shows the complete graph required for the application generation Verify if the Project Graph window has all the expected MCC configurations  MCC Project Graph      The following figure shows the steps for configurations to be done prior to project generation  System and FreeRTOS Configuration  MCC Project Graph    MCC Project Graph     SERCOM0 PAD configuration  MCC Project Graph      SYS CONSOLE BUFFER configuration can be chosen as per user preference (recommended to have max value possible)  MCC Project Graph     P2P PHY APP component configuration options (can be modified as per user preference)  MCC Project Graph       Generate Code by Following Instructions here    Files and Routines Automatically generated by MCC  MCC Project code Generation    MCC Project code Generation    After generating the code from MCC tool by clicking Generate below is the project folder structure   MCC Project code Generation    The following code snippet shows modifications that need to be added in MCC generated files (lines to be modified are highlighted)    tasks c file Add the following modifications in tasks c file in the places highlighted in the following figures TaskHandle_t xSYS_CMD_Tasks;  Application edits    Application edits   The above modifications need to be done manually for H3 repos using Core package version 3 12 1 or below For the next release version of Core these changes will be automatically generated  Change argument of SYS_Load_Cal() function to WSS_ENABLE_ZB in initialization c file (This is mandatory for using the PHY library component)  Application edits        User Application Development  Compile MCC auto generated project as shown in following figure  user edits    Addressing the mandatory error: User action required in app_user_edits c Click on the error message in the output window it will redirect to app_user_edits c file Follow the steps mentioned in the app_user_edits c and do the necessary changes Then comment the #error message as below Refer here for more details  user edits       Build the project after doing all the above changes and program on Curiosity board  Clean and Build MPLAB Project    Program/Flash the firmware to Device      P2P PHY Application MCC Configurations  Harmony3 based P2P PHY Application framework allows user to do different configurations and generate the code based on that configurations  Application Configuration  Application/PHY specific configurations like channel source short address ieee address etc can be configured here IEEE 802 15 4 PHY supports 16 channels (channel 11 to 26) in 2 4GHz frequency band These configuration changes are reflected in app_p2p_phy_config h file  Application configuration file          ",
							" Operating Modes   In this userguide the TeraTerm is used for providing Console inputs On the Menu bar of Tera Term Goto setup select serial port and then set the baud rate to 115200 as shown in the following figure  Tera Term Settings    Flash the application to WBZ451 board after build is succesful (as described here ) The P2P application requires 2 devices where the source address of peer device 1 is the destination address of peer device 2 and vice versa The source address and destination address can be modified in app_p2p_phy_config h file as well as via MCC Project graph configuration Window as shown here   Once the firmware is flashed to the WBZ451 board the following print will appear in console window (here Tera Term is used) Specific commands (detailed description and reference available in Command Table Description section) should be given to switch between different application modes (explained in detail in the following section)  The additional Tera Term settings should be followed as per the following figure  Console Settings      The following figure shows the simple flow diagram on the high level process flow from application level to PHY level  Application FlowChart      The P2P PHY application has 2 source files:  app_phy_cmd_processor c which is an interface between console and app/phy layer  app_p2p_phy c which is an interface between user command via console and Phy layer     The application features 5 modes  Data Mode – It is basic chat feature where once user enters bytes it will appear on the peer device console User can give time period as well where the timer starts once the user starts to enter first byte of data Even if the user did not press enter once the timer expires the data will be sent automatically  Data format can be given in format xx :data where xx is device index (for example: 01 :Microchip - 01 specifies Device table index and Microchip specifies user data ) and actual data comes after “:”  Data Mode Example    The data can also be sent without any index in such scenario the data will be sent to device details (address) stored in index 1 of the device table If the info in index 1 of the device table is not valid then the data will be broadcasted  For Broadcasting data format is ff :data (Example : ff :Microchip)  The device table can be updated with short address and ieee address as per user preference using the console command updateDeviceTable Commands supported in the application are described in COMMAND TABLE section   To enter data mode +++ time(in microseconds) should be given in console User input can be provided through console in Data Mode only In all the test modes the payload data is defined in the application Data Payload Modifications should be done in the application if required Max payload limit in data mode is 232 bytes (due to Fragmentation of payload feature in application) As per IEEE 802 15 4 Spec Max payload size is 127 octets = 116 octets + Max possible Frame Overhead In App Fragmentation 116 x 2 = 232 octets + Max possible Frame Overhead = 254 Octets  The following figure show the operation of device in data mode which is accessible using the cmd +++ time (in microseconds)   Data Mode    To exit Data Mode  command should be given in console Once exit from data mode Device performance parameters like Packet error rate no of bytes sent will be displayed  Exit Data Mode     Continuous Test Mode – Predefined payload of 116 bytes is set in application Each packet with 116 bytes is sent one by one after the previously sent packets received ack from the peer device Max payload size of 116 is set as an example  To enter Continuous Test Mode the command contTestMode need to be given in the console  Continuous Test Mode     Periodic Test Mode --- User can provide a time as input After periodic expiry of the user configured time the predefined payload of 116 bytes will be sent to peer device Once the tx is done without waiting for ack the next transmit starts once the timer expires after a configured time  To enter Periodic Test Mode the command periodTestMode time(in microseconds) need to be provided  Periodic Test Mode      For all the above modes the total no of packets sent bytes sent packets which received ack and PER value are displayed at the end    Throughput Test Mode – Time period of 1 second is set as default in application The max payload is predefined (116 bytes) which is sent once tx done cb is called The packets are sent continuously until the timer expires The total no of packets sent bytes sent packets which received ack and PER value per second are displayed at the end  To enter Throughput Test Mode the command throughputTestMode need to be provided  Throughput Test Mode     PER Test Mode --- Packet limit is fixed to 100 for this mode 100 packets are sent continuously Each packets are of max payload limit The total no of packets sent bytes sent packets which received ack and PER value are displayed at the end  To enter PER Test Mode the command perTestMode need to be provided  PER Test Mode     Each mode operates independently only one mode can be enabled at a time  To stop running test modes the command stopTestMode should be used All the active running test modes will be stopped This command can be applied to stop the test modes only  Stop Active Test Modes       Commands to navigate/switch to different modes in application are described in COMMAND TABLE section  While the packets are being received the following info will be displayed: LQI(Link Quality Indicator) RSSI(Received Signal Strength) Received packet Count and Length of received payload in bytes (Refer to Peer device 2 terminal of Figure   5 )       ",
							" Command Table  User Commands that serves as an convenient method to utilise the API's in Standalone 15 4 PHY component and facilitates switch between different modes in application These commands implementation can be found in app_phy_cmd_processor c file under app_p2p_phy/app_phy_cmd_processor/src/ folder The aforementioned file is highlighted in the following figure Argument values/input values alongside the Commands must be given in integer(unsigned/signed) unless exceptionally mentioned as \"in hex\" in command table below Some of the range mentioned in the following Command Table description is based on PHY layer Pan Information Base (PIB) attributes PIB attributes are database of managed objects pertaining to the PHY Layer Please refer IEEE 802 15 4 - 2003/2006 spec for more details on PIB attributes of PHY layer  app_phy_cmd_processor c     Command Table Description         Command  Description  Syntax Range  Reference/Example      phyInit  PHY Layer Initialization  -  phyInit    phyReset  Resets the PHY state machine and sets the default PIB value if requested  phyReset set default PIB values-true/false   phyReset true     phyEdScan  Energy detection scan start  phyEdScan set scan duration ranging from 0 to 14 (unit - symbols)  phyEdScan 8    getAttribute  Get PHY PIB attribute: Attribute id can be referred from PHY PIB attribute table (common command to set any PHY PIB attribute)  getAttribute attribute id (hex)  getAttribute attribute id(hex) For Attribute ID refer to IEEE 802 15 4 spec - PHY PIB attributes table    setAttribute  Set PHY PIB attribute (common command to set any PHY PIB attribute)  setAttribute attr id (hex)   For Attribute ID refer to IEEE 802 15 4 spec - PHY PIB attributes table     getChannel  Get the Current Channel  --  getChannel    setChannel  Set the Current Channel  setchannel 11 – 26  setChannel 11    getChannelPg  Set the Channel Page  --  getChannelPg    setChannelPg  Set the Channel Page  setChannelPg 0/2/16/171  setChannelPg 0    getPanId  Get the PAN ID( INTRAPAN - 16bits)  --  getPanId    setPanId  Set Network PAN ID  setPanId panid in hex 0x0000-0xffff - 16bits  setPanId 0x0001    getDestAddr  Get the destination short address (16 bits)  --  getDestAddr    setDestAddr  Set the destination short address (16 bits)  setDestAddr 0x0000-0xffff - 16bits  setDestAddr 0x0001    getExtDestAddr  Get the destination short address (64 bits)  --  getExtDestAddr    setExtDestAddr  Set the destination Long address (64 bits)  setExtDestAddr 0x0000000000000000-0x7fffffffffffffff - 64bits  setExtDestAddr 0x123456    getSrcAddr  Get Short Address – 16 bits  --  getSrcAddr    setSrcAddr  Set Short Address – 16 bits  setSrcAddr 0x0000-0xffff  setSrcAddr 0x0002    getIeeeAddr  Get IEEE Address – 64 bits  --  getIeeeAddr    setIeeeAddr  Set IEEE Address – 64 bits  setIeeeAddr 0x0000000000000000-0x7fffffffffffffff - 64bits  setIeeeAddr 0x1234567    getCsmaMode  Get the CSMA mode  --  getCsmaMode    setCsmaMode  Set the CSMA mode  setCsmaMode 0-3  setCsmaMode 0    getTxPwr  Get the Tx Power in DBm  --  getTxPwr    setTxPwr  Set the Tx Power in DBm  setTxPwr -12 to 14 (unit - DBm)  setTxPwr 3    getIeeeAddr  Get 64-bit address  --  getIeeeAddr    getFrameRetry  MAC level frame retries  --  getFrameRetry    setFrameRetry  Set the MAC level Frame Retry to be retried in case of transmission failure  setFrameRetry 0 – 7  setFrameRetry 1    rxEnable  Receiver Enable  rxEnable Set TRX states PHY_STATE_RX_ON/PHY_STATE_TRX_OFF: true/false  rxEnable true    trxSleep  Put the transceiver to sleep  trxSleep sleep mode - sleep mode 1/deep sleep - false/true  trxSleep 0    trxWakeup  Wakeup the transceiver  --  trxWakeup    CCA  Perform CCA over the channel given by the user  CCA phychannel: 11-26  CCA 11    updateDeviceTable  Update the Device table with info like short address ieee address and corresponding device index  updateDeviceTable device index (0-total no of devices) short address(0x0000-0xffff (16 bits)) ieee address(64 bits) Total No of Devices = 64 (default MACRO associated : NUM_OF_DEVICES)  updateDeviceTable 1 0x1234 0x1234567    readDeviceTable  Read the Device table info based on table index  readDeviceTable device index – 255 – if entire list of devices in device table need to be displayed/specific index of the device table  readDeviceTable 2 = read the device info at index 2 readDeviceTable 255 = read the device info of all the devices    +++  Enter data mode  +++ Time period in microseconds  +++ 1000000 = [1000000usec = 1sec]      Exit Data Mode  --      periodTestMode  Enter Periodic Test Mode  periodTestMode Time period in microsecs  periodTestMode 1000000    contTestMode  Start Continuous Test Mode  --  contTestMode    perTestMode  Start PER Test Mode  --  perTestMode    throughputTestMode  Start ThroughputTest Mode  --  throughputTestMode    stopTestMode  Stop All Active application Test Modes (periodTestMode contTestMode perTestMode throughputTestMode)  --  stopTestMode    updatePERTestPacketsCnt  Update PER test Packets  updatePERTestPacketsCnt 0-4294967295 packets  updatePERTestPacketsCnt 100    promTestMode  Enable promiscuous RX mode  --  promTestMode    updateThroughputTime  Update Throughput Timer  updateThroughputTime 0-4294967295us  updateThroughputTime 1000000    getFrameType  Type of frame to be TX/RX  --  getFrameType    setFrameType  Type of frame to be TX/RX  setFrameType 0-5  setFrameType 0    phyCntTx  Starts continuous transmission on current channel  phyCntTx txMode-0/1-CW_MODE/PRBS_MODE userandomcontent -true/false  phyCntTx 0 true    stopPhyCntTx  Stops continuous transmission on current channel  --  stopPhyCntTx    ConfigRxRPCMode  Configures the reduced power consumption mode  ConfigRxRPCMode true - To Enable the rxRPC mode false - To disable the rx RPC mode  ConfigRxRPCMode true    configAutoAck  Configures TRX for auto acknowledging the reserved frame  configAutoAck enableAACK-true/false  configAutoAck true    getRSSIBaseVal  get the base RSSI value for respective radios  --  getRSSIBaseVal    getTrxStatus  get the status of the transceiver  --  getTrxStatus    configRxSensitivity  Configures receiver sensitivity level This is used to desensitize the receiver  configRxSensitivity pdtlevel:0-15  configRxSensitivity 0      Addressing Mode is set to 16 bit type as default config in application (Can be modified using the API app_P2P_Phy_setAddressModes )  Please Refer Standalone IEEE 15 4 PHY component API guide for more details  ",
							" How-to: Adding Chip Peripherals Guidance on how to add analog/digital peripherals to your application The Chip Support Package(csp) which is downloaded as part of installing Harmony 3 Dependancy is used to configure and generate code related to peripherals of choice Once a peripheral is added to Project Graph a user can configure a variety of settings applicable to the peripheral Upon code generation users will have a code generated specific to the peripheral Initialization of the peripheral for example SERCOM0_Initiliaze() will be added automatically to the SYS_Initialize() function call Documentation to understand the usage of various API's available for a particular peripheral is available here There are also precompiled application examples available as part of repo which give users ready to use examples to follow Adding UART logs to the BLE application ",
							" USART with Direct Pin Enable Direct Mode is a mode in which peripherals are running based on function priority for pins and not using Peripheral Pin Selection(PPS) SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE Zigbee stacks and application examples on your PC Software 1 Tera Term Hardware 1 WBZ451 Curiosity board Developing an application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop an application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview Create a new MCC Harmony Project -- link for instructions User can find Device Resources window right below the Project resource tab Device Resources 1 Add SERCOM0 from Peripherals list SERCOM0 Peripheral 2 Project graph view after adding SERCOM0 to the project resources Project Graph Verify UART Configuration 1 Select SERCOM0 component in project graph SERCOM0 USART provides 3 operating modes: a ) Ring buffer mode In ring buffer mode the receiver is always enabled and the received data is saved in the internal receive ring buffer size of which can be configured using MHC The application can use the API calls to read the data out from the ring buffer APIs are provided to query the number of (unread) bytes available in the receive buffer free space in the receive buffer and size of the receive buffer Similarly during transmission the application data is deep copied into the internal transmit ring buffer size of which can be configured using MHC This allows the use of local buffers for data transmission APIs are provided to query the free space in the transmit buffer number of bytes pending transmission and the size of the transmit buffer Additionally application can enable notifications to get notified when n bytes are available in the receive buffer or when n bytes of free space is available in the transmit buffer The APIs allow application to set the threshold levels for notification in both receive and transmit buffers Further application can also choose to enable persistent notifications whereby the application is notified until the threshold condition is met Ring buffer mode configuration options b) Blocking mode In blocking mode the transfer APIs block until the requested data is transferred Blocking mode configuration options c) Non-blocking mode In non-blocking mode the peripheral interrupt is enabled The transfer API initiates the transfer and returns immediately The transfer is then completed from the peripheral interrupt Application can either use a callback to get notified when the transfer is complete or can use the IsBusy API to check the completion status Non-blocking mode configuration options 2 Select system component in project graph and set SERCOM0 in \"Direct\" mode System configuration Generate Code link for instructions The sercom initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC according to the user settings Header Files Header File associated with sercom0 peripheral library or any other peripheral library for a different example is included in definitions h file Function Calls MCC generates and adds the code to initialize the UART peripheral in SYS_Initialize() function SERCOM0_USART_Initialize() is the API that will be called inside the SYS_Initialize() function User can exercise SERCOM0_USART_Write() api to create a “Hello World” application example like this: App example Testing Connect the WBZ451 Curiosity board to PC program the application example Open TeraTerm(Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) and select the COM port that is enumerated when connecting the WBZ451 Curiosity Board Reset the board and your application example will output the message in Teraterm Terminal window ",
							" USART with Peripheral Pin Select (PPS) The Peripheral Pin Select (PPS) feature allows digital signals to be moved from their default pin location to another location To enable a digital peripheral’s input and/or output signals the appropriate PPS registers must be configured This can be extremely handy for routing circuit boards There are cases where a change of I/O position can make a circuit board easier to route Sometimes mistakes are found too late to fix so having the option to change a pinout mapping in software rather than creating a new printed circuit board can be very helpful PPS block diagnram and various pin selection tables are explained in PIC32CX-BZ2 and WBZ45 Datasheet (D S70005504A ) chapter 6 SERCOM0 USART with PPS 1 Create a new project and add SERCOM0 device resource as explained in USART with Direct Pin Enable Direct Mode is a mode in which peripherals are running based on function priority for pins and not using Peripheral Pin Selection(PPS) mode 2 Find SERCOM0 Pin description from evaluation kit user’s guide ( DS50003367A ) 3 Assign a new pin for SERCOM0_PAD0 SERCOM0_PAD1 SERCOM0_PAD2 SERCOM0_PAD3 from PPS input/output group tables mentioned in datasheet( DS70005504A)  As per below table SERCOM0_PAD1 input pin can be mapped to any of the given RPn listed on this table Similar tables are present in Datasheet for SERCOM0_PAD1 SERCOM0_PAD2 SERCOM0_PAD3 also 4 Open Pin settings from Window- MPlab Code configuratior v5- Harmony- Pin Configuration tab and select your desired pin functions 5 Open your project graph from MCC code configurator and go to system configuration options and select SERCOM0 in \"PPS\" mode Generate Code link for instructions PPS input/output remaping code can be find in this generated plib_gpio c file SERCOM0_PAD3(in)- RA9 Pin setting will set PPS_SCOM0P3R to 15 (binary value 1111) SERCOM0_PAD1(in)- RA8 Pin setting will set PPS_SCOM0P1R to 9 (binary value 1001) SERCOM0_PAD0(out)- RA7 Pin setting will set PPS_RPA7G2R to 1 (binary value 00001) SERCOM0_PAD2(out)- RA3 Pin setting will set PPS_RPA3G1R to 2 (binary value 00010) Create a \"hello world\" application as mentioned in USART with Direct Pin Enable Direct Mode is a mode in which peripherals are running based on function priority for pins and not using Peripheral Pin Selection(PPS) section Testing Connect the WBZ451 Curiosity board to PC program the application example User can verify the data coming from UART Tx pin :SERCOM0_PAD0(RA7 in this case) using a logic analyzer User can also verify this application using one FTDI cable Connect FTDI ground pin and FTDI RX pin to appropriate Tx pin on WBZ451 and verify the message on TeraTerm window 1) Verify using Logic analyzer 2) Terminal window ",
							" Clock Provides configuration information for PIC32CX -BZ2 and WBZ45 family devices For details regarding the operation of the clock module refer to the “Clock and Reset Unit(CRU)” chapter in the specific PIC32CX -BZ2 device Data Sheet( DS70005504A ) The following figure shows the configuration screen for PIC32CX -BZ2 and WBZ45 family devices Configuring the System Clock Frequency Description Supports the following as system clock sources: – 16 MHz Primary Crystal Oscillator (POSC) – 8 MHz Fast RC Oscillator (FRC) – 32 kHz Low Power RC Oscillator (LPRC) – 32 768 kHz Secondary Crystal Oscillator (SOSC) – 96 MHz System PLL (RFPLL) Primary Oscillator (POSC) and Secondary Oscillator (SOSC) are customizable external clock source Most peripherals can utilize either the Peripheral Bus Clocks or the Reference Clock Generator as clock source Configuring the Peripheral Clock Three Peripheral Bus Clocks generated by independent integer dividers of the sys_clk: pb1_clk pb2_clk pb3_clk Peripheral Bus clock frequency is derived from SYSCLK and can be scaled using this Postscaler as shown in the above screenshot The system and peripheral clocks are stopped when in Sleep low power mode The clocks are restarted by disabling the sleep enable User can configure the reference clock for peripherals as shown below Configuring the Reference Clock Six Reference output clocks (REFO1-REFO6) with the following clock sources System clock PB1 Bus clock 16 MHz Primary Crystal Oscillator (POSC) 8 MHz Fast RC Oscillator (FRC) 32 kHz Low Power RC Oscillator (LPRC) 32 768 kHz Secondary Crystal Oscillator (SOSC) 96 MHz System PLL (RFPLL) 64 MHz System PLL (RFPLL PGM MHz) REFI Pin Select reference clock option from REFCLK1-REFCLK6 Turn on selected REFCLK as shown in the above screenshot Select your reference clock source option from drop down list User can enable \"Run in sleep mode\" by selecting this option as shown in the above screenshot Use Auto-calculate button to generate required perpheral frequency Click on Peripheral clock Configuration and verify your peripheral clock source and the frequency ",
							" How-to: Low Power Design Enable low power modes - Sleep/Standby or Deep Sleep/Backup Modes in your design ",
							"  Low Power Design on PIC32CXBZ2 Devices PIC32CXBZ2 examples and stacks supports Sleep and Deep Sleep low power modes as part of Harmony framework for WBZ451 Sleep and Deep Sleep Modes are synonymous to Standby and Backup Modes Throughout this document we refer to Sleep Mode as Standby and Deep Sleep mode as Backup mode Diffrence between Sleep and Deep Sleep Low Power Mode Sleep Low Power Mode Application layer calls BLE stack to enable advertising BLE stack will continue sending and receiving advertising Tx and Rx periodically until the application layer disables it System continues to operate between Active Mode and Sleep Mode periodically based on the ADV Tx and Rx Application layer can have peripherals running in sleep/standby low power mode Deep Sleep Low Power Mode Application layer calls BLE stack to enable Deep Sleep Advertisement BLE stack will backup advertisement parameters and data into backup SRAM and perform one time advertising event After entering Deep Sleep low power mode the system wakes up from reset whereby all parameters are lost Backup SRAM (retained in deep sleep low power mode)is used to save the advertisement parameters when waking up from reset Application layer will put system into Deep Sleep low power mode and control the wakeup time based on RTC timer (which runs in Deep Sleep low power mode) Once the system wakes up from Deep Sleep low power mode application layer triggers advertisement again by recovering the adverstisement and data partamters that are stored in backup SRAM Low Power Design of a system involves optimizing power both in Hardware and Software To name a few System Design MLDO vs Buck Mode (DC DC) Operating in Buck Mode yields to power consumption savings of about Board design to be able to measure the current consumed by the PIC32CXBZ2 device alone as there can be multiple components in the system Device Errata needs to be verified and special attention to issues that affect Device Power Consumption Lower System Clock speed from 64 MHz to 48 MHz some applications can operate with a lower system clock speed of 48 MHz Hardware Design Configuring the Transmitter power - @ 0dBm with Buck Mode on @ 64 MHz the PIC32XCBZ2 device draws 22 72 mA @+12 dBm Transmitter (Buck Mode @64 MHz) current consumption is 42 82 mA @+4 dBm Transmitter (Buck Mode @64 MHz) current consumption is 24 98 mA At Power up all GPIO's are inputs Unused GPIOs should be configured as input and pull down configuration Software Design Low Power BLE Application Design Low Power BLE Application Design ",
							" Low Power BLE Application Design Low Power BLE Application Design When designing a wireless Bluetooth Application BLE stack advertisement/connection intervals are the driving factors determining sleep mode entries and exit There are 2 low power/sleep modes that are supported by the BLE stack Sleep Deep Sleep Sleep and Deep Sleep Modes are synonymous to Standby and Backup Modes and this document may use these terminologies interchangeably The following table lists the various functionality/modules of the device that are available in the low power modes supported by BLE stack Function Sleep Deep Sleep Legacy ADV Available Available Extended ADV (Coded PHY) Available Not Supported BLE Connection Available Device can start with advertisement in \"Deep Sleep\" low power mode and post a BLE connection shift to \"Sleep\" low power mode Peripherals Available (see product datasheet for more info) Limited - wakeup sources are available Device Wakesup from reset after exiting Sleep Mode No Yes System RAM Available Not retained Backup RAM Not used by Application or BLE stack Available and used by Application and BLE stack Timer used to manage sleep and wakeup times Wireless Subsystem manages time intervals based on ADV/Connection intervals setup by API calls to BLE Stack library RTC ADV intervals recommended No min/max ADV interval Min ADV interval = 500 ms for power consumption savings Sleep/ Standby Low Power Mode What determines Application Sleep Duration and How to control it BLE stack allows system to enter low power mode if there is no active data tx/reception or the ble advertisement interval/connection interval So the system sleep cannot be directly edited as a parameter/ API call Device operation in Sleep low power mode During system sleep clock (system PLL) will be disabled and syatem tick will be turned off FreeRTOS timer needs to be componsated for the time spent in low power mode RTC timer can continue operating in the low power modes will adjust the FreeRTos timer offset So overall system sleep time is determined by the following factors - BLE activity interval external interrupt (like GPIO) or peripheral interrupts Peripherals that are allowed to run in standby/sleep low power mode can continue to run in the \"Sleep\" low power mode \"Deep Sleep/Backup Mode\" only allows for certain peripherals like RTC and INT0 to continue operating in this low power mode How to enable \"Sleep/Standby\" Low Power Mode Reference application examples BLE Legacy Adv Implements sleep low power mode with periodic ble legacy adv BLE Extended Adv Implements sleep low power mode with periodic ble extended (coded PHY) adv BLE Sensor App Implements sleep low power mode in a ble connection oriented application and data exchage using Microchip Transparent UART Service This application also has peripherals that are enabled to run in standby/sleep low power mode BLE Custom Service Building Block Implements sleep low power mode in a ble connection oriented application and data exchage using custom service This application does not have peripherals continuing to run in standby/sleep low power mode How to use MPLAB Code Configurator to Generate Sleep Mode low power mode code Sytem Sleep Mode needs to be enabled in BLE stack H3 compoenent configuration after enabling this dependant components like RTC (Timer source during sleep) will be requested to be enabled Upon enabling sleep mode FreeRTOS related settings will be set automatically Tick Mode will be set to Tickless_Idle Expected idle time before sleep will be set to 5 (ms) Tick Hook will be enabled (For user to add any custom code needed to be executed within each tick interrupt) RTC peripheral library will be added and configured Note: RTC counter should not be reset (RTC_Timer32CounterSet()) arbitrarily when the system is running RTC clock source should be set manually there are 4 options to choose from FRC (±1% offset) LPRC ( with larger offset ±5%) POSC - Candidate of the clock source (better clock accuracy) SOSC - Candidate of the clock source (better clock accuracy) Note: Users must select POSC/SOSC as the RTC clock source as choosing other clock sources will impact BLE connection stability Manually Setting RTC clock source - POSC open MCC select \"Clock Configuration\" and configure as highlighted Manually Setting RTC clock source - SOSC open MCC select \"Clock Configuration\" and configure as highlighted Note: Users can only select one clock source POSC or SOSC steps are mentioned to choose either It is recommended to use 48MHz as SYS_CLOCK for better power savings This can be configured by setting SPLLPOSTDIV1 to 2 as shown below Ensure that JTAG Enable is disabled by clearing the JTAGEN bit in CFGCON0 (Configuration Control Register 0) as shown below This code snippet can be added to SYS_Initialize() CFG_REGS- CFG_CFGCON0CLR = CFG_CFGCON0_JTAGEN_Msk; All Unused pins in the application needs to be set in input mode and the pulldown should be enabled for these pins This can be configured through pin configuration in Harmony3 Configurator as shown below Generate Code link for instructions Where can i find Sleep related code implementation after code generation step Implementation Location BT Sleep Mode BLE Stack Library System Sleep Mode device_sleep c Execute BT/System Sleep app_idle_task c RTC Based Tickless Idle Mode app_idle_task c What is code the user has to implement after code generation for sleep/standby low power mode entry FreeRTOS provides Tickless IDLE Mode for power saving this can be used to stop periodic tick interrupts during idle periods (periods when there are no application tasks that are able to excute) For the lost count on time during the IDLE mode RTC timer is used to make a correcting adjustment to the RTOS tick count value when it is restarted (after waking up from sleep) More information on low power tickless mode is available here The Tickless Idle Mode will be executed automatically when the Idle task is the only task able to run because all the application tasks are either in blocked or suspended state To prevent the system from entering sleep/standby low mode and waking up immediately the minimum sleep time(IDLE time) is automatically set to 5 ms Note: maximum sleep time is equal to the maximum period of the RTC 32 bit counter - 134217 8 sec (around 37 hours) In order for the system to enter sleep system needs to request bluetooth wireless subsystem to sleep This is accomplished by calling API - BT_SYS_EnterSleepMode() for BLE The API to call to ensure subsytem is sleeping (inactive) or ready for system to enter sleep mode is - BT_SYS_AllowSystemSleep If the expected sleep time is greater than 5 ms system is allowed to enter sleep mode by checking for 2 conditions Bluetooth subsystem is inactive eTaskConfirmSleepModeStatus() returns eNoTasksWaitingTimeout more information here  Tip: User can also add their own condition to be checked before system goes to sleep for example do not enter system sleep if data transmission over UART is active Pseudo code in RTC based Tickless Idle Mode: ``` if ((BT_SYS_AllowSystemSleep() || ZB_ReadyToSleep()) ( eTaskConfirmSleepModeStatus() = eAbortSleep ) (user_condition)) { //Enter System Sleep Mode DEVICE_EnterSleepMode (); //RTC Based Tickless Idle Mode } ``` When both the conditions as mentioned in point 3 are met we enter RTC based Tickless Idle mode (Stop the system tick use of RTC timer to set the sleep time disable interrupts) System will enter sleep mode after setting the RTC based Tickless Idle Mode by calling API - Device_EnterSleepMode() and then wait for Interrupt (WFI) instruction is executed How does the system exit from sleep mode Sytem when in sleep/standby mode can be waken up by RTC timeout BLE or GPIO interrupt Sleep mode exit is initiated by calling API - DEVICE_ExitSleepMode() Upon exiting the sleep mode interrupts need to be reenabled to allow the inteerupt service routine to be executed Interrupts are disabled as the sys tick needs to be compensated (Tickless IDLE mode) HW and FW state during System wake up and Sleep Mode Deep Sleep/Backup Low Power Mode What determines Application Sleep Duration and How to control it User Application determines the duration application stays in Deep Sleep low power mode When user selects an advertisement interval and enables deep sleep mode in the BLE_Stack component of Microchip Code configurator all the necessary API's required to enter and exit deep sleep low power mode are generated User application holds the responsibility to enable deep sleep adv and determine the sleep and wakeup duration based on the advertisement interval requirements Unlike sleep mode which uses a timer in the wireless subsystem to determine sleep and wakeup duration deep sleep mode does not use this timer (as it is unavailable in Deep Sleep low power mode) Hence we utilize the RTC timer(as it is available to run in Deep Sleep) and its interrupt based on the Deep Sleep adv interval that is set in application to wakeup the device from sleep sleep User can enter Deep Sleep low power mode post a succesful reception of \"BLE_GAP_EVT_ADV_COMPL\" event from BLE stack Device operation in Deep Sleep low power mode When the application layer initiates the BLE stack to enable Deep Sleep Advertisement the BLE stack backs up advertising parameters and application data into backup RAM and performs a one-time advertisement event Application layer will put the system in Deep Sleep mode and control Deep Sleep wakeup time using RTC timer User is responsible for putting the system in deep sleep mode and control the wakeup from RTC Based on the RTC Timer interval the device wakes up from Deep Sleep low power mode Exiting Deep Sleep mode is similar to Power on Reset Backup RAM saves the adv parameters through a reset upon wakeup BLE stack will be able to continue advertisements based on the data retained in backup RAM What is the device startup and initialization time when waking up from deep sleep low power mode since the device wakes up from reset Device startup and initialization code is diffrent and more optimizied to enable fast completion of initialization post a reset caused by waking up from deep sleep low power mode MPLAB code configurator generates API \"DEVICE_DeepSleepIntervalCal\" to calibrate the sleep duration based on the ADV interval chosen The device's startup and initialization procedures are optimized to make the device enter deep sleep low power mode as soon as possible Total time spent during device startup and firmware initialization is approximately 10 ms Average device startup time is 1 5 ms The firmware intialization time for various applications can change based on the user choice of peripherals and clocks to be initialized How to maintain I/O state when device comes out of reset when using deep sleep low power mode Device needs to backup all GPIO register settings prior to entering the deep sleep mode and recover these settings when devices wakes up from deep sleep prior to clearing the Deep Sleep register \"DSCON\" This register is cleared by the following generated API \"DEVICE_ClearDeepSleepReg()\" How to use MPLAB Code Configurator to Generate Deep Sleep Mode low power mode code Add the Harmony Components to project graph some components are optional based on Application being developed Configuration settings for \"BLE stack\" component Configuration settings for \"RTC\" component \"POSC\" as Low Power Clock Source (LPCLK) select clock configuration POSC Config bits generated after code generation \"SOSC\" as Low Power clock source(LPCLK) select clock configuration SOSC Config bits generated after code generation Clock Switching mechanism if LPCLK source is set as POSC clock source using clock configuration the FW switch to LPRC as LPCLK source as POSC clock source is unavailable in Deep Sleep Low Power Mode How to enable \"Deep Sleep/Backup\" Low Power Mode Reference application examples BLE Deep Sleep Advertisement On reset Device starts in Deep Sleep Mode upon press of SW1 button on curiosity board the sytem starts Deep Sleep Advertisements once connected to a central device the device will switch to Sleep low power mode Recommendations for using Deep Sleep ADV mode Deep Sleep ADV should be used when the ADV interval is = 500 ms What are the BLE Advertisements supported when using Deep Sleep Low Power Mode BLE Legacy Advertisement types \"ADV_IND\" \"ADV_SCAN_IND\" \"ADV_DIRECT_IND_LOW\" and \"ADV_NONCONN_IND\" are supported when using Deep Sleep mode What is the procedure for retaining Application data in backup RAM User should define the variable as persistent Persistent variables are variables that should not be cleared by the runtime startup code such as during a reset User should initialize a persistent variable as follows The data read/write into backup RAM must be single word (4 bytes) uint32_t __attribute__((persistent)) backup1; User firmware should not assign initial value for persistent variables Bootloader Firmware Authentication when using deep sleep low power mode If the bootloader has Firmware Authentication enabled the bootloader checks for Firmware Authentication upon all types of resets like POR BOR etc Firmware Authentication is skipped only when the device wakes up from Deep Sleep Low Power Mode RTC Clock Sources that are recommended to be used when using deep sleep low power mode SOSC or LPRC are the clock sources recommended when using deep sleep mode ",
							" How-to: Firmware and OTA Updates This section documents how to enable FW updates in your design whether its serial or over the air ",
							" Bootloader Introduction A bootloader is a small application that can be used to upgrade firmware on a target device without the need for an external programmer or debugger For PIC32CXBZ2 standalone bootloader it provides below functionalities: Device Firmware Upgrade over Serial(UART) interface this is also called DFU over Serial Provide functionality support for wireless Over The Air Update which is also called OTAU Provide various approaches to verify and authenticate firmware if enabled Display Console message if enabled PIC32CXBZ2 Standalone Bootloader Component PIC32CXBZ2 bootloader is a standalone Harmony component used to configure bootloader code for PIC32CXBZ2 device Click here to know about PIC32CXBZ2 standalone bootloader component user can find more information as listed below: Memory layout of PIC32CXBZ2 device Boot memory information Image metadata definition Working of Bootloader Flow diagram of Bootloader Bootloader configuration options Bootloader and DFU API usage Bootloader Example Code PIC32CX-BZ2/WB45 bootloader provided two methods to enter DFU mode one is GPIO Trigger another is Timber Based Trigger Later section will have more detailed information about them For bootloader using GPIO Trigger method user can find example code in wireless_apps_pic32cxbz2_wbz45 apps bootloader bootloader and precompiled hex file at wireless_apps_pic32cxbz2_wbz45 apps bootloader bootloader precompiled_hex bootloader X production hex For bootloader using Timer Based Trigger method user can find a precompiled hex file at wireless_apps_pic32cxbz2_wbz45 apps bootloader bootloader precompiled_hex bootloader_timer X production hex Since Timer Based Trigger bootloader creation is very similar to GPIO Trigger there is no example code provided for it Creating Bootloader From Scratch Using MCC This section explains the steps required by a user to configure and generate a PIC32CXBZ2 standalone bootloader from scratching using MCC User can find the bootloader example code(GPIO Trigger) generated using MCC in the path wireless_apps_pic32cxbz2_wbz45 apps bootloader bootloader Generated Bootloader example has the following configurations: Enabled UART DFU Enabled console to display messages Enabled GPIO Trigger Hardware requried is WBZ451 Curiosity Board DFU mode is triggered by pressing SW2(GPIO PB4) on the board Automatically reboot firmware after DFU is finished WBZ451 Curiosity Board is the hardware required to run this bootloader example the board top view is shown in figure-1 WBZ451 Curiosity Board WBZ451 Curiosity Board Top View Followings are steps to create the bootloader example(GPIO Trigger) from scratch Tip: New users of MPLAB Code Configurator are recommended to go through the overview  1 Create a new MCC Harmony Project -- link for instructions selecting WBZ451 as Target Device 2 After MCC is launched in Device Resource window expand Harmony – Wireless – Driver select Bootloader and add the component Accept all the dialog messages by clicking Yes on message prompt This will resolve dependencies among components and add connection in the graph Device Resources Window Harmony-Wireless-Dirver select Bootloader Confirmation for Components Auto-activiation Click all YES 3 In the project graph window select Bootloader component to show its Configuration Options In the Configuration Options enable Bootloader UART DFU verify it is GPIO Trigger mode and port PB4 is selected as GPIO trigger port PB4 is chosen as it is connected to SW2 on WBZ451 Curiosity board Then enable Console and leave ECC Public Key and Supported Authentication Methods to default Project Graph Window Select Bootloader to Configure Bootloader Options for GPIO Trigger GPIO Trigger mode options GPIO Trigger is the option to trigger DFU mode where user needs to hold the GPIO button during reset to put the bootloader into DFU mode Use GPIO Port and GPIO Pin option to change the port and pin based on user hardware Tip : Other than GPIO Trigger another trigger option Timer Based Trigger is also provided where bootloader will be in DFU mode for amount of time before jumping to the user application User can change the DFU Wait Time in Milliseconds to change the amount of time By selecting Timer Based Trigger a 32bit timer component TC0 is asked to be activated click YES to accept adding TC0 and accept its connection Following figures show Timer Based Trigger options and message prompt of adding TC0 Bootloader Options for Timer Based Trigger Timer Based Trigger mode options Comfirmation for Components Auto-activiation Click YES to Activate TC0 Component Tip : For Supported Authentication Methods 3 methods are provided: None  SHA256 and ECDSA256 Authentication methods with ECC Public Key are used to configure firmware authentication methods including verifying firmware completion status and authenticating firmware vendor For more details about these configurations user can refer to here  4 In the project graph window selecting the Bootloader component right click the dependency of UART select SERCOM0 in the Satisfiers list Then SERCOM0 component will be added into project graph Dependency of UART Select SERCOM0 in UART Satisfiers Project Graph Window Select SERCOM0 to Configure 5 Select SERCOM0 component to open its Configuration Options change Receive Pinout and Transmit Pinout according to WBZ451 Curiosity board Leave other settings to default SERCOM0 Options Configure Receive Pinout and Transmit Pinout 6 Expand tree of Peripherals select and add RCON component Verify RCON options just leaving it as default is okay Device Resources Window Harmony - Peripherals - RCON Project Graph Window Select RCON to Check its Options Tip : RCON provides software reset function adding RCON component is for enabling automatical firmware reboot after DFU completion 7 Then press Generate button to generate the code Generate Bootloader Code Press MCC Generate Button to Generate the Code 8 To make the Bootloader code be fit into 24KB boot memory of PIC32CXBZ2 manually find and replace ecc c and crypt_ecc_pukcl c with files provided in wireless_pic32cxbz_wbz utilities pic32cx-bz tempBtl 9 To enable firmware auto reboot after DFU completion it need host end to send a new command to bootloader This new command is device Reset command defined to 0x12 To add this command definition open file progexec h add code as below: #define DEVICE_RESET_CMD 0x12 Code Change in File progexec h Add RESET_CMD Definition Then in file progexec c function program_exec_main() add code to handle device Reset command call RCON_SoftwareReset() to start software reset Code added is shown in below figure Code Change in File progexec c Add RESET_CMD Command Handler Tip : firmware auto reboot also needs host end modification to send 0x12 command to reset device after DFU completion so far only PC GUI tool(MicrochipUtilityTool exe) is modified and supported it Python scripts as another way have not been modified to support it 10 On the IDE Tools bar click Clean and Build Main Project to build the code bootloader X production hex file will be generated User can also find precompiled hex files under folder wireless_apps_pic32cxbz2_wbz45 apps bootloader bootloader precompiled_hex  Build Bootloader Code Click Clean and Build Main Project to Build Code While generated bootloader hex file should be added to user aplication as Loadable File they shouldn't be used alone Followings are talking about a few simple steps need to be handled at user application side Configure User Application to Use Bootloader To use Bootloader with a user application there are a few steps to be configured at user application project These steps are common to any user application that wants to have Bootloader capability these steps include: Add Bootloader Services component onto user application project and generate code Add Bootloader as Loadable File/Project to create unified image Program unified image to device Add Bootloader Services Component and Generate Code Open any user application project with MPLAB X IDE click on MCC icon on Tools bar to launch MPLAB Code Configurator to open project graph In Device Resource window expand Harmony – Wireless – Driver select Bootloader Services component and add it This component generates the supporting linker file and MPLABX script needed for adding metadata header into application image(Project Properties is added with SignFirmware settings) Use Firmware Signature Verification API in Bootloader is the only option in Bootloader Services component For DFU via UART it is not necessary to enable firmware signature and verification although user can do so if needs While for OTAU user must enable firmware signature and verification by clicking on check box to Use Firmware Signature Verification API in Bootloader  (Following project graph is just an example user may have different graph depending on their application ) User Application Add Bootloader Services Add Bootloader Services and Configure After Bootloader Services component is added and configured press Generate button to generate the user application code In the generated new code some code about bootloader service is added as well as project’s linker script file is also automatically changed to reflect bootloader functionality Generate User Application Code Press Generate button to Generate User Application Code Also in the updated new project SignFirmware setting is added into Project Properties (if not see it try close and open MPLABX to refresh the project ) It's strongly recommended to enable Authen Method as SHA256 or ECDSA256-SHA256 in SignFirmware setting If user choose None since there is no firmware integrity check if any issue happens during image saving into slot1 as new image may not be complete the firmware may become non-functional at next restart So None option is not secure for firmware upgrade ECDSA256-SHA256 : firmware signature validation and data integrity check SHA256 : firmware data integrity check None : no security no integrity check SignFirmware - Auth Method - ECDSA256-SHA256 Firmware signature and integrity check SignFirmware - Auth Method - SHA256 Firmware integrity check Tip : Sequence Number cannot be 0x00000000 or 0xffffffff which are invalid values Add Bootloader as Lodable File/Project to Create Unified Image Once the new code is generated and configured user need to add Bootloader as a loadable project/loadable hex file in the updated project This enables MPLAB X IDE to merge both user application and bootloader and make an unified firmware by creating an unified image file To add Bootloader as loadable file expand application project’s tree right click Loadables select Add Loadable File then browse and add the bootloader hex file User Application Add Loadable File Right Click Loadables and Add Loadable File Add Loadable File Select Bootloader Precompiled Hex File as Loadable File To add bootloader as loadable project expand application project’s tree right click Loadables select Add Loadable Project then browse and add the bootloader project User Application Add Loadable Project Right Click Loadables and Add Loadable Project Add Loadable Project Select Bootloader Project as Loadable Project After Loadable File or Project is added then on the IDE Tools bar click Clean and Build Main Project icon to rebuild the project Build to Create Unified Image Click Clean and Build Main Project to Create Unified Image Merged Both User Application and Bootloader After code is built a few files is generated under path f irmware ble_sensor X dist default production The file named as signed unified hex is the unified image merged with both user application and bootloader By programing this unified image user application will have bootloader capability The file named as signed bin file is the target binary image file that bootloader use for DFU If user has any modifications on user application firmware user can build and generate this binary file then use bootloader to upgrade device to new image Program Unified Image As mentioned above user need to program device with unified image to make user application to have bootloader capability to do this on the IDE Tools bar click Make and Program Device Main Project icon to program device the unified image will be programmed into device Program Unified Image Click Make And Program Device Main Project to Program Unified Image Now the device with user application will have bootloader functionality referring the guidance in Device Firmware Upgrade Over Serial user can run Device Firmware Upgrade by using the bootloader ",
							" Device Firmware Upgrade Over Serial Device Firmware Upgrade(DFU) over serial is the functionality in Bootloader that user uses it to load new image received over serial interface and write into the flash PC GUI tool(MicrochipUtilityTool exe) and Python Script are two methods used for DFU over serial Followings are user guide and demostrantion steps using these two methods to do DFU over serial the demonstration is to upgrade ble_sensor user application with a new image DFU over Serial Using MicrochipUtility Tool MicrochipUtility is a GUI tool it suppors OTAU over serial Zigbee OTAU The utility tool is provided in Microchip website link For its user guide and demonstration using this tool to do serial DFU click Serial Bootloader Demo  DFU over Serial Using Python Script Pre-requisite: ble_sensor project as current user application(version 1 0 0 0) wireless_apps_pic32cxbz2_wbz45 apps ble advanced_applications ble_sensor firmware Precompiled ble_sensor new image(binary file): wireless_apps_pic32cxbz2_wbz45 apps ble advanced_applications ble_sensor precompiled_hex ble_sensor X production signed_uart_1 0 0 1 bin Bootloader : Precompiled hex file for GPIO Trigger mode DFU: wireless_apps_pic32cxbz2_wbz45 apps bootloader bootloader precompiled_hex bootloader X production hex Precompiled hex file for Timer Based Trigger DFU: wireless_apps_pic32cxbz2_wbz45 apps bootloader bootloader precompiled_hex bootloader_timer X production hex Python Script Files: For GPIO Trigger mode DFU: flash_load_2ndSlot py progctrl py ( wireless_pic32cxbz_wbz utilities pic32cx-bz dfuPythonScripts ) For Timer Based Trigger DFU: flash_load_2ndSlot_timer py progctrlOptimized py ( wireless_pic32cxbz_wbz utilities pic32cx-bz dfuPythonScripts ) Hardware: WBZ451 Curiosity Board How to Run Python Script: For GPIO Trigger DFU execute python script by below command: python flash_load_2ndSlot py -i image bin For Timer Based Trigger DFU execute python script by below command: python flash_load_2ndSlot_timer py -i image bin image bin is the binary file of new user image this binary file is generated from user application by MPLAB X IDE It could be other file name from user’s own application it may have path name before the file DFU over Serial Demonstration: Following are steps to operate DFU over seiral programing a new user image by using Bootloader Preparation: Create and Program Unified image Before DFU operation make sure the unified image containing bootloader and current user application are created and programmed To do this open ble_sensor project with MPLAB X IDE If user click Lodables will see the bootloader precompiled hex file is already added into the project Verify Loadable File in ble_sensor Project Click Loadables Verify Bootloader Precompiled Hex file is Added Tip : For Timer Based Trigger DFU user need to remove this hex file that is for GPIO Trigger DFU and add another timer based bootloader hex( bootloader_timer X production hex ) as Loadable File  Then on the IDE Tools bar click Clean and Build Main Project icon to build the project Since the project has a loadable hex file added code building will create a unified image hex file ble_sensor X production signed unified hex Tip : Another binary file named ble_sensor X production signed bin is created at the same time This binary file will be the targe image file used by bootloader for DFU However in this demonstration we will use another precomipled binary file as target image since that image contains different firmware version to tell user DFU is successful Build Unified Image Unified Image Contains Both User Application and Bootloader Once code building is finished on the IDE Tools bar click Make and Program Device Main Project icon to program device the unified image will be programmed into WBZ451 Curiosity board Program Unified Image Program Unified Image to Board Now the board is ready followings we will use DFU over serial to upgrade it to a new image ble_sensor X production signed_uart_1 0 0 1 bin For creating unified image user can refer to Bootloader - section Configure User Application to use Bootloader - Add Bootloader as Lodable File/Project to Create Unified Image to know more details Enter into DFU Mode For the provided bootloader example DFU mode is triggered by SW2 Button on WBZ451 Curiosity board So press and hold SW2 Button first then short press Reset button(SW1) to restart the firmware the firmware will enter DFU mode Opening Tera Term on PC and configure it as 115200/8bit/none Parity/1 Stop bit will see the message output as “DFU Now ” Ener Into DFU Mode Display Message \"DFU Now \" in Tera Term This message means the board is under DFU mode Run Python Script to do DFU Close Tera Term and open Windows Command Prompt go to the directory where python script files and binary image file are located and execute python script as below: python flash_load_2ndSlot py -i ble_sensor X production signed_uart_1 0 0 1 bin To run above python script user may need to copy those python script files and binary image file into a same folder However python script also support file with aboslute path name or relative path name Run Python Script to Do DFU (GPIO Trigger Mode) Execute Python Script and see DFU Progress Tip : For Timer Based Trigger DFU it uses different python script files execute python script as below: python flash_load_2ndSlot_timer py -i ble_sensor X production signed_uart_1 0 0 1 bin For Timer Based Trigger DFU it will wait to capture DFU mode window of the bootloader so for operating Timer Based Trigger DFU need execute python script first then reset the board and wait for a while If python script has captured DFU window it will start DFU process Otherwise user will need another reset the board until DFU is started Referring to figure below after python script is executed it keep waiting and reminding user to reset the board until DFU progress starts to be shown Run Python Script (Timer Based Trigger) Execute Python Script Reset Board and see DFU Progress The % progress will tell the DFU progress Once it is finished as 100% the new image is copied to slot1 of internal flash memory Reset Board to Start New Firmware Python script has not supported firmware automatical reboot after DFU completion so need manually reset the board to start new firmware Once DFU progress achieves 100% complete close Windows Command Prompt and open Tera Term to see the message output On the board press the Reset button(SW1) to restart the bootloader will then copy new firmware from flash memory slot1 to slot0 After that bootloader will jump and start new user image in slot0 On Tera Term user will see messages as shown below original firmware version is 1 0 0 0 now firmware version is 1 0 0 1 the DFU is successful Reset Board to Star New Firmware Display Message About Firmware Erase/Copy/Verify in Tera Term Tip : For Timer Based Trigger DFU it doesn't need manual reset the board to start new image Timer Based Trigger bootloader will automatically copy new user image and jump to start it Tip : Depending on if user has enabled Use Firmware Signature Verification API in Bootloader in Bootloader Services component or not the bootloader code may or may not verify metaheader and firmware using specified method If bootloader has verified metaheader and firmware their verification result will be displayed in Tera Term ",
							" Device Firmware Upgrade Over BLE Introduction One of the highly important features of wirelessly-connected devices is the capability of Over-The-Air device firmware update (OTA DFU) The increasing demand by end-users for this functionality is To address issues and security vulnerabilities To ship products to market faster and have the option of delaying lower priority features and being able to roll them out to devices in the field  PIC32CXBZ2 / WBZ451 family of devices support Over-The-Air upgrade through BLE Microchip defined OTA profile and service enables firmware upgrade over the BLE link using Generic Attribute Profile (GATT) The BLE OTA protocol defines the communication between the OTAU target and OTAU manager The OTAU manager can be a mobile device (iOS/Android™) or any BLE device that implements the OTA GATT client protocol that transfers the upgrade firmware to the OTAU target The OTAU target implements the OTA GATT server protocol to receive the new firmware image Secure BLE OTA DFU Process With the increasing popularity of OTA DFU capability in IoT devices devices are getting exposed to vulnerabilities and security threats So it is important to make sure that the device’s OTA DFU process is secure and reliable One of the way of sending upgradable image reliably and securely is to sign and encrypt the image Here are the basics of how an over-the-air device firmware update (OTA DFU) process works over BLE link: BLE OTA DFU Process • BLE OTA DFU file (Firmware Image encrypted signed) is uploaded to the OTAU Manager OTAU Manager can be Smart phone or any BLE device that supports OTA Client • OTAU Target ( PIC32CXBZ2 / WBZ451 device) queries the OTAU Manager and fetches new firmware image • The image will be decrypted validated and applied ",
							" BLE OTA DFU Firmware Architecture The below figure shows the BLE OTA DFU Firmware Architecture of PIC32CXBZ2 / WBZ451 device BLE OTA DFU Firmware Architecture MCHP OTA Profile and Service Middleware: Defines and handles the MCHP defined BLE GATT Server and Profile for getting the upgradable image over BLE link Implements OTA state management and error handling Implements defragmentation and decryption of received new image DFU Middleware: DFU APIs for writing the OTA image into Embedded Flash This module provides Device Firmware Update (DFU) capabilities common across the different supported transport mediums like UART BLE OTA Event Handling: OTA events from \"MCHP OTA Profile and Service\" middleware is sent to application for DFU permission OTA DFU Encryption Key management: Trigger new Flash Image authentication by calling Bootloader API Timeout handling in case of failure/error while receiving the image Bootloader: Bootloader is responsible for authentication and activation of new firmware booting into the application optionally entering into Serial DFU mode to get new image over serial interface Please be noted that Bootloader code is running from Boot Flash in PIC32CXBZ2 / WBZ451 family of devices So it is not immutable BLE OTA DFU Firmware Architecture - H3 Code ",
							" Memory Management  PIC32CXBZ2 / WBZ451 family of devices has enough Embedded Flash memory to hold the new upgradable OTA image until new image is authenticated The image is received in blocks over BLE link If the image is encrypted will be decrypted and stored in Embedded Flash Slot1 Once the complete image is received image is validated for signature Then the device reset will trigger the bootloader in Boot Flash region to load the image from Slot1 to Slot0 Now the new firmware starts executing Here is the memory split for PIC32CXBZ2 / WBZ451 embedded Flash for OTA DFU: Memory Split for DFU The above memory split is handled in linker script as shown below: #ifndef PDS_LENGTH #define PDS_LENGTH 0x4000 #endif #define ROM_BASE_ADDR 0x01000000 #define METADATA_HEADER_SIZE 0x200 #define SLOT0_BASE_ADDR ROM_BASE_ADDR #define SLOT1_BASE_ADDR 0x01080000 #ifndef ROM_ORIGIN1 #define ROM_ORIGIN1 SLOT0_BASE_ADDR + METADATA_HEADER_SIZE #endif #ifndef ROM_LENGTH1 #define ROM_LENGTH1 (SLOT1_BASE_ADDR - SLOT0_BASE_ADDR - PDS_LENGTH - METADATA_HEADER_SIZE) #elif (ROM_LENGTH1 0x100000) #error ROM_LENGTH1 is greater than the max size of 0x100000-0x200 #endif #ifndef PDS_ORIGIN #define PDS_ORIGIN (ROM_ORIGIN1 + ROM_LENGTH1) #endif #ifndef ROM_ORIGIN2 # define ROM_ORIGIN2 SLOT1_BASE_ADDR #endif #ifndef ROM_LENGTH2 #define ROM_LENGTH2 0x0080000 #elif (ROM_LENGTH2 0x100000) #error ROM_LENGTH2 is greater than the max size of 0x100000 #endif #ifndef BOOT_ROM_ORIGIN # define BOOT_ROM_ORIGIN 0x0 #endif #ifndef BOOT_ROM_LENGTH # define BOOT_ROM_LENGTH 0x5e00 #elif (BOOT_ROM_LENGTH 0x5e00) # error BOOT_ROM_LENGTH is greater than the max size of 0x5e00 #endif ",
							" Microchip defined BLE OTA DFU Profile The BLE OTA DFU profile is a GATT based profile It is designed to perform device firmware update over the air In general mobile will perform the OTAU client role and the BLE device will be in server role OTAU service is a Microchip’s propriety service with a 16-byte service UUID There shall be only one instance of the OTAS in a device The OTAS shall be instantiated as a «Primary Service» The service Universally Unique Identifier (UUID) value shall be set to «4D434850-253D-46B3-9923-E61B8E8215D7» There are 3 characteristics defined under the service: Characteristic Name Universally Unique Identifier (UUID) Properties Permissions OTA Feature 4D434850-22E4-4246-AF03-0C4A2F906358 Read Encryption required OTA Data 4D434850-34D9-40A6-BA7E-56F57C8CD478 WriteWithoutResponse Notify Encryption required OTA Control Point 4D434850-9327-45DE-8882-C97F39028A76 Write Encryption required Further details on OTAU service and profile can be found in stack documents BLE OTA Profile BLE OTA Service ",
							" BLE OTA DFU Image File Definition #BLE OTA DFU Image File Definition BLE OTA DFU File contains the OTAU header and Upgradable Flash Image as shown in below figure This file is loaded into OTAU Manager (Smart phone/ GATT client) to send to OTAU Target over BLE link BLE OTA DFU Image File Definition • Flash Image: Meta-data Header + Executable Firmware This is Full image content which is programmed in the device Flash Slot1 • Meta-data Header: Flash Image will have a metadata header metadata payload and metadata footer that will give the Bootloader firmware information about where the firmware image is located security decryption information signature sequence number etc Digital signatures ensure the authenticity of the image and integrity of the data in the image A digital signature also ensures that the data within the image has not been modified (preserving integrity) and is intact as it was generated at the source Refer to meta data header format from stack document  • OTAU File Encryption: The executable firmware can be encrypted (This is configurable) Encrypting the image ensures the confidentiality of the data This makes that no unauthorized parties are able to peek at the contents of the image Only the end-device should be able to decrypt the image AES128-CBC method of encryption is used Only the firmware image is encrypted and OTAU Header is not encrypted • BLE OTAU Header: This holds the OTAU File information for BLE OTA DFU Client (Ex: mobile App) to perform OTA DFU procedures This header is not being sent over the air to OTAU Target BLE OTAU Header ◦ Total Header length: 16 bytes ◦ BLE OTAU Header Version (HEADER_VER): 1 byte 0x01: PIC32CXBZ2 / WBZ451 Others: RFU ◦ Flash Image is encrypted or not (FLASH_IMG_ENC): 1 byte 0x00: Firmware Image is not encrypted 0x01: Firmware Image is encrypted by AES-CBC method Others: RFU ◦ Checksum : 2 bytes Checksum value of full OTAU file ◦ Flash Image ID (FLASH_IMG_ID): 4 byte Identity number of Flash Image ◦ Flash Image Revision/version (FLASH_IMG_REV): 4 byte ◦ OTAU File Type (FILE_TYPE): 1 Byte 0x01: BLE OTAU File 0x02: BLE+Zigbee Combo OTAU File Others: RFU ◦ Reserved: 3 byte OTA file is bin file which can be generated from MPLABX Tools environment as shown below The detail steps for image generation is explained later • BLE OTA Header and Encryption Key Configuration: BLE OTA Header and Encryption Key Configuration in MPLABX • Meta-data Header Configuration: Meta-data Header Configuration in MPLABX ",
							" BLE OTA DFU Image Distribution Procedure Step 1: Encrypted and Signed BLE OTAU bin File generation using signature and OTA configurator from MPLABX Tools device properties Place the OTAU file in OTAU manager Step 2: Transfer the OTAU Flash image over BLE OTA profile/service to OTAU Target Step 3: Image is decrypted using AES Key in Target and stored in Embedded Flash Slot1 Step 4: Once the complete image is received the device is reset Bootloader will copy new image from Slot1 to Slot0 after image authentication is done BLE OTA DFU Image Distribution Procedure ",
							" BLE OTA DFU Implementation Follow the below steps to add the BLE OTA DFU functionality in any of the Microchip BLE application ",
							" MCC Component and Code Generation Pre-requisite Open any BLE application based on MCC (Example project/ Custom created project) Launch MPLABx Code Configurator (MCC) MPLABx Code Configurator Pull-in MCC Components The below steps explains the components/configurations needed for OTA functionality alone Click on \"+\" symbol \"BLE OTA APP SERVICE\" component from \"Device Resources\" of MCC to project graph When the component is added the dependent components also getting added automatically Accept Dependencies or satisfiers select \"Yes\" inorder to add the dependent components  Configure \"BLE OTA APP SERVICE\" component as below based on the need   Enable Flash Image ID - This option checks for Image ID If this option is enabled the upgradable image should have the same ID of current image only then OTA upgrade procedure will happen Use the same value as in BLE OTA DFU bin file generation configuration as shown below  Enable Image Decryption - If the upgradable image is secured (encrypted using AES128 CBC) this configuration has to be enabled to do decryption of the received image The AES Key should match with the Key in BLE OTA DFU bin file generation configuration as shown below        When the Image decryption option is enabled in the above step the dependent crypto components will get added (if not already present in project graph) Accept Dependencies or satisfiers select \"Yes\" in order to add the dependent components Verify the below configurations: wolfCrypto Library component - AES-CBC mode is enabled  System component - AES Hardware engine clock is enabled   Verify Configurations All the required configurations are automatically done when the \"BLE OTA APP SERVICE\" component is added Verify if the Project Graph window has all the expected MCC configurations  BLE OTA profile and OTA Service Components - Enable Server Role This module generates the code needed for MCHP defined BLE OTA profile and service           BLE_Stack component - DFU Module enable - This module generates the code needed for device firmware upgrade middleware for writing the OTA image into Embedded Flash      BLE_Stack component - Advertising and Scan data payload is configured for manufacturer specific service UUID and local name BLE OTA Microchip Data (MBD) mobile app expects service UUID as \"0xFEDA\" to filter the devices    FreeRTOS stack size - The minimum stack size required by OTA feature is 3584 bytes For example if the original stack size needed for user application is 1024 bytes then set the total stack size as 1024 + 3584 = 4608 bytes      Bootloader Services component - This component generates the supporting linker file and MPLABX script needed for Upgradable image bin file generation Also the crypto API's in bootloader section is called to verify the authenticity (signature verification) of the received image before performing device reset         App Timer Service component - The BLE OTA procedure requires error handling and initializing the state in case of failure in receiving the image There are 2 software timers based on FreeRTOS systick is used APP_TIMER_OTA_TIMEOUT for error handling APP_TIMER_OTA_REBOOT for resetting the device after successful image reception      RCON component - As mentioned above APP_TIMER_OTA_REBOOT timer is used for resetting the device after successful image reception Device reset is performed using SW reset in RCON module    DIS BLE Service - Device Info Service is BT SIG defined service This service can be used to hold the firmware version When upgrading the Image OTAU manager gets the current running image version OTA server in device can use firmware version from DIS and send to OTAU manager Using the FW from DIS is just optional   If DIS is not needed for customer application DIS component can be removed and the below code for sending firmware version should be modified   Generate Code Generate Code by Clicking on \" Generate \" button Files and Routines Automatically generated by MCC After generating the code from MCC tool by clicking Generate button below is the project folder structure ",
							" OTA Application Development Compile MCC auto generated project Compile the MCC auto generated project as below Addressing the mandatory error (if not already done): User action required in app_user_edits c Follow the steps mentioned in the note and do the necessary changes Then comment the #error message as below Call BLE OTA Init function in \"app c\" and add the include file APP_OTA_HDL_Init(); #include \"app_ota/app_ota_handler h\" Call BLE OTA event handler function in \"app_ble/app_otaps_handler c\" APP_OTA_EvtHandler(p_event); #include \" /app_ota/app_ota_handler h\" Uncomment timer message ID's in \"app_timer/app_timer c\" needed for OTA error handling and reboot timer When the timer is fired the related message is posted in freeRTOS application task queue Define the timer message ID's in APP_MsgId_T structure in \"app h\" APP_TIMER_OTA_TIMEOUT_MSG APP_TIMER_OTA_REBOOT_MSG Call OTA timer handlers in APP_Tasks() in \"app c\" else if(p_appMsg- msgId == APP_TIMER_OTA_TIMEOUT_MSG) { APP_OTA_Timeout_Handler(); } else if(p_appMsg- msgId== APP_TIMER_OTA_REBOOT_MSG) { APP_OTA_Reboot_Handler(); } Call DIS service Init function in \"app c\" and add the include file BLE_DIS_Add(); #include \"ble_dis/ble_dis h\" Call BLE gap connected/disconnected event handler in \"app_ble/app_ble_handler c\" app_ble_conn_handler c handles the events and also restarts the Advertising when disconnected APP_BleGapConnEvtHandler(p_event); #include \" /app_ble_conn_handler h\" If the \"Standby Sleep mode\" low power functionality is enabled in the application during the OTA upgrade procedues it is required to disable the device entering into sleep mode Add the below check in app_idle_task() when the BT_SYS_EnterSleepMode() is called if (APP_OTA_HDL_GetOTAMode() = APP_OTA_MODE_OTA) BT_SYS_EnterSleepMode(RTC_Timer32FrequencyGet() RTC_Timer32CounterGet()); Compile the project for no errors API Documentation Reference: OTA Profile Middleware API's OTA Application level API's ",
							" Project Properties Configuration for Current/Running Firmware By following the previous steps the BLE OTA capability is added into application project Referring to Memory management this belongs to \"Firmware\" in Slot0 section Metatdata header and \"Bootloader\" has to be added into this project to make as working project with OTA capability to receive new upgradable image over BLE link MPLABX Tools environment allows to configure and append the Metadata header into application image The needed script and sample private key pem files are added into project folder ( X) when the OTA code was generated from MCC Note: Before proceeding to below steps close the OTA application project and reopen the project This step is mandatory for \"SignFirmware\" and \"OTA\" bin generation MPLABX script to be loaded into project environment Right click on the project - Properties SignFirmware - Adds Metadata header into application image Refer to Meta-data Header Configuration for more details on header format There are configurable parameters like Firmware Rev (version) authentication method and manufacturer ID Configure as per requirement     Step1: \"Firmware Rev\" - Firmware version of current running firmware This should be same as version in DIS service    Step2:\"Auth Method\" - There are 3 Supported authenticated methods   Signature validation (ECDSA256-SHA256) – most secure and data integrity check Signature is encrypted using ECDSA private key 256-bit ECDSA Public key to be programmed in device to do signature decryption openssl (example commands: https://techdocs akamai com/iot-token-access-control/docs/generate-jwt-ecdsa-keys) is one of the open tools to generate ECDSA public/private key pair Sample private key is available in project folder X Public key is input in Bootloader project    Hash validation (SHA-256) – less security and data integrity check    No validation (None) – no security no integrity check     Make sure to keep \"Sequence number\" as non-zero value and not 0xFFFFFFFF  Bootloader - Standalone Bootloader project is available in bootloader folder of application GIT repo The bootloader code stays in Boot Flash section The bootloader project can be added as loadable project into OTA project When the OTA project is build unified image with Bootloader+Metadata Header+Firmware will be generated Add the loadable project/loadable file (bootloader hex) into OTA project as shown below After doing the above steps click on \"Apply\" then \"OK\" to take the changes into effect ",
							" Unified Image Generation Compile the project for no errors MPLABX generated hex image will be available in project production folder dist default production There are 3 new images created as an outcome of \"SignFirmware\" MPLABX script These images are the valid images which has the metadata header appended signed unified hex - This is signed unified image along with bootloader This is the current image to be programmed on the device  signed hex - This image is signed image without bootloader This does not work if bootloader is not present on the device    signed bin - This is upgradable image which can be sent over serial DFU Follow the steps mentioned in DFU over serial if want to upgrade the device using serial interface     ",
							" Programming the Current Application Image using MPLABX IDE Build the project after doing all the above changes and program on Curiosity board  Now the device (OTAU Target) is running the application with OTA capability and able to be upgraded using OTAU manager like mobile phone ",
							" Upgradable image bin file generation Referring to Project Properties Configuration for Current image \"SignFirmware\" and \"OTA\" bin generation MPLABX script is added into OTA project \"OTA\" window in project properties is used for OTA DFU image generation  After making the new upgrdabe application keep the new upgradable image version number not same as current running image version The version number has to be taken care in DIS Service in new firmware as well as \"Firmware Rev\" in \"SignFirmware\" window For example new image Firmware Rev is chosen as 1 0 0 1 and same in DIS Firmware version in the project   Follow step 1 in Project Properties Configuration for Current image to open \"SignFirmware\" properties window  Change the \"Firmware Rev\" and then click on \"Apply\"   Compile the project     Follow step 1 in Project Properties Configuration for Current image to open \"OTA\" properties window  \"OTA\" window has few configurations       Output File Name - Name of the image    Output File Encryption - Image is encrypted or plain image    Output File Type - Choose \"BLE OTA File\" type for BLE based OTAU    Flash Image ID - Refer to Enable Flash Image ID for details    After the configurations click on \"Create OTA File\" The Upgradable bin image with selected \"Output File Name\" will be created in X folder This is the image stored in OTAU Manager to send to OTAU Target    ",
							" BLE OTA DFU Demo The below BLE OTA demo steps are common for any application implementing OTA functionality BLE sensor application is the sample project which implements OTA functioanlity as explained in the above steps The current image (ble_sensor X production signed unified_gpiobased hex or ble_sensor X production signed unified_timerbased hex) with OTA capability and new upgrdable bin (ble_sensor_1 0 0 1_enc_ota bin) is also available in ble advanced_applications ble_sensor precompiled_hex for your reference Hardware Required: Tool Qty  WBZ451 Curiosity Board 1 Micro USB cable 1 Android/iOS Mobile 1 Smartphone App: Microchip Bluetooth Data (MBD) iOS/Android app available in stores  Demo steps:   To perform the OTAU the upgradable firmware bin file created in \" Upgradable image bin file generation \" to be stored into MBD app Send the upgrdable bin file to your mail Follow the below screenshots to store the image received on mail into MBD app  iOS Mobile:            Android Mobile:          Turn on mobile Bluetooth and select “OTA DFU\" tab of Microchip Bluetooth Data App on the mobile device    Power On the OTA capable target device ( PIC32CXBZ2 / WBZ451 ) which was programmed in \" Programming the Application using MPLABX IDE \" Device will be advertising Click on \"SCAN\" button in mobile app and the device be visible in scanned list  Click on intended device from the scanned list Mobile app will now get connected with OTA Target device \"Connected\" message will appear for a short while  Click the ‘Select Image’ option to choose the available firmware file    The OTAU firmware image file copied in the step 1 will be visible on screen Click on that image    After confirming the FW version press OK button  Firmware update will be initiated and the progress will be shown in mobile app The process would take few seconds  Once the complete image is transferred \"OTA Update successfully\" status will be shown in mobile app Click on \"OK\" and then device will perform authentication of the image If validation is successful then system reboot automatically      On bootup device does the authentication of new image in Slot1 and then copies the new image to Slot0 Now the new image will be running from Slot0  To verify whether the running image on the target is newly upgraded image follow steps 2 to 7 and check the current version   ",
							" Device Firmware Upgrade Over Zigbee Link Designers and providers of embedded wireless systems continue to be challenged by the rapid evolution of the ZigBee® standard The continuous evolution of the standard requires that these systems must be made “future- proof” that is the system engineers must design them to be easily upgraded systems to the next version even after the system has been deployed The ability to upgrade networks also depends on the individual devices having enough hardware resources to accommodate the next version of the specification But even when these hardware resource requirements are met there still must be a defined and interoperable mechanism for efficient over the air upgrade The over-the-air upgrade support in ZigBee networks is covered by the Over-the- Air Upgrade Cluster specification The OTAU functionality relies on the use of standard ZigBee data transfer and network management facilities to transfer firmware images to any node on the network The standard covers on air message exchange but leaves the details of the architecture and implementation up to the vendor This guide outlines the Microchip architecture and implementation of over-the- air upgrade and describes how to add over-the-air upgrade support to zigbee applications The guide also introduces PC-side tools for initiating OTAU and explores practical considerations in performing a network upgrade ",
							" Zigbee OTAU Firmware Architecture ZigBee Over-the-Air Upgrade (OTAU) relies on existing ZigBee services for service discovery and data transmission across the network The main components of the architecture are: The OTAU client which resides on one of the end points on every upgradeable device The OTAU server which resides on whichever devices initiates the upgrade process A NVM driver responsible for writing the transferred images to embedded flash Slot1 on every upgradeable device An OTAU-capable bootloader for copying firmware image from Slot1 to Slot0 and does the image authentication Client Side Architecture The high-level software architecture of the OTAU client side (that is the upgradeable device) is illustrated in the below Figure According to the Zigbee OTAU specification the OTAU client part of the architecture is realized as a client side of the OTAU cluster This implies that the ZigBee Cluster Library (ZCL) framework must be present whenever OTAU is to be enabled on a device Server Side Architecture The server side of the OTAU cluster resides on what is commonly referred to as the upgrade access point (UAP) This may be a dedicated physical device which implements the server-side cluster or a multi-function in-network device which implements the OTAU service as an add-on piece of functionality Regardless of how UAP is realized there is always an implicit back channel usually in the form of another network or serial connection outside of the ZigBee network which is used to transfer the firmware images and control commands to the UAP This guide considers an application scenario where an in- network device is used as a permanent access point on the network through which over-the-air upgrades can be initiated at some point in a network’s lifetime In such case UAP is a device joined to the network and supporting the server side of the OTAU cluster in addition to functionality of a common network device In order to start and control upgrade process an in-network UAP is connected serially to a PC and the OTA PC tool or a similar custom utility is used ",
							" OTAU Basic Protocol and Control Flow Once UAP (OTAU Server) appears on the network (assuming it possesses the necessary security material to join it) it must be discovered by the OTAU clients (upgradeable nodes) that implement the client side of the OTAU cluster These client nodes issue periodic service discovery commands to discover the OTAU service cluster In application scenarios where UAP is always present this discovery will happen once when the client is powered on Before clients can proceed with any OTAU specific actions they must secure the link to the server The security settings applied to this link are the same as the security requirements for ZigBee Once the link is secured the clients can begin querying the server for the next image If the server indicates that a new image is available then a client starts requesting individual firmware image blocks or image pages consisting of multiple blocks from the server eventually completing the download When the download is complete the server can tell the client when to actually begin running the new firmware image The whole sequence of steps is illustrated in below Figure If a client loses connection to the server while it is loading an image it will try to restore connection and continue downloading the image The OTAU client cluster will try to get response from the server If the server replies with information about the image of the same version as the image which downloading has been broken the downloading will continue ",
							" Memory Management Due to unpredictable and dynamic nature of network links in multi-hop wireless networks like ZigBee the firmware image can only be transferred to the client using the best effort facilities for data transfer At any given point in time the client which has downloaded only a part of the image may become disconnected from the network Since in the general case it is impossible to avoid such a scenario it helps to ensure that the entire image is received before any part of it irreversibly overwrites any part of the currently running image This requires an architecture where whole and partially downloaded firmware images can be stored in a dedicated nonvolatile firmware image store decoupled from the flash memory holding the currently executing application image PIC32CX-BZ2/WBZ45 family of devices has enough Embedded Flash memory to hold the new upgradable OTA image until new image is authenticated The image is received in blocks over Zigbee link If the image is encrypted will be decrypted and stored in Embedded Flash Slot1 Once the complete image is received image is validated for signature Then the device reset will trigger the bootloader in Boot Flash region to load the image from Slot1 to Slot0 Now the new firmware starts executing Here is the memory split for PIC32CX-BZ2/WBZ embedded Flash for OTA DFU: The above memory split is handled in linker script as shown below: #ifndef PDS_LENGTH #define PDS_LENGTH 0x4000 #endif #define ROM_BASE_ADDR 0x01000000 #define METADATA_HEADER_SIZE 0x200 #define SLOT0_BASE_ADDR ROM_BASE_ADDR #define SLOT1_BASE_ADDR 0x01080000 #ifndef ROM_ORIGIN1 #define ROM_ORIGIN1 SLOT0_BASE_ADDR + METADATA_HEADER_SIZE #endif #ifndef ROM_LENGTH1 #define ROM_LENGTH1 (SLOT1_BASE_ADDR - SLOT0_BASE_ADDR - PDS_LENGTH - METADATA_HEADER_SIZE) #elif (ROM_LENGTH1 0x100000) #error ROM_LENGTH1 is greater than the max size of 0x100000-0x200 #endif #ifndef PDS_ORIGIN #define PDS_ORIGIN (ROM_ORIGIN1 + ROM_LENGTH1) #endif #ifndef ROM_ORIGIN2 # define ROM_ORIGIN2 SLOT1_BASE_ADDR #endif #ifndef ROM_LENGTH2 #define ROM_LENGTH2 0x0080000 #elif (ROM_LENGTH2 0x100000) #error ROM_LENGTH2 is greater than the max size of 0x100000 #endif #ifndef BOOT_ROM_ORIGIN # define BOOT_ROM_ORIGIN 0x0 #endif #ifndef BOOT_ROM_LENGTH # define BOOT_ROM_LENGTH 0x5e00 #elif (BOOT_ROM_LENGTH 0x5e00) # error BOOT_ROM_LENGTH is greater than the max size of 0x5e00 #endif ",
							" Zigbee OTAU Image File Definition Zigbee OTAU File contains the OTAU header and Upgradable Flash Image This file is loaded into OTAU Server connected PC tool to send to OTAU Client over zigbee mesh network • Flash Image: Meta-data Header + Executable Firmware This is Full image content which is programmed in the device Flash Slot1 • Meta-data Header: Flash Image will have a metadata header metadata payload and metadata footer that will give the Bootloader firmware information about where the firmware image is located security decryption information signature sequence number etc Digital signatures ensure the authenticity of the image and integrity of the data in the image A digital signature also ensures that the data within the image has not been modified (preserving integrity) and is intact as it was generated at the source Refer to meta data header format from stack document) • OTAU File Encryption: The executable firmware can be encrypted (This is configurable) Encrypting the image ensures the confidentiality of the data This makes that no unauthorized parties are able to peek at the contents of the image Only the end-device should be able to decrypt the image AES128-CBC method of encryption is used Only the firmware image is encrypted and OTAU Header is not encrypted • Zigbee OTAU Header: This header is as per zigbee OTA specification The below is the extract from the specification OTA file is zigbee file which can be generated from MPLABX Tools environment as shown below The detail steps for image generation is explained later Zigbee OTAU Header and Encryption Key Configuration: Meta-data Header Configuration: ",
							" Zigbee OTAU - Image Distribution Procedure The Basic Networking for Image Transfer for zigbee node is shown in below figure Step 1: Encrypted and Signed Zigbee OTAU bin ( zigbee) File generation using signature and OTA configurator in MPLABX device properties Copy the OTAU file to Zigbee OTAU PC tool to which zigbee OTAU server is connected Step 2: Transfer the OTAU Flash image over zigbee OTA service to OTAU Client node Step 3: Image is decrypted using AES Key in Target and stored in Embedded Flash Slot1 Step 4: Once the complete image is received the device is reset Bootloader will copy new image from Slot1 to Slot0 after image authentication is done ",
							" OTA Implementation Details - OTAU Client Side Follow the below step to add the Zigbee OTAU Client functionality in any of the zigbee application Pre-requisite Open any zigbee device type application based on MCC (Example project/ Custom created project) Launch MPLABx Code Configurator (MCC) The below steps explains only the components/configurations needed for OTA functionality Pull-in MCC Components Configure \"Zigbee Device Type\" component as below to enable \"OTA Client\" capability Optional \"Page mode\" configuration - When enabled OTA client sends page request instead of block request to server (1 Page = 5 Blocks) Add the \"Bootloader Services\" dependent component for \"Device Support\" component in project graph This component generates the supporting linker file and MPLABX script needed for generating OTA bin file Image Decryption - If the upgradable image is secured (encrypted using AES128 CBC) the below configuration has to be enabled to do decryption of the received image The AES Key should match with the Key in Zigbee OTA file generation configuration as shown below wolfCrypto Library component - AES-CBC mode is enabled System component - AES Hardware engine clock is enabled When upgrading the Image OTA Server PC Tool gets the current running image version from the device The upgradable image version has to be greater than running image to get upgraded The version is referred to macro CS_ZCL_OTAU_FILE_VERSION in the code Generate Code Generate Code by Clicking on \" Generate \" button Files and Routines Automatically generated by MCC After generating the code from MCC tool by clicking Generate below is the project folder structure ",
							" Application Development Compile MCC auto generated project Compile the MCC auto generated project as below Addressing the mandatory error (if not already done): User action required in app_user_edits c Follow the steps mentioned in the note and do the necessary changes Then comment the #error message as below Some configurations of interest in zigbee zigbee_device configs otauConfig h Interval between block requests This decides the firmware upgrade speed If the interval is more then the upgrade will take longer time #define ZCL_OTAU_DEFAULT_BLOCK_REQ_PERIOD 1000 AES Key and Init Vector This is used to decrypting the upgradable image which is encrypted The key used to encrypt the upgradable image should match with this key value #define OTA_IMAGE_CBC_KEY {0x01 0x12 0x23 0x34 0x45 0x56 0x67 0x78 0x89 0x90 0x99 0x88 0x77 0x66 0x55 0x44} #define OTA_IMAGE_CBC_IV {0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0} The current running image checks the version of new image against to this configuration value and expects the new image version is not same as this value #define CS_ZCL_OTAU_FILE_VERSION 0X50030700//CS_STACK_VERSION_VALUE This configuration is image Type and running image checks the upgradable image type against to this value If the upgradable image type matches to this configuration value or 0xFFFF only then upgrade happens #define OTAU_APP_IMAGE_TYPE OTA_EXTENDED_COLOR_LIGHT_IMAGE_TYPE ",
							" Project Properties Configuration for Current Image By following the previous steps the Zigbee OTA Client capability is added into application project Referring to Memory management this belongs to \"Firmware\" in Slot0 section Metatdata header and \"Bootloader\" has to be added into this project to make as working project with OTA capability to receive new upgradable image over BLE link MPLABX Tools environment allows to configure and append the Metadata header into application image The needed script and sample private key pem files are added into project folder ( X) when the OTA code was generated from MCC Note: Before proceeding to below steps close the OTA application project and reopen the project This step is mandatory for \"SignFirmware\" and \"OTA\" bin generation MPLABX script to be loaded into project environment Right click on the project - Properties SignFirmware - Adds Metadata header into application image Refer to Meta-data Header Configuration for more details on header format There are configurable parameters like Firmware Rev (version) authentication method and manufacturer ID Configure as per requirement Step1: \"Firmware Rev\" - Firmware version of current running firmware Step2a:\"Auth Method\" - There are 3 Supported authenticated methods Step 2b: Signature validation (ECDSA256-SHA256) – most secure and data integrity check Signature is encrypted using ECDSA private key 256-bit ECDSA Public key to be programmed in device to do signature decryption openssl (example commands: https://techdocs akamai com/iot-token-access-control/docs/generate-jwt-ecdsa-keys) is one of the open tools to generate ECDSA public/private key pair Sample private key is available in project folder X Public key is input in Bootloader project Hash validation (SHA-256) – less security and data integrity check No validation (None) – no security no integrity check Make sure to keep \"Sequence number\" as non-zero value and not 0xFFFFFFFF Bootloader - Standalone Bootloader project is available in bootloader folder The bootloader code stays in Boot Flash section The bootloader project can be added as loadable project into OTA project When the OTA project is build unified image with Bootloader+Metadata Header+Firmware will be generated Add the loadable project/loadable file (bootloader hex) into OTA project as shown below After doing the above steps click on \"Apply\" then \"OK\" to take the changes into effect ",
							" Unified Image Generation Compile the project for no errors MPLABX generated hex image will be available in project production folder dist default production There are 3 new images created as an outcome of \"SignFirmware\" MPLABX script These images are the valid images which has the metadata header appended signed unified hex - This is signed unified image along with bootloader This is the current image to be programmed on the device signed hex - This image is signed image without bootloader This does not work if bootloader is not present on the device signed bin - This is upgradable image which can be sent over serial DFU Follow the steps mentioned in DFU over serial if want to upgrade the device using serial interface ",
							" Programming the Current Application Image using MPLABX IDE Build the project after doing all the above changes and program on Curiosity board Now the device is running the application with OTA capability ",
							" Upgradable image zigbee file generation Referring to Project Properties Configuration for Current image \"SignFirmware\" and \"OTA\" bin ( zigbee) generation MPLABX script is added into OTA project \"OTA\" window in project properties is used for OTA image generation After making the new upgrdabe application keep the new upgradable image version number not same as current running image version The version number has to be taken care (defined by macro APPLICATION_VERSION in app h file) in new firmware as well as \"Firmware Rev\" in \"SignFirmware\" window For example new image Firmware Rev is chosen as 1 0 0 1 and same in Firmware version in the project Follow step 1 in Project Properties Configuration for Current image to open \"SignFirmware\" properties window Change the \"Firmware Rev\" and then click on \"Apply\" Compile the project Follow the step 1 in Project Properties Configuration for Current image to open \"OTA\" properties window \"OTA\" window has few configurations Output File Name - Name of the image Output File Encryption - Key used to encrypt the image If the upgradable image is secured (encrypted using AES128 CBC) the encryption key has to be present in current application to do decryption of the received image The AES Key used in Zigbee OTA file generation configuration has to match with the key in current running image as shown below Output File Type - Choose \"Zigbee OTA File\" type for Zigbee based OTAU Manufacture Code - This has to match with the configuration in upgradable image code Image Type - This can be 0xFFFF where image type can be anything or has to match with configuration in upgradable image code File Version - This is the application firmware version and has to be greater than the current running image It has to match with the configuration in upgradable image code After the configurations click on \"Create OTA File\" The Upgradable zigbee image with \"Output File Name\" will be created in X folder This is the image stored in Zigbee OTAU PC tool to send to OTAU Client ",
							" OTA Implementation Details - OTAU Server Follow the below step to add the Zigbee OTAU Server capability in any of the zigbee application Mostly Combined interface which is zigbee co-ordinator is considered for OTAU server Pre-requisite Open any zigbee type application based on MCC (Example project/ Custom created project) Launch MPLABx Code Configurator (MCC) The below steps explains only the components/configurations needed for OTAU Server functionality Pull-in MCC Components Configure \"Zigbee Device Type\" component as below to enable \"OTA Server\" capability As the OTAU server is connected to PC to get the upgradable image the UART interface has to be configured Connect \"Zigbee console\" in the Zigbee device component to USART Driver Component and to SERCM0 component (for WBZ Curiosity Board) as shown below Configure the SERCOM0 component to set the uart baud rate parity data bits and Sercom Tx and Rx pins DMA DMA is needed for stable UART communication without impacting the CPU time for other operations Add the \"Bootloader Services\" dependent component for \"Device Support\" component in project graph This component generates the supporting linker file and MPLABX script needed for OTAU Server device upgrade over UART This step is needed only when require to upgrade the OTAU server device locally through UART interface Generate Code Generate Code by Clicking on \" Generate \" button Files and Routines Automatically generated by MCC After generating the code from MCC tool by clicking Generate below is the project folder structure ",
							" Application Development Compile MCC auto generated project Compile the MCC auto generated project as below Addressing the mandatory error (if not already done): User action required in app_user_edits c Follow the steps mentioned in the note and do the necessary changes Then comment the #error message as below ",
							" Project Properties Configuration for Serial Bootloading By following the previous steps the Zigbee OTA Server capability is added into application project The below steps are needed if upgrading the server firmware through UART when Bootloader service is added as per step Bootloader Services Referring to Memory management Metatdata header and \"Bootloader\" has to be added into the project to receive new upgradable image over UART MPLABXTools environment allows to configure and append the Metadata header into application image The needed script is added into project folder ( X) when the \"Bootloader Service\" component was added and the code was generated from MCC Note: Before proceeding to below steps close the OTA application project and reopen the project This step is mandatory for \"SignFirmware\" and \"OTA\" bin generation MPLABX script to be loaded into project environment Right click on the project - Properties SignFirmware - Adds Metadata header into application image Refer to Meta-data Header Configuration for more details on header format There are configurable parameters like Firmware Rev (version) authentication method and manufacturer ID Configure as per requirement Step1: \"Firmware Rev\" - Firmware version of current running firmware Step2a:\"Auth Method\" - There are 3 Supported authenticated methods Step 2b: Signature validation (ECDSA256-SHA256) – most secure and data integrity check Signature is encrypted using ECDSA private key 256-bit ECDSA Public key to be programmed in device to do signature decryption openssl (example commands: https://techdocs akamai com/iot-token-access-control/docs/generate-jwt-ecdsa-keys) is one of the open tools to generate ECDSA public/private key pair Sample private key is available in project folder X Public key is input in Bootloader project Hash validation (SHA-256) – less security and data integrity check No validation (None) – no security no integrity check Make sure to keep \"Sequence number\" as non-zero value and not 0xFFFFFFFF Bootloader - Standalone Bootloader project is available in bootloader folder The bootloader code stays in Boot Flash section The bootloader project can be added as loadable project into OTA project When the OTA project is build unified image with Bootloader+Metadata Header+Firmware will be generated Add the loadable project/loadable file (bootloader hex) into OTA project as shown below After doing the above steps click on \"Apply\" then \"OK\" to take the changes into effect ",
							" Unified Image Generation for Serial Bootloading Compile the project for no errors MPLABX generated hex image will be available in project production folder dist default production There are 3 new images created as an outcome of \"SignFirmware\" MPLABX script These images are the valid images which has the metadata header appended signed unified hex - This is signed unified image along with bootloader This is the current image to be programmed on the device signed hex - This image is signed image without bootloader This does not work if bootloader is not present on the device signed bin - This is upgradable image which can be sent over serial DFU Follow the steps mentioned in DFU over serial if want to upgrade the device using serial interface ",
							" Programming the Current Application Image using MPLABX IDE Build the project after doing all the above changes and program on Curiosity board Now the device is running the application with OTA capability ",
							" Zigbee OTAU Demo Hardware Required Tool Qty WBZ451 Curiosity Board 2 Micro USB cable 2 PC 1 PC GUI Tool 1 MicrochipUtilityTool ( download link please always download the latest version on Microchip web) Demo steps To perform the OTAU the upgradable firmware zigbee file created in \"Upgradable image zigbee file generation\" to be stored in PC Follow the procedure in Microchip Utility Tool \"Zigbee Over The Air Update\" to perform Zigbee OTAU ",
							" Microchip Utility Tool Microchip Utility Tool is windows based GUI Tool used for firmware upgrade ",
							" Introduction Microchip Utility Tool works with Microchip PIC32CX_BZ2/WBZ45 device family This Tool Works on windows platform and provides the following functionalities This Tool communicates with the device over UART/PKOB4 Zigbee OTAU Zigbee Server (e g Combined Interface Application) is connected to a Zigbee Network which has one or more Zigbee clients (e g Zigbee light application) and connected to the Tool through Serial Port * Zigbee image is sent by the tool frame by frame (Payload Size =48 bytes) to the server through serial port Server manages the connection and send the received packets from the tool to the Clients till entire file is transferred Last command is sent to reset Zigbee client device Details of this functionality is provided in Zigbee OTAU section Zigbee Over the Air Update(OTAU) is discussed in this section  Serial Bootloader Bootloader enabled device is connected to the tool through Serial Port Device is put in DFU mode and Binary Image(* bin) image is sent through Serial Port frame by frame (payload size = 4096 bytes) Details of this functionality is discussed in Serial Bootloader Section  Programming * hex file using MPLAB IPE Image(* hex) is available in the local drive can be programmed using MPLAB IPE Details are provided in in Programming using MPLAB IPE section Image(* hex) file can be programmed into the device  This Tools has three Tabs (Zigbee OTAU and Serial Bootloader) There is a common section related to UART functionality which is visible in all three tabs of the tool Details of each tab of the tool is described below ",
							" Tools Description Zigbee OTAU Tab Details of this tab are given in the following Figure 1 Description of each buttons and text box are given in the picture Figure 1: Zigbee OTAU Tab Above Figure 1 shows details of each button and text boxes Details are provided for Zigbee OTAU function Serial Port connection UART Rx Display Box and related functions Programming * hex file through IPECMD exe in this Tab Details for item #12 and item#18 are given below Item#12 Zigbee Update : This button is used to start the Zigbee update process Cancel Update : This button is used to cancel Zigbee update process Clear Devlist : clear out device list Open The Network : send setPermitJoin 180/ invokeCommissioning 8 0 commands to open network for 180 ms Create NewNetwork : send resetToFN command to open new network for 180 sec Issuing this command deletes old network information in the Zigbee Server Item # 18 Select All : Select all items in the display box Select Items : press Ctrl and click mouse on lines in display box to select items Copy Selected : Copy selected items on Clip Board Clear : Remove all the texts from display box Copy All: Copy all the texts from the display box Serial Bootloader Tab Details of this tab are given in the following figure Description of each button and text box are given the figure Figure 2: Serial Bootloader Device can enter in Bootloader mode either through GPIO (button press) or waiting for specified amount of time after rebooting the device Both the scenarios are handled in this tab ",
							" Zigbee Over The Air Update Demo Zigbee Over the Air Update(OTAU) is discussed in this section Hardware Requirements Two or more WBZ451 Curiosity Board USB Cables PC Software Requirements MPLABX IDE/IPE MicrochipUtilityTool exe Zigbee OTAU Server and Client Image(* hex) Zigbee OTA Image(* zigbee) Terminal Emulator like TeraTerm Procedure Program Zigbee OTA Server Image into One WBZ451 Curiosity board Program Zigbee Client Image into One or more WBZ451 Curiosity Boards Connect Server and Client/Clients board with USB to PC and start TeraTerm for each board Type resetToFN on every board’s Tera Term Wait for network to establish The following type of messages will appear on Tera Term Device joined: Address 0xABCD MACID 0x000000000000EFBA ExtendedPANID 0x0000000000003578 Device joined: Address 0x1234 MACID 0x000000000000QRST ExtendedPANID 0x000000000000789A Note: Numbers above are for illustration purposes only These numbers will be different Close Server Terra Term Start MicrochipUtilityTool exe Follow steps mentioned in the following picture The demo shows two devices Click on Zigbee OTAU Tab Select Baud Rate as 115200 from the drop-down menu Select Zigbee OTA Server Serial Port from the drop-down menu Click on Connect/Disconnect Button Click Ok on popup windows Figure 4: Zigbee Server Connection Wait for connected device to appear on the device list Click on Select File button from each device list and select * zigbee file for each device(up to 5) Click on Zigbee Update button Figure 5: Zigbee OTAU Process Start Image keeps transferring frame by frame to each client node Progress bar keep advancing % Progress keeps advancing for selected device in the device list till all reach 100% for every selected client node OTA Status shows OTAU Done Tera Term connected with client shows Image Transferred Successfully and reboots after 5 sec into new Image as last command sent from Tool is reboot client devices after 5 sec Figure 6: Zigbee OTAU Process Finish Summary Maximum 5 client can be updated at a time This limitation comes from Zigbee Server Maximum 48 bytes payload can be sent in a frame at a time Out of Full packet size of 89 bytes 39 bytes are header It takes long time to transmit all the image data to client setMinimunBlockPeriod xx can be used set interpacket timing It is recommended xx should be 100 ms The Image used for this demo has 200 ms interpacket timing Default is set to 1000 ms interpacket timing It takes 32 min 17 sec to transmit entire image Image Size = 307784 bytes Once the OTAU is started File transfer can be initiated into new nodes appeared in the device list Time out (status = 0x95) in client node is not transmitted to OTA Server A 30 sec timeout has been introduced in the Tool to exit OTA process for not getting any update from the OTA server during OTA process ",
							" ISD Protocol Zigbee server communicates with the PC Tools using ISD protocol Following figure shows a typical Zigbee Network where a Zigbee Server is connected to network with multiple client nodes Zigbee server is connected to PC Tool (MicrochipUtilityTool exe) through serial port OTA enabled Zigbee Server communicates with the PC Tool through ISD (Internal Storage Driver) protocols Figure 1: Zigbee Network PC Tool sends entire image (* zigbee) through ISD packet by ISD packet to OTA server and OTA server routes the packet to client node ISD Packet Format PC Tool communicates with Zigbee Servers through ISD protocol ISD frame format is common to both transmit to/and receive from Zigbee server Details are given below ISD Frame Format Byte 0 Byte 1 Byte 2 Byte 3 Byte 4 Byte 5… n SOF Length ISD Command ID ISD Payload SOF (1 Byte): Start of frame = 0x2A (ASCII ‘*’) This is mandatory for all Tx/Rx packets Length (2 Byte): ISD Command ID Length + ISD Payload Length Total packet length exclude SOF(1 byte) and Length(2 byte)= Packet Length - 3 ISD Command ID (2 Byte): There are 4 types of commands between PC Tool and Zigbee server device ISD_DRIVER_INIT_REQUEST 0x0100 (From Zigbee Server to PC) ISD_DRIVER_INIT_RESPONSE 0x0101 (From PC to Zigbee Server) ISD_ZCL_COMMAND_REQUEST 0x0044 (From PC to Zigbee Server) ISD_ZCL_COMMAND_INDICATION 0x0046 (From Zigbee Server to PC) ISD Payload (N-5 Byte) : ISD Payload is Zigbee Cluster Command (ZCL) and have following structure(ZCL Command ID + ZCL Payload) ISD Payload ZCL Command ID ZCL Payload ZCL Command Here are details of ZCL Command ID ZCL Commands ID Direction Query Next Image Request 0x01 From Zigbee OTA server to PC Tool Query Next Image Response 0x02 From PC Tool to Zigbee OTA server Image Block Request 0x03 From Zigbee OTA server to PC Tool Image Block Response 0x05 From PC Tool to Zigbee OTA server Upgrade End Request 0x06 From Zigbee OTA server to PC Tool Upgrade End Response 0x07 From PC Tool to Zigbee OTA server ZCL Payload (RX): Received by PC Field Size (bytes) Comment Address mode 1 Standard addressing information that is used to identify the client to which the response is addressed Short address 2 Extended address 8 Profile ID 2 Endpoint 1 Source Cluster ID 2 Cluster ID 2 Direction 1 Being set to 1 indicates that the default response should be sent Command ID 1 May have one of the following values: QUERY_NEXT_IMAGE_REQUEST_ID(1) IMAGE_BLOCK_REQUEST_ID(3) UPGRADE_END_REQUEST_ID(6) (defined in the zclOTAUCluster h file) Payload Up to 16 bytes Control field (1 Byte) Manufacture ID (2 Bytes) Image Type (2 Bytes) File Version (4 Bytes) File Offset (4 Bytes) Max Packet Size (1 Byte) Block Request Delay (2 Bytes) ZCL Payload (TX): Sent by PC Field Size (bytes) Comment Address mode 1 Standard addressing information that is used to identify the client to which the response is addressed Short address 2 Extended address 8 Profile ID 2 Endpoint 1 Source Cluster ID 2 Cluster ID 2 Direction 1 Being set to 1 indicates that the default response should be sent Command ID 1 May have one of the following values: QUERY_NEXT_IMAGE_Response_ID(2) IMAGE_BLOCK_Response_ID(5) UPGRADE_END_Response_ID(7) (defined in the zclOTAUCluster h file) Payload Depends on command May be cast to one of the following types depending on the command ID: ZCL_OtauQueryNextImageResp_t ZCL_OtauImageBlockResp_t ZCL_OtauUpgradeEndResp_t Protocol Details of data exchanged between PC Tool and Zigbee Server are given below From Zigbee OTA Server to PC Tool From PC Tool to Zigbee OTA Server Step 1 Keep sending ISD_DRIVER_INIT_REQUEST command with Init marker to PC Tool Step 2 Sends ISD_DRIVER_INIT_RESPONSE with Init marker Step 3 Sends ISD_ZCL_COMMAND_INDICATION with \"Query Next Image Request\" Step 4 Sends ISD_ZCL_COMMAND_REQUEST with Query Next Image Response Step 5 Sends ISD_ZCL_COMMAND_INDICATION with \"Image Block Request\" with appropriate Image offset and length Step 6 Sends ISD_ZCL_COMMAND_REQUEST with \"Image Block Response\" with corresponding Image payload Continue Step 5 Continue step 6 for every step 5 request Step N Sends ISD_ZCL_COMMAND_INDICATION with \"Upgrade End Request\" Step N+1 Sends ISD_ZCL_COMMAND_REQUEST with \"Upgrade End Response\" Zigbee OTA server keeps sending ISD_DRIVER_INIT_REQUEST This command is sent to PC tool after Zigbee Server node is connected to a Zigbee networks ISD_ZCL_COMMAND_INDICATION has three ZCL Commands and ISD_ZCL_COMMAND_REQUEST (Query Next Image Request Image Block Response Upgrade End Response) has three ZCL commands (Query Next Image Response Image Block Response Upgrade End Response) Packet Details Following types of packets are received/sent from/to Zigbee OTA server ISD_DRIVER_INIT_REQUEST command : 2A 03 00 01 00 55 2A: SOF 03 00: Frame Length 01 00: ISD_DRIVER_INIT_REQUEST 55(ASCII “U”): init marker Direction: From Zigbee OTA Server to PC ISD_DRIVER_INIT_RESPONSE : 2A 03 00 01 01 55 2A: SOF 03 00: Frame Length 01 01: ISD_DRIVER_INIT_RESPONSE 55(ASCII “U”): init marker Direction: PC to Zigbee OTA Server ISD_ZCL_COMMAND_INDICATION This command is sent from Zigbee OTA server to PC Tool and has following three ZCL commands Query Next Image Request Here is typical ZCL Command indication packet which is sent periodically from the Zigbee server after Driver Init Response has been sent from the PC Query Image Request Bytes Typical Value Description Bytes 0 2A SOF 1 1 1F PKT LEN 2 2 0 PKT LEN 3 46 ZCL Command Indication 2 4 0 ZCL Command Indication 5 2 Address Mode 1 6 A0 Sort Address 2 7 50 Sort Address 8 11 Extended Address Mode 8 9 0 Extended Address Mode 10 0 Extended Address Mode 11 0 Extended Address Mode 12 0 Extended Address Mode 13 0 Extended Address Mode 14 0 Extended Address Mode 15 0 Extended Address Mode 16 4 Profile ID 2 17 1 Profile ID 18 23 End Point 1 19 19 SRC Cluster ID 2 20 0 SRC Cluster ID 21 19 Cluster ID 2 22 0 Cluster ID 23 0 Direction 1 24 1 Query Next Image Request 1 25 0 Control Field 1 26 14 Manufacture ID 2 27 10 Manufacture ID 28 FF Image Type 2 29 FF Image Type 30 0 Fi rmware Version 4 31 7 Fi rmware Version 32 3 Fi rmware Version 33 50 Fi rmware Version Image Block Request Image Block Request Bytes Typical Value Description Bytes 0 2A SOF 1 1 26 PKT LEN 2 2 0 PKT LEN 3 46 ZCL Command Indication 2 4 0 ZCL Command Indication 5 2 Address Mode 1 6 A0 Sort Address 2 7 50 Sort Address 8 11 Extended Address Mode 8 9 0 Extended Address Mode 10 0 Extended Address Mode 11 0 Extended Address Mode 12 0 Extended Address Mode 13 0 Extended Address Mode 14 0 Extended Address Mode 15 0 Extended Address Mode 16 4 Profile ID 2 17 1 Profile ID 18 23 End Point 1 19 19 SRC Cluster ID 2 20 0 SRC Cluster ID 21 19 Cluster ID 2 22 0 Cluster ID 23 0 Direction 1 24 3 Image Block Request 1 25 2 controlField 1 26 14 Manufacture ID 2 27 10 Manufacture ID 28 FF Image Type 2 29 FF Image Type 30 0 Fi rmware Version 4 31 7 Fi rmware Version 32 3 Fi rmware Version 33 50 Fi rmware Version 34 xx File Offset 4 35 xx File Offset 36 xx File Offset 37 xx File Offset 38 30 Max Pkt Size 1 39 E8 Block RequestDelay 2 40 3 Block RequestDelay Upgrade End Request Last Packet Request Bytes Typical Value Description Bytes 0 2A SOF 1 1 1F PKT LEN 2 2 0 PKT LEN 3 46 ZCL Command Indication 2 4 0 ZCL Command Indication 5 2 Address Mode 1 6 A0 Sort Address 2 7 50 Sort Address 8 11 Extended Address Mode 8 9 0 Extended Address Mode 10 0 Extended Address Mode 11 0 Extended Address Mode 12 0 Extended Address Mode 13 0 Extended Address Mode 14 0 Extended Address Mode 15 0 Extended Address Mode 16 4 Profile ID 2 17 1 Profile ID 18 23 End Point 1 19 19 SRC Cluster ID 2 20 0 SRC Cluster ID 21 19 Cluster ID 2 22 0 Cluster ID 23 0 Direction 1 24 6 Upgrade End Request 1 25 0 Status 1 26 14 Manufacture ID 2 27 10 Manufacture ID 28 FF Image Type 2 29 FF Image Type 30 0 Firmware Version 4 31 7 Firmware Version 32 3 Firmware Version 33 50 Firmware Version ISD_ZCL_COMMAND_REQUEST This command is sent from PC Tool to Zigbee Server and has following three ZCL Command Query Next Image Response with status 98 PC Tool send the following response Status 98 shows the PC is still not ready for OTA Query Image Response Bytes Typical Value Description Bytes 0 2A SOF 1 1 17 PKT LEN 2 2 0 PKT LEN 3 44 ZCL COMMAND REQUEST 2 4 0 ZCL COMMAND REQUEST 5 2 Address Mode 1 6 A0 Sort Address 2 7 50 Sort Address 8 11 Extended Address Mode 8 9 0 Extended Address Mode 10 0 Extended Address Mode 11 0 Extended Address Mode 12 0 Extended Address Mode 13 0 Extended Address Mode 14 0 Extended Address Mode 15 0 Extended Address Mode 16 4 Profile ID 2 17 1 Profile ID 18 23 End Point 1 19 23 Destination End Point 1 20 19 Cluster ID 2 21 0 Cluster ID 22 0 Default Resp 1 23 0 Command Options 1 24 2 Query Next Image Response 1 25 98 Status 1 Query Next Image Response to Start OTA In case PC Tool is ready for OTA operation (* zigbee file has been selected by the Tool and Zigbee Update Button has been pressed) status is set to 0 and the following response is sent Query Next Image Response with Data Bytes Typical Value Description Bytes 0 2A SOF 1 1 23 PKT LEN 2 2 0 PKT LEN 3 44 ZCL COMMAND REQUEST 2 4 0 ZCL COMMAND REQUEST 5 2 Address Mode 1 6 A0 Sort Address 2 7 50 Sort Address 8 11 Extended Address Mode 8 9 0 Extended Address Mode 10 0 Extended Address Mode 11 0 Extended Address Mode 12 0 Extended Address Mode 13 0 Extended Address Mode 14 0 Extended Address Mode 15 0 Extended Address Mode 16 4 Profile ID 2 17 1 Profile ID 18 23 End Point 1 19 23 Destination End Point 1 20 19 Cluster ID 2 21 0 Cluster ID 22 0 defaultResp 1 23 0 Command Options 1 24 2 Query Next Image Response 1 25 0 Status 1 26 14 Manufacture ID 2 27 10 Manufacture ID 28 ff Image Type 2 29 ff Image Type 30 1 Firmware Version 4 31 7 Firmware Version 32 3 Firmware Version 33 50 Firmware Version 34 38 Image Length 4 35 b9 Image Length 36 b4 Image Length 37 0 Image Length Image Block Response Image Block Response Bytes Typical Value Description Bytes 0 2A SOF 1 1 54 PKT LEN 2 2 0 PKT LEN 3 44 ZCL COMMAND REQUEST 2 4 0 ZCL COMMAND REQUEST 5 2 Address Mode 1 6 A0 Sort Address 2 7 50 Sort Address 8 11 Extended Address Mode 8 9 0 Extended Address Mode 10 0 Extended Address Mode 11 0 Extended Address Mode 12 0 Extended Address Mode 13 0 Extended Address Mode 14 0 Extended Address Mode 15 0 Extended Address Mode 16 4 Profile ID 2 17 1 Profile ID 18 23 End Point 1 19 23 Destination End Point 1 20 19 Cluster ID 2 21 0 Cluster ID 22 0 Default Resp 1 23 0 Command Options 1 24 5 Image Block Response 1 25 0 Status 1 26 14 Manufacture ID 2 27 10 Manufacture ID 28 ff Image Type 2 29 ff Image Type 30 1 Firmware Version 4 31 7 Firmware Version 32 3 Firmware Version 33 50 Firmware Version 34 38 File Offset 4 35 b9 File Offset 36 b4 File Offset 37 0 Image Length 38 30 Frame Size 1 39-xx yy-yy Payload =48 Upgrade End Response Last Packet Response Bytes Typical Value Description Bytes 0 2A SOF 1 1 26 PKT LEN 2 2 0 PKT LEN 3 44 ZCL COMMAND REQUEST 2 4 0 ZCL COMMAND REQUEST 5 2 Address Mode 1 6 A0 Sort Address 2 7 50 Sort Address 8 11 Extended Address Mode 8 9 0 Extended Address Mode 10 0 Extended Address Mode 11 0 Extended Address Mode 12 0 Extended Address Mode 13 0 Extended Address Mode 14 0 Extended Address Mode 15 0 Extended Address Mode 16 4 Profile ID 2 17 1 Profile ID 18 23 End Point 1 19 23 Destination End Point 1 20 19 Cluster ID 2 21 0 Cluster ID 22 0 Default Resp 1 23 0 Command Options 1 24 7 Upgrade End Response 1 25 14 Manufacture ID 2 26 10 Manufacture ID 27 ff Image Type 2 28 ff Image Type 20 1 Firmware Version 4 30 7 Firmware Version 31 3 Firmware Version 32 50 Firmware Version 33 xx Time to Reboot 8 34 xx Time to Reboot 35 xx Time to Reboot 36 xx Time to Reboot 37 xx Time to Reboot 38 xx Time to Reboot 39 xx Time to Reboot 40 xx Time to Reboot ",
							" Serial Bootloader Demo Boot loading over the serial port is discussed in this section Hardware Requirements One WBZ451 Curiosity Board USB Cables PC Software Requirements MPLABX IDE/IPE MicrochipUtilityTool exe Bootload enabled Firmware Image (ble_sensor signed unified hex BootloaderTimerBasedxxx hex) Bootload enabled binary image (ble_sensor signed_uart bin) Procedure Device can put in DFU Mode by one of the following methods GPIO (SW2 Button Press) Timer Based GPIO Based DFU mode Figure 7: Serial Bootlod Demo Start(GPIO) Program WBZ451 Board with the Image file( ble_sensor signed unified Hex ) Start MicrochipUtilityTool exe Follow the steps mentioned in the above picture Select Serial BootLoader Tab Select Baud Rate as 115200 from the drop-down menu Select the device Serial Port from the drop-down menu Click on Connect/DisConnect Button Press reset button on WBZ451 board UART Rx message appears in the log window Press and hold SW2 and then press and release reset Button on the WBZ451 Board and then release SW2 button WBZ451 Board will enter in DFU mode The following message will appear in the log DFU Now Click on Select File Button and choose ble_sensor signed_uart bin file Click on Send Image Button Image starts downloading into WBZ451 device Progress bar keeping advancing and debug status (Frame: Byte Sent: Time(hh:mm:ss)) keeps updating Figure 8: Serial Bootalod Demo End(GPIO) Wait for Image download to complete (Progress bar = 100% Status= Programming Complete) Press reset button on WBZ451 Board Slot1 is erased and new image is copied from slot0 and start executing new image A new command (0x12) has been added in the Tool This is the last command sent during DFU process If this command is supported in Boot loader code then the WBZ451 device will be automatically booted into new image Timer Based DFU mode Figure 9: Serial Bootlad Demo Start (Timer) Program WBZ451 Board with the Image file (BootloaderTimerBasedxxx hex ) Start MicrochipUtilityTool exe Follow the steps mentioned in the above picture Select Serial BootLoader Tab Select Baud Rate as 115200 from the drop-down menu Select the device Serial Port from the drop-down menu Click on Connect/DisConnect Button Connection status as Connected Click on Select File Button and choose ble_sensor signed_uart bin file Enter (Decimal Integer) Timeout period (step 7) Default is 30 sec Check Timer Click on Send Image Button Tool will wait for WBZ451 device to be in DFU mode for a time period entered in step 7(Default 30 sec) Press Reset Button The device will enter in DFU mode The following message will appear in the log DFU Now Image starts downloading into the WBZ451 device Progress bar keeping advancing and debug status (Frame: Byte Sent: Time(hh:mm:ss)) keeps updating Figure 10: Serial Bootoad Demo End (Timer) Wait for Image download to complete (Progress bar = 100% Status= Programming Complete) The device will automatically boot into new image Summary Frame size = 4096 bytes Image (size = 161920 bytes) takes 16 sec to transmit Default Timeout (30 sec) can be changed in the tool Timer Based Bootloading mode will automatically boots into new image after image download No need to press reset button GPIO based Botloading mode can also boot automatically into new image if a new command (command #0x12) is added into bootloader code ",
							" Programming using IPECMD exe Image(* hex) file can be programmed into the device Hardware Requirements One WBZ451 Curiosity Board USB Cables PC Software Requirements MPLABX IDE/IPE MicrochipUtilityTool exe Procedure Follow the steps shown in the following picture Figure 13: IPECMD Click on Browse File Button and select an image file Selected file will appear in the File Text Box Click on Flash Button Wait for Programming to complete Status: Done Summary MPLABX IPE should be installed on the PC ",
							" Wireless System Services API Wireless system services abstracts out the complexities of a networked system design and simplifies development for common BLE use cases like Over the Air Firmware Update and also provides debug services like BLE Virtual Sniffer ",
							" BLE_OTA BLE OTA service component generates the example code implementation needed for handling BLE OTA application callback and OTA timeouts Refer to OTA Application Development document for the usage of this component API's ",
							" BLE_OTA Enums ",
							" APP_OTA_HDL_Mode_T ",
							" C typedef enum APP_OTA_HDL_Mode_T { APP_OTA_MODE_IDLE APP_OTA_MODE_OTA } APP_OTA_HDL_Mode_T; ",
							" Description Application Status Mode Enumerator Description APP_OTA_MODE_IDLE Application in Idle Mode APP_OTA_MODE_OTA Application in OTA Mode ",
							" BLE_OTA Functions ",
							" APP_OTA_EvtHandler ",
							" C void APP_OTA_EvtHandler(BLE_OTAPS_Event_T *p_event); ",
							" Description OTA handler called from OTA profile from middleware ",
							" Parameters Parameter Description [in] p_event pointer to the structure with OTA Handler BLE_OTAPS_Event_T ",
							" APP_OTA_HDL_Complete ",
							" C void APP_OTA_HDL_Complete(void); ",
							" Description Stops the OTA timeout timer as OTA update is completed ",
							" APP_OTA_HDL_ErrorHandle ",
							" C void APP_OTA_HDL_ErrorHandle(uint16_t OTAHandle); ",
							" Description Handles OTA error ",
							" Parameters Parameter Description [in] OTAHandle Handle Associated with the connection ",
							" APP_OTA_HDL_GetOTAMode ",
							" C APP_OTA_HDL_Mode_T APP_OTA_HDL_GetOTAMode(void); ",
							" Description Gets the application mode ",
							" Return values Return value Description APP_OTA_MODE_IDLE Application in Idle Mode APP_OTA_MODE_OTA Application in OTA Mode ",
							" APP_OTA_HDL_Init ",
							" C void APP_OTA_HDL_Init(void); ",
							" Description OTA initialisation API to init mode and encryption API ",
							" APP_OTA_HDL_Prepare ",
							" C void APP_OTA_HDL_Prepare(uint16_t OTAHandle); ",
							" Description Preparation for OTA procedure ",
							" Parameters Parameter Description [in] OTAHandle Handle Associated with the connection ",
							" APP_OTA_HDL_Reset ",
							" C void APP_OTA_HDL_Reset(void); ",
							" Description Starts the OTA reboot timer to reset the device ",
							" APP_OTA_HDL_SetOTAMode ",
							" C void APP_OTA_HDL_SetOTAMode(APP_OTA_HDL_Mode_T mode); ",
							" Description Sets the application in OTA mode ",
							" Parameters Parameter Description [in] mode Variable to the OTA Application Mode structure APP_OTA_HDL_Mode_T ",
							" APP_OTA_HDL_Start ",
							" C void APP_OTA_HDL_Start(void); ",
							" Description Starts the OTA timeout timer ",
							" APP_OTA_HDL_Updating ",
							" C void APP_OTA_HDL_Updating(void); ",
							" Description Starts the OTA timeout timer while OTA update is in progress ",
							" APP_OTA_Reboot_Handler ",
							" C void APP_OTA_Reboot_Handler(void); ",
							" Description OTA reboot timer handler ",
							" APP_OTA_Timeout_Handler ",
							" C void APP_OTA_Timeout_Handler(void); ",
							" Description OTA timeout handler ",
							" BLE_Conn_Handler The example code implementation for handling BLE connected and disconnected events in BLE GAP event callback from application They are supporting API's and are generated when the BLE OTA service component is added in the project Refer to OTA Application Development document for the usage of the API's ",
							" BLE_Conn_Handler Enums ",
							" APP_BLE_LinkState_T ",
							" C typedef enum APP_BLE_LinkState_T { APP_BLE_STATE_STANDBY APP_BLE_STATE_ADVERTISING APP_BLE_STATE_SCANNING APP_BLE_STATE_CONNECTED APP_BLE_STATE_TOTAL } APP_BLE_LinkState_T; ",
							" Description Enumeration type of BLE state Enumerator Description APP_BLE_STATE_STANDBY Standby state i e not advertising APP_BLE_STATE_ADVERTISING BLE is advertising APP_BLE_STATE_SCANNING BLE is scanning (only for BLE_GAP_ROLE_CENTRAL) APP_BLE_STATE_CONNECTED BLE is connected APP_BLE_STATE_TOTAL Final State ",
							" BLE_Conn_Handler Functions ",
							" APP_BleGapConnEvtHandler ",
							" C void APP_BleGapConnEvtHandler(BLE_GAP_Event_T *p_event); ",
							" Description BLE Stack application GAP Connection event handler ",
							" Events generated BLE_GAP_EVT_CONNECTED Generated when the connection is established Succefully ",
							" Parameters Parameter Description [in] p_event Pointer to the BLE_GAP_Event_T Structure buffer ",
							" APP_GetBleState ",
							" C APP_BLE_LinkState_T APP_GetBleState(void); ",
							" Description Returns BLE link state ",
							" Return values Return value Description APP_BLE_STATE_STANDBY Standby state i e not advertising APP_BLE_STATE_ADVERTISING BLE is advertising APP_BLE_STATE_SCANNING BLE is scanning (only for BLE_GAP_ROLE_CENTRAL) APP_BLE_STATE_CONNECTED BLE is connected ",
							" APP_GetConnHandleByIndex ",
							" C uint16_t APP_GetConnHandleByIndex(uint8_t index); ",
							" Description Gets the connection handle based on index passed ",
							" Parameters Parameter Description [in] index Index Associated with the Connection ",
							" Return values Return value Description uint16_t Connection Handle associated with the Index ",
							" APP_GetConnInfoByConnHandle ",
							" C APP_BLE_ConnList_T *APP_GetConnInfoByConnHandle(uint16_t connHandle); ",
							" Description Returns the connection information based on connection handle ",
							" Parameters Parameter Description [in] connHandle Handle assocaited with the Connection ",
							" Return values Return value Description Info Ble link related Info APP_BLE_ConnList_T Structure ",
							" APP_InitConnList ",
							" C void APP_InitConnList(void); ",
							" Description Initialise connection list ",
							" APP_SetBleState ",
							" C void APP_SetBleState(APP_BLE_LinkState_T state); ",
							" Description Sets BLE link state ",
							" Parameters Parameter Description [in] state BLE Link State APP_BLE_LinkState_T Structure ",
							" BLE_Conn_Handler Structures ",
							" APP_BLE_ConnData_T ",
							" C typedef struct APP_BLE_ConnData_T { uint8_t role; uint16_t handle; BLE_GAP_Addr_T remoteAddr; uint16_t connInterval; uint16_t connLatency; uint16_t supervisionTimeout; } APP_BLE_ConnData_T; ",
							" Description The structure contains the BLE Connection parameters ",
							" Field Documentation Field Description role GAP role see BLE_GAP_ROLE  handle Connection handle associated with this connection remoteAddr See BLE_GAP_Addr_T  connInterval Connection interval used on this connection Range should be BLE_GAP_CP_RANGE  connLatency Slave latency for the connection in terms of number of connection events see BLE_GAP_CP_RANGE  supervisionTimeout Supervision timeout for the LE Link see BLE_GAP_CP_RANGE  ",
							" APP_BLE_ConnList_T ",
							" C typedef struct APP_BLE_ConnList_T { APP_BLE_LinkState_T linkState; APP_BLE_ConnData_T connData; } APP_BLE_ConnList_T; ",
							" Description The structure contains the BLE link related information maintained by the application Layer ",
							" Field Documentation Field Description linkState BLE link state see APP_BLE_LinkState_T connData BLE connection information See APP_BLE_ConnData_T ",
							" APP_TRPS ",
							" APP_TRPS Defines ",
							" Control Response ID status Length ",
							" C #define APP_TRPS_CTRL_RSP_ID_STATUS_LEN 2 ",
							" Description The definition of Maximum length of Control Response ID Status ",
							" Macro Definition Macro Description APP_TRPS_CTRL_RSP_ID_STATUS_LEN Control Response Status Size ",
							" Maximum Control List Size ",
							" C #define APP_TRPS_CTRL_LST_SIZE 2 ",
							" Description The definition of Maximum Size of Control List ",
							" Macro Definition Macro Description APP_TRPS_CTRL_LST_SIZE Control List Size ",
							" APP_TRPS Enums ",
							" APP_TRPS_CTRL_STATUS_CODE_T ",
							" C typedef enum APP_TRPS_CTRL_STATUS_CODE_T { SUCCESS = 0x00 OPCODE_NOT_SUPPORTED = 0x01 INVALID_PARAMETER = 0x02 OPERATION_FAILED = 0x03 }APP_TRPS_CTRL_STATUS_CODE_T; ",
							" Description Application Transparent Service Control Status Code Enumerator Description SUCCESS Control Status Success OPCODE_NOT_SUPPORTED COntrol Opcode Not Supported INVALID_PARAMETER Invalid paramter Value OPERATION_FAILED Operation Failed ",
							" APP_TRPS Functions ",
							" APP_TRPS_ConnEvtProc ",
							" C void APP_TRPS_ConnEvtProc(BLE_GAP_Event_T *p_event); ",
							" Description Process Connection Event specific to BLE Sensor ",
							" Parameters Parameter Description [in] p_event pointer to the BLE GAP Event Buffer BLE_GAP_Event_T ",
							" APP_TRPS_deInit ",
							" C void APP_TRPS_deInit(uint8_t opCode); ",
							" Description DeInitialize App Transparent Service Structure ",
							" Parameters Parameter Description [in] opcode opcode specific to the profile ",
							" APP_TRPS_DiscEvtProc ",
							" C void APP_TRPS_DiscEvtProc(uint16_t connHandle); ",
							" Description Process Disconnection event specific to BLE Sensor ",
							" Parameters Parameter Description [in] connHandle Handle associated with the Connection ",
							" APP_TRPS_EventHandler ",
							" C void APP_TRPS_EventHandler(BLE_TRSPS_Event_T *p_event); ",
							" Description TRPS Event handler called from BLE Stack ",
							" Parameters Parameter Description [in] p_event pointer to the Transparent Event buffer BLE_TRSPS_Event_T ",
							" APP_TRPS_Init ",
							" C uint16_t APP_TRPS_Init(uint8_t opcode APP_TRPS_CmdResp_T *p_cmd APP_TRPS_NotifyData_T *p_ntfy uint8_t cmdRspSize uint8_t ntfySize); ",
							" Description Initialize App Transparent Service Structure ",
							" Parameters Parameter Description [in] opcode opcode specific to the profile [in] p_cmd pointer to the command Response buffer APP_TRPS_CmdResp_T [in] p_ntfy pointer to the Notify Data buffer APP_TRPS_NotifyData_T [in] cmdRspSize Command Response Size [in] ntfySize Notify Size ",
							" Return values Return value Description APP_RES_SUCCESS Successfully initialized Transparent service MBA_RES_FAIL Fail to initialize Transparent service ",
							" APP_TRPS_SendNotification ",
							" C uint16_t APP_TRPS_SendNotification(uint8_t opcode uint8_t ntfyId); ",
							" Description Send Control notify data through TRPS control service ",
							" Parameters Parameter Description [in] opcode opcode specific to the profile [in] ntfyId Control Notify ID ",
							" Return values Return value Description MBA_RES_SUCCESS Execution successfully MBA_RES_FAIL Execution fail MBA_RES_INVALID_PARA Invalid parameters MBA_RES_OOM Out of memory ",
							" APP_TRPS Structures ",
							" APP_TRPS_CmdResp_T ",
							" C typedef struct __attribute__ ((packed)) { uint8_t CmdId; uint8_t RspId; uint8_t Length; uint8_t* p_Payload; uint8_t (*fnPtr) (uint8_t*); } APP_TRPS_CmdResp_T; ",
							" Description The structure contains the information about control command/Resp format ",
							" Field Documentation Field Description CmdId Command ID RspId Response ID Length Command/Response Lengh p_Payload Command/Response Payload (*fnPtr) Pointer to Function ",
							" APP_TRPS_ConnList_T ",
							" C typedef struct APP_TRPS_ConnList_T { uint16_t connHandle; } APP_TRPS_ConnList_T; ",
							" Description The structure contains information about APP transparent connection parameters for recording connection information ",
							" Field Documentation Field Description connHandle Connection handle associated with this connection ",
							" APP_TRPS_Ctrl_T ",
							" C typedef struct { uint8_t opcode; uint8_t cmdRspSize; uint8_t ntfySize; APP_TRPS_CmdResp_T *appTrpsCmdResp; APP_TRPS_NotifyData_T *appTrpsNotify; } APP_TRPS_Ctrl_T; ",
							" Description The structure contains the information about control Cmd resp notify structures ",
							" Field Documentation Field Description opcode opcode cmdRspSize Size of cmd Resp array ntfySize Size of Notfy array appTrpsCmdResp Command Response to structure APP_TRPS_CmdResp_T appTrpsNotify Notify Data to structure APP_TRPS_NotifyData_T ",
							" APP_TRPS_CtrlCmd_T ",
							" C typedef struct __attribute__ ((packed)) { uint8_t Opcode; uint8_t Length; uint8_t ctrlID; uint8_t* p_Payload; } APP_TRPS_CtrlCmd_T; ",
							" Description The structure contains the information about control command format ",
							" Field Documentation Field Description Opcode Control Opcode Length Control command length ctrlID Control control ID p_Payload Control command data pointer ",
							" APP_TRPS_NotifyData_T ",
							" C typedef struct __attribute__ ((packed)) { uint8_t NtfID; uint8_t Length; uint8_t *p_Payload; } APP_TRPS_NotifyData_T; ",
							" Description The structure contains the information about control Notify format ",
							" Field Documentation Field Description NtfID Control Notify ID Length Control Notify length p_Payload Control Notify data pointer ",
							" APP_ERROR_DEF ",
							" APP_ERROR_DEF Defines ",
							" Error Codes Def-1 ",
							" C #define APP_RES_SUCCESS MBA_RES_SUCCESS #define APP_RES_FAIL MBA_RES_FAIL #define APP_RES_OOM MBA_RES_OOM #define APP_RES_INVALID_PARA MBA_RES_INVALID_PARA #define APP_RES_NO_RESOURCE MBA_RES_NO_RESOURCE #define APP_RES_BAD_STATE MBA_RES_BAD_STATE #define APP_RES_PENDING_DUE_TO_SECURITY MBA_RES_PENDING_DUE_TO_SECURITY #define APP_RES_BUSY MBA_RES_BUSY ",
							" Description The definition of App Request Status ",
							" Macro Definition Macro Description APP_RES_SUCCESS Execution successfully APP_RES_FAIL Execution fail APP_RES_OOM Out of memory APP_RES_INVALID_PARA Invalid parameters APP_RES_NO_RESOURCE No resource APP_RES_BAD_STATE Bad State APP_RES_PENDING_DUE_TO_SECURITY Pending the request due to security process APP_RES_BUSY Execution fail due to system is busy ",
							" Error Codes Def-2 ",
							" C #define APP_RES_SUCCESS 0x0000 #define APP_RES_FAIL 0x0001 #define APP_RES_OOM 0x0002 #define APP_RES_INVALID_PARA 0x0003 #define APP_RES_NO_RESOURCE 0x0004 #define APP_RES_BAD_STATE 0x0005 #define APP_RES_PENDING_DUE_TO_SECURITY 0x0006 #define APP_RES_BUSY 0x0007 ",
							" Description The definition of App Request Status ",
							" Macro Definition Macro Description APP_RES_SUCCESS Execution successfully APP_RES_FAIL Execution fail APP_RES_OOM Out of memory APP_RES_INVALID_PARA Invalid parameters APP_RES_NO_RESOURCE No resource APP_RES_BAD_STATE Bad State APP_RES_PENDING_DUE_TO_SECURITY Pending the request due to security process APP_RES_BUSY Execution fail due to system is busy ",
							" APP_Timer ",
							" APP_Timer Defines ",
							" APP_TIMER_TIMEOUT ",
							" C #define APP_TIMER_10MS 0x0A #define APP_TIMER_12MS 0x0C #define APP_TIMER_18MS 0x12 #define APP_TIMER_30MS 0x1E #define APP_TIMER_50MS 0x32 #define APP_TIMER_100MS 0x64 #define APP_TIMER_500MS 0x1F4 #define APP_TIMER_1S 0x3E8 #define APP_TIMER_2S 0x7D0 #define APP_TIMER_3S 0xBB8 #define APP_TIMER_5S 0x1388 #define APP_TIMER_30S 0x7530 ",
							" Description The definition of the timeout value ",
							" Macro Definition Macro Description APP_TIMER_10MS 10ms timer APP_TIMER_12MS 12ms timer APP_TIMER_18MS 18ms timer APP_TIMER_30MS 30ms timer APP_TIMER_50MS 50ms timer APP_TIMER_100MS 100ms timer APP_TIMER_500MS 500ms timer APP_TIMER_1S 1s timer APP_TIMER_2S 2s timer APP_TIMER_3S 3s timer APP_TIMER_5S 5s timer APP_TIMER_30S 30s timer ",
							" APP_Timer Enums ",
							" APP_TIMER_TimerId_T ",
							" C typedef enum APP_TIMER_TimerId_T { APP_TIMER_ID_0 APP_TIMER_ID_1 APP_TIMER_ID_2 APP_TIMER_ID_3 APP_TIMER_ID_4 APP_TIMER_ID_5 APP_TIMER_TOTAL } APP_TIMER_TimerId_T; ",
							" Description The definition of Timer ID ",
							" Note Naming of the Elements provided are default and can be modified inside MCC Configuration Enumerator Description APP_TIMER_ID_0 App Timer ID 0 APP_TIMER_ID_1 App Timer ID 1 APP_TIMER_ID_2 App Timer ID 2 APP_TIMER_ID_3 App Timer ID 3 APP_TIMER_ID_4 App Timer ID 4 APP_TIMER_ID_5 App Timer ID 5 APP_TIMER_TOTAL Total App Timers ",
							" App_Timer Functions ",
							" APP_TIMER_IsTimerExisted ",
							" C bool APP_TIMER_IsTimerExisted(uint8_t timerId); ",
							" Description The function is used to check if a timer exists already ",
							" Parameters Parameter Description [in] timerId Timer ID See APP_TIMER_TimerId_T  ",
							" Return values Return value Description true This timer exites already false This timer doesn't exist ",
							" APP_TIMER_ResetTimer ",
							" C uint16_t APP_TIMER_ResetTimer(uint8_t timerId); ",
							" Description The function is used to re-start a timer Not available if the timer is one-shot and it has been expired ",
							" Parameters Parameter Description [in] timerId Timer ID See APP_TIMER_TimerId_T  ",
							" Return values Return value Description APP_RES_SUCCESS Reset a timer successfully APP_RES_FAIL Failed to reset the timer APP_RES_INVALID_PARA The timerId doesn't exist ",
							" APP_TIMER_SetTimer ",
							" C uint16_t APP_TIMER_SetTimer(uint8_t timerId uint32_t timeout bool isPeriodicTimer); ",
							" Description The function is used to set and start a timer ",
							" Parameters Parameter Description [in] timerId Timer ID See APP_TIMER_TimerId_T  [in] timeout Timeout value (unit: ms) [in] isPeriodicTimer Set as true to let the timer expire repeatedly with a frequency set by the timeout parameter Set as false to let the timer be a one-shot timer ",
							" Return values Return value Description APP_RES_SUCCESS Set and start a timer successfully APP_RES_FAIL Failed to start the timer APP_RES_OOM No available memory APP_RES_NO_RESOURCE Failed to create a new timer ",
							" APP_TIMER_StopTimer ",
							" C uint16_t APP_TIMER_StopTimer(uint8_t timerId); ",
							" Description The function is used to stop a timer ",
							" Parameters Parameter Description [in] timerId Timer ID See APP_TIMER_TimerId_T  ",
							" Return values Return value Description APP_RES_SUCCESS Stop a timer successfully APP_RES_FAIL Failed to stop the timer APP_RES_INVALID_PARA The timerId doesn't exist ",
							" Application Timer Service   Introduction  The application timer service can be used to provide timer service required for the application functionality Application timer service provides one shot or periodic timeout events for application    Application Timer Service usage with MPLAB Code Configurator(MCC)  This section explains the steps required by a user to develop/utlize this application timer service using MPLABx MCC Framework  Tip: New users of MPLAB Code Configurator (MCC) are recommended to go through the overview of MCC Users can add/remove different components like peripheral support and other wireless functionality by following steps mentioned here     Create a new MCC Harmony Project -- link for instructions  Ensure that wireless_system_pic32cxbz2_wbz45 repo is available locally in the development repo  Open MCC The Wireless System Service components will be displayed in available components -- Wireless -- System Services as shown in the below figure    Drag APP TIMER SERVICE component from available components to project graph area as shown in below figure Accept Dependencies or satisfiers select \"Yes\"  Click on the Device Support dependecny satisfiers to know the device supported for this service and select pic32cx_bz2_devsupport  Click on the APP_TIMER_SERVICE to know the capability consumers and link the required component which is in need of the appication timer service    Accept Dependencies or satisfiers select \"Yes\"  Select the APP TIMER SERVICE component and provide the required configuration for Timer IDs    Here for e g BLE sensor application in the project as shown in below figure  Generate the code Refer link for more details  After generating the program source from MCC interface by clicking Generate Code the application timer service can be found in the following project directories        User Application Development    Users can use the APP_TIMER_SetTimer API function to start the timer funcationlity for the provided Timer ID  The one shot timers will provide the required callback and post the message in the application task with the Timer message ID associated with the Timer ID provided  In app c file function APP_Tasks the posted task can be processed and executed for required functionalities within the APP_STATE_SERVICE_TASKS application state  Function APP_TIMER_StopTimer and APP_TIMER_ResetTimer can be used to stop the required timer ID and reset the required timer ID respectivly Refer the API details of APP TIMER for further details     ",
							" 15_4_P2P_Phy_App   15_4_P2P_Phy_App Defines  15_4_P2P_Phy_App Enums  15_4_P2P_Phy_App Structures  15_4_P2P_Phy_App Functions   ",
							" 15_4_P2P_Phy_App Defines   C  #define CHANNEL_TRANSMIT_RECEIVE 11U #define SRC_ADDR 0x1U #define IEEE_ADDR 0x1U #define SRC_PAN_ID 0xcafeU #define MAXBE 5U #define MINBE 3U #define CSMA_BACKOFF 4U #define FRAME_RETRY 3U #define CCA_MODE 1U #define TRANSMIT_POWER 4 #define APP_PAYLOAD_BUFFER_SIZE 500U #define DST_ADDR 0x2U #define DST_IEEE_ADDR 0x2U #define NUM_OF_DEVICES 64U #define ED_SCAN_DURATION 8U    Description  The definition of the PAN Network parameters and device specific parameters    Macro Definition   Configuration Parameters       Macro  Description      CHANNEL_TRANSMIT_RECEIVE  Device Operating Channel Frequency    SRC_ADDR  Source Device Address - 16 bits    IEEE_ADDR  Extended Address of the source Device - 64 bits    SRC_PAN_ID  Source PAN ID(if INTER PAN) / PAN ID(if INTRA PAN)    MAXBE  MAXIMUM BE    MINBE  MINIMUM BE    CSMA_BACKOFF  CSMA retries    FRAME_RETRY  MAC Level Retries    CCA_MODE  CCA Mode    TRANSMIT_POWER  Transmit Power    APP_PAYLOAD_BUFFER_SIZE  APP PAYLOAD BUFFER SIZE    DST_ADDR  Destination Device Short Address - 16 bits    DST_IEEE_ADDR  Destination Device IEEE Address - 64 bits    NUM_OF_DEVICES  No of Devices    ED_SCAN_DURATION  Energy Detection Scan Duration (in Symbols)       ",
							" 15_4_P2P_Phy_App Enums   APP_MODE_T  APP_TEST_MODE_T  APP_OP_STATE_T   ",
							" APP_Mode_T   C  typedef enum APP_Mode_T { APP_DATA_MODE APP_CONTINUOUS_DATA_TEST_MODE APP_PER_TEST_MODE APP_PROMISCUOUS_MODE APP_THROUGHPUT_TEST_MODE APP_LOOP_BACK_MODE APP_CMD_TASK_SUSPEND APP_RESUME_DATA_MODE APP_FRAGMENT_DATA_MODE APP_SYSTIMER_START_PERIODIC_TEST_MODE APP_SYSTIMER_EXPIRY_PERIODIC_TEST_MODE APP_SYSTIMER_EXPIRY_DATA_ENTRY }APP_Mode_T;    Description  The definition of different application modes Please refer Operating Modes of application and Command Table section for more details          Enumerator  Description      APP_DATA_MODE  APP DATA MODE    APP_CONTINUOUS_DATA_TEST_MODE  APP CONTINUOUS DATA_TEST MODE    APP_PROMISCUOUS_MODE  APP PROMISCUOUS MODE    APP_PER_TEST_MODE  APP_PER_TEST_MODE    APP_THROUGHPUT_TEST_MODE  APP_THROUGHPUT_TEST_MODE    APP_LOOP_BACK_MODE  APP LOOP BACK MODE    APP_CMD_TASK_SUSPEND  APP CMD TASK SUSPEND    APP_RESUME_DATA_MODE  APP RESUME DATA MODE    APP_FRAGMENT_DATA_MODE  APP FRAGMENT DATA MODE    APP_SYSTIMER_START_PERIODIC_TEST_MODE  APP SYSTIMER START PERIODIC TEST MODE    APP_SYSTIMER_EXPIRY_PERIODIC_TEST_MODE  APP SYSTIMER EXPIRY PERIODIC TEST MODE    APP_SYSTIMER_EXPIRY_DATA_ENTRY  APP SYSTIMER EXPIRY DATA ENTRY       ",
							" APP_TEST_Mode_T   C  typedef enum APP_TEST_MODE_T { PER_TEST_MODE PERIOD_TEST_MODE CONT_TEST_MODE PROM_TEST_MODE THROUGHPUT_TEST_MODE }APP_TEST_MODE_T;    Description  The definition of different application Test modes Please refer Operating Modes of application and Command Table section for more details          Enumerator  Description      PER_TEST_MODE  PER TEST MODE    PERIOD_TEST_MODE  PERIOD TEST MODE    CONT_TEST_MODE  CONT TEST MODE    PROM_TEST_MODE  PROM TEST MODE    THROUGHPUT_TEST_MODE  THROUGHPUT TEST MODE       ",
							" APP_OP_STATE_T   C  typedef enum { APP_STATE_TX_SUCCESS APP_STATE_TX_IN_PROGRESS APP_STATE_TX_FAILURE APP_STATE_TX_ACK APP_STATE_TX_NO_ACK APP_STATE_RX_SUCCESS APP_CCA_CHANNEL_ACCESS_SUCCESS APP_CCA_CHANNEL_ACCESS_FAILURE APP_ED_SCAN_INIT APP_ED_SCAN_IN_PROGRESS APP_PIB_ATTR_SET_SUCCESS APP_PIB_ATTR_SET_FAILURE APP_PIB_ATTR_OUT_OF_RANGE APP_TIMER_START APP_TIMER_IN_PROGRESS APP_TIMER_EXPIRED APP_TIMER_STOPPED }APP_OP_STATE_T;    Description  The definition of different application Operating States    Field Documentation        Enumerator  Description      APP_STATE_TX_SUCCESS APP_STATE_TX_IN_PROGRESS APP_STATE_TX_FAILURE APP_STATE_TX_ACK APP_STATE_TX_NO_ACK APP_STATE_RX_SUCCESS  Packet Transmit States    APP_ED_SCAN_INIT APP_ED_SCAN_IN_PROGRESS  ED Scan States    APP_CCA_CHANNEL_ACCESS_SUCCESS APP_CCA_CHANNEL_ACCESS_FAILURE  CCA result Status    APP_PIB_ATTR_SET_SUCCESS APP_PIB_ATTR_SET_FAILURE APP_PIB_ATTR_OUT_OF_RANGE  PIB Attribute Set Status using PHY_PibSet API    APP_TIMER_START APP_TIMER_IN_PROGRESS APP_TIMER_EXPIRED APP_TIMER_STOPPED  APP Timer Status if used       ",
							" 15_4_P2P_Phy_App Functions  void app_P2P_Phy_TransmitFrame(uint8_t *payload uint8_t payloadLength uint8_t devIndex uint8_t msduHandle bool unicast bool ackReq bool frameRetry); void app_P2P_Phy_setAddressModes(uint8_t srcAddressMode uint8_t dstAddressMode); void app_P2P_Phy_setFrameType(uint8_t frameType); void app_P2P_Phy_ConfigDataReception(void); void app_P2P_Phy_TaskHandler(APP_Msg_T *appModeSwitch); void app_P2P_Phy_packetErrorRateCal(uint64_t nPacketsSent uint64_t nBytesSent uint64_t nPacketsRecAck); PHY_Retval_t app_P2P_Phy_StartEdScan(void); void app_P2P_Phy_GetDeviceTableInfo(uint8_t dev_index); void app_P2P_Phy_SetDeviceTableInfo(uint8_t dev_index DEVICE_TABLE *devTable); APP_OP_STATE_T app_P2P_Phy_SetNWKParams(APP_NWK_PARAM *appnwkParam);  ",
							" 15_4_P2P_Phy_App Structures    DEVICE_TABLE  APP_NWK_PARAM  APP_STATES_PARAM Enter a short description of your topic here (optional)  SYSTIMER_FLAGS  MODE_SWITCH_FLAGS  APP_MODE_PARAMS    ",
							" DEVICE_TABLE   C  typedef struct { uint64_t ieeeAddr; uint16_t shortAddr; int8_t rssiVal; uint8_t lqi; uint64_t txPacketCnt; uint64_t rxPacketCnt; bool valid; }DEVICE_TABLE;    Description  The structure contains the PAN Network information about the self and peer devices In the application index 0 is reserved for self information To update the device table console commands can be used Please refer Command Table section for more details    Field Documentation   Application Configurations       Macro  Description      ieeeAddr  IEEE Address - 64 bits    shortAddr  Short Address - 16 bits    rssiVal  Received Signal Strength Indicator    lqi  Link Quality Indicator    txPacketCnt  Packets which got Transmit Done Callback    rxPacketCnt  Packets which got Ack from Peer Device    valid  Set to true if there is valid address in the corresponding index of device table       ",
							" APP_NWK_PARAM   CCA  CSMA  ED_SCAN    C  typedef struct { uint8_t channel; uint8_t channelPage; uint16_t srcPanId; uint16_t dstPanId; uint16_t srcAddress; uint64_t extendedSrcAddress; uint8_t srcAddrMode; uint16_t dstAddress; uint64_t extendedDstAddress; uint8_t dstAddrMode; int8_t txPowerDBm; uint8_t txPower; uint64_t ieeeAddress; uint64_t dstIeeeAddress; bool unicastFlagPredefData; bool unicastFlagUserDefData; PHY_Retval_t pibAttributeStatus; ED_SCAN edScan; CCA cca; CSMA csma; bool PromiscuousMode; uint8_t frameRetry; uint8_t maxBE; uint8_t minBE; bool ackReq; uint8_t frameType; uint8_t frameOverHead; uint64_t nPacketsSent; uint64_t nBytesSent; uint64_t nPacketsRcvdAck; PHY_Retval_t txStatusFrameSent; PHY_Retval_t txDoneCbStatus; uint64_t nPerTestPackets; } APP_NWK_PARAM;    Description  The structure contains the general PAN Network information about the devices (2 communicatng Peer Devices - Source and Destination Devices) To update the device table console commands can be used Please refer Command Table section for more details    Field Documentation        Field  Description      channel  Channel    channelPage  Channel Page    srcPanId  Source PAN ID 16 bits    dstPanId  Destination PAN ID 16 bits    srcAddress  Source Address - 16 bits    extendedSrcAddress  Extended Source Address - 64 bits    srcAddrMode  Source Address Mode    dstAddress  DestinationAddress - 16 bits    extendedDstAddress  Extended DestinationAddress - 64 bits    dstAddrMode  Destination Address Mode    txPowerDBm  Transmit Power in DBm    txPower  TX Power    ieeeAddress  Extended Source Address - 64 bits    dstIeeeAddress  Extended DestinationAddress - 64 bits    unicastFlagPredefData  Flag for Application purpose    unicastFlagUserDefData  Flag for Application purpose    pibAttributeStatus  Attribute Status structure to store status of pibGet and pibSet Attributes    edScan  ED Scan    cca  CCA    csma  CSMA    PromiscuousMode  Boolean to enable Promiscous RX Mode    frameRetry  MAC level Frame Retry    maxBE  MAX BE    minBE  MIN BE    ackReq  bool to enable/disable Ack request during packet Transmit    frameType  Type of frame to be transmitted    frameOverHead  No of overhead octets in TX frame    nPacketsSent  No of packets receiving TX Done CB    nBytesSent  No of bytes receiving TX Done CB    nPacketsRcvdAck  No of packets receiving Ack    txStatusFrameSent  Status of TX Frames Sent    txDoneCbStatus  Status of transmitted packets after TX Done Cb is recived    nPerTestPackets  No of packets sent in Packet Error Rate Test Mode       ",
							" CCA   C  typedef struct { uint8_t ccaMode; PHY_Retval_t ccaStatus; }CCA;    Description  The structure contains the information about Clear Channel Assessment (CCA) Mode and the status striucture holding the info on the result of performing CCA To perform CCA and read back status console commands can be used Please refer Command Table section for more details    Field Documentation        Field  Description      ccaMode  CCA Modes    ccaStatus  Status result of performing CCA       ",
							" CSMA   C  typedef struct { PHY_CSMAMode_t csmaMode; uint8_t csmaBackoff; }CSMA;    Description  The structure contains the information about CSMA parameters like CSMA Mode and CSMA retries To update read back the CSMA info console commands can be used Please refer Command Table section for more details    Field Documentation   Application Configurations       Macro  Description      csmaMode  CSMA Modes    csmaBackoff  CSMA Retries       ",
							" ED_SCAN   C  typedef struct { uint8_t edscanDurationSYMBOLS; PHY_Retval_t edStatus; }ED_SCAN;    Description  The structure contains the information about the Energy Detection (ED) Scan duration and status holding the info about the result of ED scan To perform ED scan and get the status console commands can be used Please refer Command Table section for more details    Field Documentation        Field  Description      edscanDurationSYMBOLS  ED Scan Duration in Symbols    edStatus  Status result of performing ED scan       ",
							" APP_STATES_PARAM Enter a short description of your topic here (optional)  This is the start of your topic  ",
							" SYSTIMER_FLAGS   C  typedef struct { SYS_TIME_RESULT timerStartPeriodicTestMode timerStartDataMode timerStopPeriodicTestMode timerStopDataMode; SYS_TIME_HANDLE sysTimerPeriodicTestModeHandle sysTimerDataModeHandle sysTimerThroughputHandle; uint32_t periodicSysTimer; uint32_t singleShotSysTimer; uint32_t throughputSysTimer; }SYSTIMER_FLAGS;    Description  The structure contains the member variables of SYS TIMER Handle SYS TIMER Result Structure and Timer variables of 32 bit in microseconds This variables are used to provide time in microsecs as input parameter for data modes and test modes For the app mode switching purpose console commands can be used Please refer Operating Modes of application and Command Table section for more details    Field Documentation        Field  Description      timerStartPeriodicTestMode timerStartDataMode timerStopPeriodicTestMode timerStopDataMode  SYS Timer Start Flags in different app modes    sysTimerPeriodicTestModeHandle sysTimerDataModeHandle sysTimerThroughputHandle  SYS Timer object Handle Flags in different app modes    periodicSysTimer  Periodic SYS Timer for Periodic Test Mode    singleShotSysTimer  Single Shot SYS Timer for Data Mode    throughputSysTimer  Throughput Test Mode SYS Timer       ",
							" MODE_SWITCH_FLAGS   C  typedef struct { bool enterDataMode; bool enterPeriodicTestMode; bool enterContTestMode; bool enterThroughputTestMode; bool throughputTimerCallback; bool enterPerTestMode; bool perTestMode; }MODE_SWITCH_FLAGS;    Description  The structure contains the flags to indicate the app switching between different modes For the app mode switching purpose console commands can be used Please refer Operating Modes of application and Command Table section for more details    Field Documentation        Field  Description      enterDataMode  Boolean flag to check if app has entered data mode    enterPeriodicTestMode  Boolean flag to check if app has entered Periodic Test mode    enterContTestMode  Boolean flag to check if app has entered Continuous Test mode    enterThroughputTestMode  Boolean flag to check if app has entered Throughput Test mode    throughputTimerCallback  Boolean flag to check if Throughput Timer Cb been called    enterPerTestMode  Boolean flag to check if app has entered PER Test Mode    perTestMode  Boolean flag set to True if 100 packets been sent       ",
							" APP_MODE_PARAMS   C  typedef struct { uint64_t nPacketsSent; uint64_t nBytesSent; uint64_t nPacketsRcvdAck; bool isModeActive; }APP_MODE_PARAMS;    Description  The structure contains the information about the no of packets transmitted no of bytes sent and no of packets which has received acknowledgement for each of the test Modes To operate different test modes console commands can be used Please refer Operating Modes of application and Command Table section for more details    Field Documentation        Field  Description      nPacketsSent  No of Packets Sent received TX Done Cb    nBytesSent  No of Bytes Sent    nPacketsRcvdAck  No of Packets which received Ack    isModeActive  Boolean to indicate if a selected test Mode is active or not        APPL_DATA_MODE  APPL_CNT_TEST_MODE  APPL_PERIOD_TEST_MODE  APPL_PER_TEST_MODE  APPL_THROUGHPUT_TEST_MODE   ",
							" APPL_DATA_MODE  APP_MODE_PARAMS   C  typedef struct { APP_MODE_PARAMS devPerformanceParam; }APPL_DATA_MODE;    Description  The structure contains the information about the no of packets transmitted no of bytes sent and no of packets which has received acknowledgement for app data Mode To operate different test modes console commands can be used Please refer Operating Modes of application and Command Table section for more details    Field Documentation        Field  Description      devPerformanceParam  Holds the info of device performance params like packets sent bytes sent packets which received ack for corresponding application mode       ",
							" APPL_CNT_TEST_MODE  APP_MODE_PARAMS   C  typedef struct { APP_MODE_PARAMS devPerformanceParam; }APPL_CNT_TEST_MODE;    Description  The structure contains the information about the no of packets transmitted no of bytes sent and no of packets which has received acknowledgement for app Continuous Test Mode To operate different test modes console commands can be used Please refer Operating Modes of application and Command Table section for more details    Field Documentation        Field  Description      devPerformanceParam  Holds the info of device performance params like packets sent bytes sent packets which received ack for corresponding application mode       ",
							" APPL_PERIOD_TEST_MODE  APP_MODE_PARAMS   C  typedef struct { APP_MODE_PARAMS devPerformanceParam; }APPL_PERIOD_TEST_MODE;    Description  The structure contains the information about the no of packets transmitted no of bytes sent and no of packets which has received acknowledgement for app Period Test Mode To operate different test modes console commands can be used Please refer Operating Modes of application and Command Table section for more details    Field Documentation        Field  Description      devPerformanceParam  Holds the info of device performance params like packets sent bytes sent packets which received ack for corresponding application mode       ",
							" APPL_PER_TEST_MODE  APP_MODE_PARAMS   C  typedef struct { APP_MODE_PARAMS devPerformanceParam; }APPL_PER_TEST_MODE;    Description  The structure contains the information about the no of packets transmitted no of bytes sent and no of packets which has received acknowledgement for app PER Test Mode To operate different test modes console commands can be used Please refer Operating Modes of application and Command Table section for more details    Field Documentation        Field  Description      devPerformanceParam  Holds the info of device performance params like packets sent bytes sent packets which received ack for corresponding application mode       ",
							" APPL_THROUGHPUT_TEST_MODE  APP_MODE_PARAMS   C  typedef struct { APP_MODE_PARAMS devPerformanceParam; }APPL_THROUGHPUT_TEST_MODE;    Description  The structure contains the information about the no of packets transmitted no of bytes sent and no of packets which has received acknowledgement for app Throughput Test Mode To operate different test modes console commands can be used Please refer Operating Modes of application and Command Table section for more details    Field Documentation        Field  Description      devPerformanceParam  Holds the info of device performance params like packets sent bytes sent packets which received ack for corresponding application mode       ",
							" Support Documentation This section has documentation that is generic and used as supporting document with our application example documentation ",
							"  User Action This document explains to users the code edits that are needed to be made after a user does code generation using MPLAB Code Configurator Developers are required to call API - app_idle_task() in vApplicationIdleHook() This is required to enable periodic Persistent Data Storage RF calibration Persistant Data Storage provides means for storing data in non-volatile memory(Flash) User application and stack parameters like peer connection etc are saved IDLE task is set to execute at the lowest priority in FreeRtos Users will be prompted to call app_idle_task() and app_idle_updateRtcCnt(RTC_Timer32CounterGet()) when they compile/build the project with a compile error action required to be taken users are required to open freertos_hooks c file and add #include \"definitions h\" users are required to open freertos_hooks c file and add API app_idle_task() users are required to comment out #error in app_user_edits c file Initiate build and user will be able to build successfully Note: User action is only required for the first time code gets generated Additional User Action when Low Power is enabled Developers are required to call app_idle_updateRtcCnt(RTC_Timer32CounterGet()) in vApplicationTickHook() This API call is used to compensate for FreeRTOSTimer when in sleep mode users are required to open freertos_hooks c file and add API app_idle_updateRtcCnt(RTC_Timer32CounterGet()) ",
							" MPLAB Code Configurator(MCC) Code Generation Generate code Select Generate Merge Strategy Understanding MCC Merge Window Tip: if a user wants to maintain the modifications made for their application code development they should select \"Close\" the merge window ",
							" Import existing App Example Configuration Users who want to implement a similar application based on the existing application examples provided by Microchip can choose to import the configuration so that they srart from a known good configuration Create a new MPLAB MCC Harmony Project Select the MPLAB Harmony option Select Finish Select Harmony Framework Default project graph will be loaded Close the MPLAB Code Configurator by clicking on the MCC option in IDE User should now overwrite the mc3 file created for the new MPLAB MCC Harmony Project (in step 1) with the mc3 file of the application example of their choice provided by Microchip For example we will now overwrite the mc3 file (created with the new MPLAB MCC Harmony Project)with mc3 file created for legacy advertisement application Reopen MCC to see if project graph has imported the components and the respective configuration for these components as expected ",
							" Porting Guide for WBZ451 to PIC32CX1012BZ25048 ",
							" Introduction  This document provides the steps that helps the user to port an existing project created for WBZ451 to PIC32CX101BZ25048  ",
							" Steps for porting an MCC project    Open an existing WBZ451 MCC project in MPLABx  Open Project properties by selecting customize option available in the drop down options    Change the Device name to PIC32CX1012BZ25048 and select the respective packs and compiler versions    Open the MCC by pressing the MCC button available at top in MPLABx and Accept('Yes') the project migration confirmation    While opening the MCC content manager Untick the \"Skip DFP and CMSIS Selection\" option in Harmony Framework Path selection window to Manually select the DFP path    Choose the dfp path(by Pressing 'Choose Path') to **Harmony Framework**(H3 framework stored in the disk)** dev_packs Microchip PIC32CX-BZ_DFP 1 0 107 BZ25 atdf PIC32CX1012BZ25048 atdf** and Press 'Next'   Note: The DFP path selection will allow to select the folder path In that case Manually choose the path till \"dev_packs Microchip PIC32CX-BZ_DFP 1 0 107 BZ25 atdf\" and Manully include \" PIC32CX1012BZ25048 atdf\" in the DFP path selection window  Choose the default selected CMSIS path and press 'Next'    Once MCC is opened the DFP will be available for the selected device can be seen by clicking on the DFP from project graph   Note: The DFP will be updated according to the device selected If MCC project graph window is not visible or the selected DFP doesn't match with the device selection In that case Choose the correct DFP path(refer step 6)  Save MCC configuration and enable **Force update on All** option(by right clicking onto the Project Resources Tab) Press Generate    Merge all the code differences shown in the merge window except Application files  Build and Flash the Project onto the device    ",
							" References  How to Generate Code using MCC  ",
							" Microchip Information ",
							" The Microchip Website  Microchip provides online support via our website at This website is used to make files and information easily available to customers Some of the content available includes:   Product Support – Data sheets and errata application notes and sample programs design resources user’s guides and hardware support documents latest software releases and archived software  General Technical Support – Frequently Asked Questions (FAQs) technical support requests online discussion groups Microchip design partner program member listing  Business of Microchip – Product selector and ordering guides latest Microchip press releases listing of seminars and events listings of Microchip sales offices distributors and factory representatives   ",
							" Product Change Notification Service  Microchip’s product change notification service helps keep customers current on Microchip products Subscribers will receive email notification whenever there are changes updates revisions or errata related to a specified product family or development tool of interest  To register go to and follow the registration instructions  ",
							" Customer Support  Users of Microchip products can receive assistance through several channels:   Distributor or Representative  Local Sales Office  Embedded Solutions Engineer (ESE)  Technical Support   Customers should contact their distributor representative or ESE for support Local sales offices are also available to help customers A listing of sales offices and locations is included in this document  Technical support is available through the website at:  ",
							" Microchip Devices Code Protection Feature  Note the following details of the code protection feature on Microchip products:   Microchip products meet the specifications contained in their particular Microchip Data Sheet  Microchip believes that its family of products is secure when used in the intended manner within operating specifications and under normal conditions  Microchip values and aggressively protects its intellectual property rights Attempts to breach the code protection features of Microchip product is strictly prohibited and may violate the Digital Millennium Copyright Act  Neither Microchip nor any other semiconductor manufacturer can guarantee the security of its code Code protection does not mean that we are guaranteeing the product is “unbreakable” Code protection is constantly evolving Microchip is committed to continuously improving the code protection features of our products   ",
							" Legal Notice  This publication and the information herein may be used only with Microchip products including to design test and integrate Microchip products with your application Use of this information in any other manner violates these terms Information regarding device applications is provided only for your convenience and may be superseded by updates It is your responsibility to ensure that your application meets with your specifications Contact your local Microchip sales office for additional support or obtain additional support at   THIS INFORMATION IS PROVIDED BY MICROCHIP \"AS IS\" MICROCHIP MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND WHETHER EXPRESS OR IMPLIED WRITTEN OR ORAL STATUTORY OR OTHERWISE RELATED TO THE INFORMATION INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE OR WARRANTIES RELATED TO ITS CONDITION QUALITY OR PERFORMANCE  IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT SPECIAL PUNITIVE INCIDENTAL OR CONSEQUENTIAL LOSS DAMAGE COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE INFORMATION OR ITS USE HOWEVER CAUSED EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE TO THE FULLEST EXTENT ALLOWED BY LAW MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THE INFORMATION OR ITS USE WILL NOT EXCEED THE AMOUNT OF FEES IF ANY THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THE INFORMATION  Use of Microchip devices in life support and/or safety applications is entirely at the buyer's risk and the buyer agrees to defend indemnify and hold harmless Microchip from any and all damages claims suits or expenses resulting from such use No licenses are conveyed implicitly or otherwise under any Microchip intellectual property rights unless otherwise stated  ",
							" Trademarks  The Microchip name and logo the Microchip logo Adaptec AVR AVR logo AVR Freaks BesTime BitCloud CryptoMemory CryptoRF dsPIC flexPWR HELDO IGLOO JukeBlox KeeLoq Kleer LANCheck LinkMD maXStylus maXTouch MediaLB megaAVR Microsemi Microsemi logo MOST MOST logo MPLAB OptoLyzer PIC picoPower PICSTART PIC32 logo PolarFire Prochip Designer QTouch SAM-BA SenGenuity SpyNIC SST SST Logo SuperFlash Symmetricom SyncServer Tachyon TimeSource tinyAVR UNI/O Vectron and XMEGA are registered trademarks of Microchip Technology Incorporated in the U S A and other countries  AgileSwitch APT ClockWorks The Embedded Control Solutions Company EtherSynch Flashtec Hyper Speed Control HyperLight Load Libero motorBench mTouch Powermite 3 Precision Edge ProASIC ProASIC Plus ProASIC Plus logo Quiet- Wire SmartFusion SyncWorld Temux TimeCesium TimeHub TimePictra TimeProvider TrueTime and ZL are registered trademarks of Microchip Technology Incorporated in the U S A  Adjacent Key Suppression AKS Analog-for-the-Digital Age Any Capacitor AnyIn AnyOut Augmented Switching BlueSky BodyCom Clockstudio CodeGuard CryptoAuthentication CryptoAutomotive CryptoCompanion CryptoController dsPICDEM dsPICDEM net Dynamic Average Matching DAM ECAN Espresso T1S EtherGREEN GridTime IdealBridge In-Circuit Serial Programming ICSP INICnet Intelligent Paralleling IntelliMOS Inter-Chip Connectivity JitterBlocker Knob-on-Display KoD maxCrypto maxView memBrain Mindi MiWi MPASM MPF MPLAB Certified logo MPLIB MPLINK MultiTRAK NetDetach Omniscient Code Generation PICDEM PICDEM net PICkit PICtail PowerSmart PureSilicon QMatrix REAL ICE Ripple Blocker RTAX RTG4 SAM-ICE Serial Quad I/O simpleMAP SimpliPHY SmartBuffer SmartHLS SMART-I S storClad SQI SuperSwitcher SuperSwitcher II Switchtec SynchroPHY Total Endurance Trusted Time TSHARC USBCheck VariSense VectorBlox VeriPHY ViewSpan WiperLock XpressConnect and ZENA are trademarks of Microchip Technology Incorporated in the U S A and other countries  SQTP is a service mark of Microchip Technology Incorporated in the U S A  The Adaptec logo Frequency on Demand Silicon Storage Technology and Symmcom are registered trademarks of Microchip Technology Inc in other countries  GestIC is a registered trademark of Microchip Technology Germany II GmbH Co KG a subsidiary of Microchip Technology Inc in other countries  All other trademarks mentioned herein are property of their respective companies  © Microchip Technology Incorporated and its subsidiaries All Rights Reserved  ISBN:  ",
							" Quality Management System   For information regarding Microchip’s Quality Management Systems please visit    ",
							" Worldwide Sales and Service          AMERICAS  ASIA/PACIFIC  ASIA/PACIFIC  EUROPE       Corporate Office  2355 West Chandler Blvd  Chandler AZ 85224-6199  Tel: 480-792-7200  Fax: 480-792-7277  Technical Support:   Web Address:   Atlanta  Duluth GA  Tel: 678-957-9614  Fax: 678-957-1455  Austin TX  Tel: 512-257-3370  Boston  Westborough MA  Tel: 774-760-0087  Fax: 774-760-0088  Chicago  Itasca IL  Tel: 630-285-0071  Fax: 630-285-0075  Dallas  Addison TX  Tel: 972-818-7423  Fax: 972-818-2924  Detroit  Novi MI  Tel: 248-848-4000  Houston TX  Tel: 281-894-5983  Indianapolis  Noblesville IN  Tel: 317-773-8323  Fax: 317-773-5453  Tel: 317-536-2380  Los Angeles  Mission Viejo CA  Tel: 949-462-9523  Fax: 949-462-9608  Tel: 951-273-7800  Raleigh NC  Tel: 919-844-7510  New York NY  Tel: 631-435-6000  San Jose CA  Tel: 408-735-9110  Tel: 408-436-4270  Canada - Toronto  Tel: 905-695-1980  Fax: 905-695-2078    Australia - Sydney  Tel: 61-2-9868-6733  China - Beijing  Tel: 86-10-8569-7000  China - Chengdu  Tel: 86-28-8665-5511  China - Chongqing  Tel: 86-23-8980-9588  China - Dongguan  Tel: 86-769-8702-9880  China - Guangzhou  Tel: 86-20-8755-8029  China - Hangzhou  Tel: 86-571-8792-8115  China - Hong Kong SAR  Tel: 852-2943-5100  China - Nanjing  Tel: 86-25-8473-2460  China - Qingdao  Tel: 86-532-8502-7355  China - Shanghai  Tel: 86-21-3326-8000  China - Shenyang  Tel: 86-24-2334-2829  China - Shenzhen  Tel: 86-755-8864-2200  China - Suzhou  Tel: 86-186-6233-1526  China - Wuhan  Tel: 86-27-5980-5300  China - Xian  Tel: 86-29-8833-7252  China - Xiamen  Tel: 86-592-2388138  China - Zhuhai  Tel: 86-756-3210040    India - Bangalore  Tel: 91-80-3090-4444  India - New Delhi  Tel: 91-11-4160-8631  India - Pune  Tel: 91-20-4121-0141  Japan - Osaka  Tel: 81-6-6152-7160  Japan - Tokyo  Tel: 81-3-6880- 3770  Korea - Daegu  Tel: 82-53-744-4301  Korea - Seoul  Tel: 82-2-554-7200  Malaysia - Kuala Lumpur  Tel: 60-3-7651-7906  Malaysia - Penang  Tel: 60-4-227-8870  Philippines - Manila  Tel: 63-2-634-9065  Singapore  Tel: 65-6334-8870  Taiwan - Hsin Chu  Tel: 886-3-577-8366  Taiwan - Kaohsiung  Tel: 886-7-213-7830  Taiwan - Taipei  Tel: 886-2-2508-8600  Thailand - Bangkok  Tel: 66-2-694-1351  Vietnam - Ho Chi Minh  Tel: 84-28-5448-2100    Austria - Wels  Tel: 43-7242-2244-39  Fax: 43-7242-2244-393  Denmark - Copenhagen  Tel: 45-4485-5910  Fax: 45-4485-2829  Finland - Espoo  Tel: 358-9-4520-820  France - Paris  Tel: 33-1-69-53-63-20  Fax: 33-1-69-30-90-79  Germany - Garching  Tel: 49-8931-9700  Germany - Haan  Tel: 49-2129-3766400  Germany - Heilbronn  Tel: 49-7131-72400  Germany - Karlsruhe  Tel: 49-721-625370  Germany - Munich  Tel: 49-89-627-144-0  Fax: 49-89-627-144-44  Germany - Rosenheim  Tel: 49-8031-354-560  Israel - Ra’anana  Tel: 972-9-744-7705  Italy - Milan  Tel: 39-0331-742611  Fax: 39-0331-466781  Italy - Padova  Tel: 39-049-7625286  Netherlands - Drunen  Tel: 31-416-690399  Fax: 31-416-690340  Norway - Trondheim  Tel: 47-72884388  Poland - Warsaw  Tel: 48-22-3325737  Romania - Bucharest  Tel: 40-21-407-87-50  Spain - Madrid  Tel: 34-91-708-08-90  Fax: 34-91-708-08-91  Sweden - Gothenberg  Tel: 46-31-704-60-40  Sweden - Stockholm  Tel: 46-8-5090-4654  UK - Wokingham  Tel: 44-118-921-5800  Fax: 44-118-921-5820       "];

