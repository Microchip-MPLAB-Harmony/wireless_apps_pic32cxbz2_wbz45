var SearchFiles = ["GUID-7663617B-0DD1-45FA-86B5-EB0778A5A424.html","GUID-4A40968E-8B6E-4C84-93B9-D31419BBBDA6.html","GUID-53253F80-1A8A-41EE-8A9D-C0ECBD08A6F9.html","GUID-38587445-E9CF-4BF1-9ECF-2B8E6F85BA2B.html","GUID-3533318C-9ECB-4770-AD96-1D2DC7C659F6.html","GUID-B7A921CE-929D-46FD-B74E-95E78116593A.html","GUID-2AD37FE2-1915-4E34-9A05-79E3810726D7.html","GUID-0D2F114A-B713-4B27-AC5E-4593D234D9B7.html","GUID-3504C96C-3B1A-40E5-AF97-A3270CA7EC77.html","GUID-A55E9342-CE44-4A91-86BB-FEC6706FCD1C.html","GUID-5DEB6FE0-1234-4A15-A805-E451B3E73825.html","GUID-B86E8493-D00D-46EF-8624-D412342147F0.html","GUID-EA74172C-595E-4A34-B359-D42EE443F0EC.html","GUID-FAC65B28-B78E-48AF-BCFE-2D63DC274CDB.html","GUID-3CC3561E-252E-43B9-BC8A-47DD108A0A46.html","GUID-17DABF04-E5D8-4201-A746-2FC244450A19.html","GUID-E8C0DDA5-3AD0-42A4-B4EF-BCB02811BF8C.html","GUID-897B75C0-387F-4AF8-B353-1F97A3B0BEC8.html","GUID-950762E2-DD5E-41CD-AAB4-895439CCFBC4.html","GUID-8C3372E5-CAB6-4923-9B59-E97022E1252D.html","GUID-7C948236-7D8E-45CA-9511-AB244B44BE64.html","GUID-7A350957-2010-468F-AF8D-0635373EF79D.html","GUID-741308A7-A912-4C74-BF94-D5C44132003D.html","GUID-B3B46369-F5B4-401B-8405-658BE34988F4.html","GUID-AB1A02BF-4F9B-4058-90D9-02BFB3136682.html","GUID-820CEA03-90AE-484F-87C9-9CF2CE652702.html","GUID-9A3C4C97-E09F-4FF9-878C-3873892445F4.html","GUID-3D0C03E0-8EFC-455C-970B-17EBE5CB8F78.html","GUID-3D0C03E0-8EFC-455C-970B-17EBE5CB8F78.html",
							"GUID-F9A0C390-C124-49A7-9F22-157D20BFBE5D.html","GUID-07EC83B7-CC28-4C55-8634-4B7F56A9DB36.html","GUID-0F3193BF-C61D-4DDB-9E98-7F0A444269A8.html","GUID-1968EFD4-E642-4715-B867-9A1A9087AC80.html","GUID-59D44A45-F1F0-46AF-A611-9720C8CE7E93.html","GUID-CB26EBC2-7D3B-454B-98D1-C29A3223ADE6.html","GUID-E1A0E9CA-311E-4F53-9C27-160173609975.html","GUID-92137358-930E-4654-9431-E8BA0E260468.html","GUID-D3F1BF46-F275-409B-A344-4DB9EAABC5E9.html","GUID-D320EA38-86CE-4C0B-8093-60C59E1F03AE.html","GUID-BAAA9A7D-DCB6-4ADB-820A-68D1E8B81B09.html","GUID-71834715-4833-43ED-A1ED-A2A72DDE48BC.html","GUID-B9333775-2F34-4B60-9429-E1B1B7F505FD.html","GUID-F9A40E74-7127-4C2C-B480-2746007AAEAE.html","GUID-994B6462-D0F1-4B8C-A97B-A9CBF20426C2.html","GUID-101C8B73-AD8E-4845-831A-DC498B147435.html","GUID-D7A53CEA-74B4-4CAA-A5D4-F69980188D1B.html","GUID-399616BF-E65E-43B3-9831-4B19472A5EF0.html","GUID-003E64BA-98A3-40EA-8417-ED7F09C14761.html","GUID-908446A4-F490-4063-9096-66C4831F9BE4.html","GUID-159581BB-D157-4A79-A4B0-7C9A9692449A.html","GUID-F2D3E8B2-1470-4065-82A4-A313FCBAC126.html","GUID-DF914131-7CEA-4CF1-8F13-C5872AAB7DC6.html","GUID-894A155C-558E-45FD-AA0C-1546AE00DE53.html","GUID-03033848-F789-4EF6-845B-0C7594868889.html","GUID-1DBEFA54-6B29-4BB3-8C75-9FD48DB81F3F.html","GUID-2624FC46-FF08-4D14-9FA0-25B260F81754.html","GUID-84A8D478-B715-4D83-8D8F-49E3F5AFE32C.html","GUID-70714605-ACB2-451F-87F0-66F97057949F.html","GUID-D392EA5B-9A98-4F73-8F52-BD4C9445CD4F.html","GUID-436FCDB1-1B96-4B4C-802C-0C61967DA657.html","GUID-6816EA2C-EDCC-48EC-9D99-BF8EAF56C5A1.html","GUID-5B01388B-241F-4BCF-9204-BE758BC2F97F.html","GUID-A3F96AEA-7517-4859-9799-149B152B5BC4.html","GUID-67C26DAC-FADD-4345-813A-DB4744C54C4D.html","GUID-E24160FD-C371-4A9C-99F3-CB7C84DFD5C6.html","GUID-931E0477-A4B1-4887-BC2C-370DC398B29C.html","GUID-E1A30ECC-1212-4B25-AE72-7EAF982C6D50.html","GUID-CDA62122-6D5D-4CDC-B1B7-3EB02C26552C.html","GUID-4A2BABB9-3C7D-45F1-BAD5-C7978B7429B5.html","GUID-CBFFF24C-4BA1-47FC-8AC4-7731929F39A5.html",
							"GUID-CBFFF24C-4BA1-47FC-8AC4-7731929F39A5.html",
							"GUID-CBFFF24C-4BA1-47FC-8AC4-7731929F39A5.html",
							"GUID-222AEAB9-376D-4929-9BD2-5C490840C896.html","GUID-92E7736F-5413-4A33-A7CB-4731DB34B39D.html",
							"GUID-92E7736F-5413-4A33-A7CB-4731DB34B39D.html",
							"GUID-92E7736F-5413-4A33-A7CB-4731DB34B39D.html",
							"GUID-92E7736F-5413-4A33-A7CB-4731DB34B39D.html",
							"GUID-FBB2BFC4-2C4B-4772-8FA0-983E5933D3D4.html",
							"GUID-FBB2BFC4-2C4B-4772-8FA0-983E5933D3D4.html",
							"GUID-FBB2BFC4-2C4B-4772-8FA0-983E5933D3D4.html",
							"GUID-2815D98C-88B9-44C6-8B5E-FC9DC91AB639.html",
							"GUID-2815D98C-88B9-44C6-8B5E-FC9DC91AB639.html",
							"GUID-2815D98C-88B9-44C6-8B5E-FC9DC91AB639.html",
							"GUID-2815D98C-88B9-44C6-8B5E-FC9DC91AB639.html",
							"GUID-01FF8B34-B517-435D-B4A7-10E11D215A5F.html",
							"GUID-01FF8B34-B517-435D-B4A7-10E11D215A5F.html",
							"GUID-01FF8B34-B517-435D-B4A7-10E11D215A5F.html",
							"GUID-01FF8B34-B517-435D-B4A7-10E11D215A5F.html",
							"GUID-B60E4C4F-5960-49AB-9D58-FA4478D807B6.html",
							"GUID-B60E4C4F-5960-49AB-9D58-FA4478D807B6.html",
							"GUID-B60E4C4F-5960-49AB-9D58-FA4478D807B6.html",
							"GUID-79AF944E-7E79-4F1B-A5C9-305D6E2F1C54.html",
							"GUID-79AF944E-7E79-4F1B-A5C9-305D6E2F1C54.html",
							"GUID-79AF944E-7E79-4F1B-A5C9-305D6E2F1C54.html",
							"GUID-79AF944E-7E79-4F1B-A5C9-305D6E2F1C54.html",
							"GUID-663C8EEC-EBB2-4718-AF16-0259D1634561.html",
							"GUID-663C8EEC-EBB2-4718-AF16-0259D1634561.html",
							"GUID-663C8EEC-EBB2-4718-AF16-0259D1634561.html",
							"GUID-86B0620A-487B-42E4-B14A-900C325C8F74.html",
							"GUID-86B0620A-487B-42E4-B14A-900C325C8F74.html",
							"GUID-86B0620A-487B-42E4-B14A-900C325C8F74.html",
							"GUID-86B0620A-487B-42E4-B14A-900C325C8F74.html",
							"GUID-DB38933D-09B1-4BD1-9BE8-3BC43C5870EB.html",
							"GUID-DB38933D-09B1-4BD1-9BE8-3BC43C5870EB.html",
							"GUID-DB38933D-09B1-4BD1-9BE8-3BC43C5870EB.html",
							"GUID-6A676CE1-9475-4B6D-AE01-8E4961BF00DC.html",
							"GUID-6A676CE1-9475-4B6D-AE01-8E4961BF00DC.html",
							"GUID-6A676CE1-9475-4B6D-AE01-8E4961BF00DC.html",
							"GUID-F280F94A-7926-43EF-9D5A-EBD53B9CDBC1.html",
							"GUID-F280F94A-7926-43EF-9D5A-EBD53B9CDBC1.html",
							"GUID-F280F94A-7926-43EF-9D5A-EBD53B9CDBC1.html",
							"GUID-E0701C6C-5685-4F72-8BB6-86C491F5106F.html",
							"GUID-E0701C6C-5685-4F72-8BB6-86C491F5106F.html",
							"GUID-E0701C6C-5685-4F72-8BB6-86C491F5106F.html",
							"GUID-159FB68F-FBE7-4DF3-AFE3-09B4E8767F48.html","GUID-974C2B95-A6F2-42E5-9AFC-57AB0C5507FF.html","GUID-D337D190-6F61-4EA0-AEE9-CA58B5C83335.html",
							"GUID-D337D190-6F61-4EA0-AEE9-CA58B5C83335.html",
							"GUID-D337D190-6F61-4EA0-AEE9-CA58B5C83335.html",
							"GUID-0E14539E-032F-4959-9669-CF515777EC50.html","GUID-940847B5-E800-48A3-9934-BDF510A9666D.html",
							"GUID-940847B5-E800-48A3-9934-BDF510A9666D.html",
							"GUID-940847B5-E800-48A3-9934-BDF510A9666D.html",
							"GUID-940847B5-E800-48A3-9934-BDF510A9666D.html",
							"GUID-940847B5-E800-48A3-9934-BDF510A9666D.html",
							"GUID-D5E7B8C5-9CB4-40A0-8DB9-3B4C6A66E8CE.html",
							"GUID-D5E7B8C5-9CB4-40A0-8DB9-3B4C6A66E8CE.html",
							"GUID-D5E7B8C5-9CB4-40A0-8DB9-3B4C6A66E8CE.html",
							"GUID-D5E7B8C5-9CB4-40A0-8DB9-3B4C6A66E8CE.html",
							"GUID-9DCAF883-CC0F-4D07-848D-D39C1DA512E5.html",
							"GUID-9DCAF883-CC0F-4D07-848D-D39C1DA512E5.html",
							"GUID-9DCAF883-CC0F-4D07-848D-D39C1DA512E5.html",
							"GUID-9DCAF883-CC0F-4D07-848D-D39C1DA512E5.html",
							"GUID-9DCAF883-CC0F-4D07-848D-D39C1DA512E5.html",
							"GUID-8BCCAF48-DE26-4E7B-A94D-A1560B775CC4.html",
							"GUID-8BCCAF48-DE26-4E7B-A94D-A1560B775CC4.html",
							"GUID-8BCCAF48-DE26-4E7B-A94D-A1560B775CC4.html",
							"GUID-8BCCAF48-DE26-4E7B-A94D-A1560B775CC4.html",
							"GUID-8BCCAF48-DE26-4E7B-A94D-A1560B775CC4.html",
							"GUID-D481FB40-2B38-4578-8BC7-9AA1AAE7F547.html",
							"GUID-D481FB40-2B38-4578-8BC7-9AA1AAE7F547.html",
							"GUID-D481FB40-2B38-4578-8BC7-9AA1AAE7F547.html",
							"GUID-184F3667-3719-4254-91C4-089B4E718F79.html",
							"GUID-184F3667-3719-4254-91C4-089B4E718F79.html",
							"GUID-184F3667-3719-4254-91C4-089B4E718F79.html",
							"GUID-184F3667-3719-4254-91C4-089B4E718F79.html",
							"GUID-FFB256C1-978B-428C-BBA5-5FDCC2A63E5E.html","GUID-53A92559-C8B7-4045-970D-455EB3B190E5.html",
							"GUID-53A92559-C8B7-4045-970D-455EB3B190E5.html",
							"GUID-53A92559-C8B7-4045-970D-455EB3B190E5.html",
							"GUID-53A92559-C8B7-4045-970D-455EB3B190E5.html",
							"GUID-A18401FE-608E-4562-9544-A14814D47777.html",
							"GUID-A18401FE-608E-4562-9544-A14814D47777.html",
							"GUID-A18401FE-608E-4562-9544-A14814D47777.html",
							"GUID-A18401FE-608E-4562-9544-A14814D47777.html",
							"GUID-3095456E-3B15-42F9-BCDA-E5E1337D0AA1.html","GUID-55B35426-69EB-4BCC-8F95-F6647E69BD46.html","GUID-332DFF7E-D9EC-4308-B212-7D8E6B36DAB8.html",
							"GUID-332DFF7E-D9EC-4308-B212-7D8E6B36DAB8.html",
							"GUID-332DFF7E-D9EC-4308-B212-7D8E6B36DAB8.html",
							"GUID-332DFF7E-D9EC-4308-B212-7D8E6B36DAB8.html",
							"GUID-4CF8DE3C-29BF-4F46-9C0C-17AF6E24421F.html",
							"GUID-4CF8DE3C-29BF-4F46-9C0C-17AF6E24421F.html",
							"GUID-4CF8DE3C-29BF-4F46-9C0C-17AF6E24421F.html",
							"GUID-4CF8DE3C-29BF-4F46-9C0C-17AF6E24421F.html",
							"GUID-BDEA426A-51E9-4C3D-B8B0-FAAC0279AD65.html","GUID-E0E5C82C-569C-4FFB-809D-929A67D9AB6B.html",
							"GUID-E0E5C82C-569C-4FFB-809D-929A67D9AB6B.html",
							"GUID-E0E5C82C-569C-4FFB-809D-929A67D9AB6B.html",
							"GUID-95651E94-1B2F-4659-8B0B-FD1795A0ED6A.html","GUID-E59A9B66-D83B-4CAD-8348-562FB613CC35.html",
							"GUID-E59A9B66-D83B-4CAD-8348-562FB613CC35.html",
							"GUID-E59A9B66-D83B-4CAD-8348-562FB613CC35.html",
							"GUID-E59A9B66-D83B-4CAD-8348-562FB613CC35.html",
							"GUID-C6AFAD38-982A-4C34-99F8-C00B7B4273BB.html",
							"GUID-C6AFAD38-982A-4C34-99F8-C00B7B4273BB.html",
							"GUID-C6AFAD38-982A-4C34-99F8-C00B7B4273BB.html",
							"GUID-C6AFAD38-982A-4C34-99F8-C00B7B4273BB.html",
							"GUID-A414641C-76BE-469B-9072-FC17022ADFF5.html",
							"GUID-A414641C-76BE-469B-9072-FC17022ADFF5.html",
							"GUID-A414641C-76BE-469B-9072-FC17022ADFF5.html",
							"GUID-A414641C-76BE-469B-9072-FC17022ADFF5.html",
							"GUID-4C7F16E0-6963-4C6C-9BAC-9AE0D41789B7.html",
							"GUID-4C7F16E0-6963-4C6C-9BAC-9AE0D41789B7.html",
							"GUID-4C7F16E0-6963-4C6C-9BAC-9AE0D41789B7.html",
							"GUID-4C7F16E0-6963-4C6C-9BAC-9AE0D41789B7.html",
							"GUID-CA0E784B-D0E6-4D70-B485-6D9E6022B744.html",
							"GUID-CA0E784B-D0E6-4D70-B485-6D9E6022B744.html",
							"GUID-CA0E784B-D0E6-4D70-B485-6D9E6022B744.html",
							"GUID-CA0E784B-D0E6-4D70-B485-6D9E6022B744.html",
							"GUID-CA0E784B-D0E6-4D70-B485-6D9E6022B744.html",
							"GUID-58B9BA26-60FE-4271-B40C-7EC8F4F7B192.html",
							"GUID-58B9BA26-60FE-4271-B40C-7EC8F4F7B192.html",
							"GUID-58B9BA26-60FE-4271-B40C-7EC8F4F7B192.html",
							"GUID-58B9BA26-60FE-4271-B40C-7EC8F4F7B192.html",
							"GUID-58B9BA26-60FE-4271-B40C-7EC8F4F7B192.html",
							"GUID-84FD86A5-5EF7-4B41-B2AE-4FE3C18C13BB.html","GUID-61F29AB6-C3E0-44E4-B77A-DC259FD83C2C.html",
							"GUID-61F29AB6-C3E0-44E4-B77A-DC259FD83C2C.html",
							"GUID-61F29AB6-C3E0-44E4-B77A-DC259FD83C2C.html",
							"GUID-61F29AB6-C3E0-44E4-B77A-DC259FD83C2C.html",
							"GUID-4DF9729B-BAFC-4305-B4B5-577F28797F81.html",
							"GUID-4DF9729B-BAFC-4305-B4B5-577F28797F81.html",
							"GUID-4DF9729B-BAFC-4305-B4B5-577F28797F81.html",
							"GUID-4DF9729B-BAFC-4305-B4B5-577F28797F81.html",
							"GUID-E28C9796-BFFB-4D8D-85E8-3D32F3F3CC53.html",
							"GUID-E28C9796-BFFB-4D8D-85E8-3D32F3F3CC53.html",
							"GUID-E28C9796-BFFB-4D8D-85E8-3D32F3F3CC53.html",
							"GUID-E28C9796-BFFB-4D8D-85E8-3D32F3F3CC53.html",
							"GUID-927B1C36-F5B5-48D8-8F28-D8A4FE5026F8.html",
							"GUID-927B1C36-F5B5-48D8-8F28-D8A4FE5026F8.html",
							"GUID-927B1C36-F5B5-48D8-8F28-D8A4FE5026F8.html",
							"GUID-927B1C36-F5B5-48D8-8F28-D8A4FE5026F8.html",
							"GUID-0904E9A3-4DFA-48B3-B59C-5A4A911E07C9.html",
							"GUID-0904E9A3-4DFA-48B3-B59C-5A4A911E07C9.html",
							"GUID-0904E9A3-4DFA-48B3-B59C-5A4A911E07C9.html",
							"GUID-0904E9A3-4DFA-48B3-B59C-5A4A911E07C9.html",
							"GUID-2262C95D-85A7-48DD-A78C-F57E5917141B.html","GUID-8BBF5057-BBDA-491E-8DFE-7DFEF244DD81.html","GUID-5AF018E7-5002-44C7-8C0F-AE7D83BDA49D.html",
							"GUID-5AF018E7-5002-44C7-8C0F-AE7D83BDA49D.html",
							"GUID-5AF018E7-5002-44C7-8C0F-AE7D83BDA49D.html",
							"GUID-5AF018E7-5002-44C7-8C0F-AE7D83BDA49D.html",
							"GUID-6987A03A-ADB1-42E6-918B-E0AB1447964C.html",
							"GUID-6987A03A-ADB1-42E6-918B-E0AB1447964C.html",
							"GUID-6987A03A-ADB1-42E6-918B-E0AB1447964C.html",
							"GUID-6987A03A-ADB1-42E6-918B-E0AB1447964C.html",
							"GUID-37C0393D-F38C-4BC7-BF76-B5B7F01A9CF8.html","GUID-A8FBF1F1-80DD-42AA-82E8-3935CBABFB82.html","GUID-A7AE34A9-87E8-4AC1-8D72-8002DBC06789.html",
							"GUID-A7AE34A9-87E8-4AC1-8D72-8002DBC06789.html",
							"GUID-A7AE34A9-87E8-4AC1-8D72-8002DBC06789.html",
							"GUID-A7AE34A9-87E8-4AC1-8D72-8002DBC06789.html",
							"GUID-5DBE9129-D654-406C-9A3F-460A39626F1F.html","GUID-DD9E2B64-B9E7-4B9F-B28A-ECF9A4668A89.html",
							"GUID-DD9E2B64-B9E7-4B9F-B28A-ECF9A4668A89.html",
							"GUID-DD9E2B64-B9E7-4B9F-B28A-ECF9A4668A89.html",
							"GUID-DD9E2B64-B9E7-4B9F-B28A-ECF9A4668A89.html",
							"GUID-BBDEFB96-FD29-4302-927D-CD4E2CDFBCD8.html","GUID-22E72B1B-A789-4A9B-85FD-C1830AE41DD6.html",
							"GUID-22E72B1B-A789-4A9B-85FD-C1830AE41DD6.html",
							"GUID-22E72B1B-A789-4A9B-85FD-C1830AE41DD6.html",
							"GUID-22E72B1B-A789-4A9B-85FD-C1830AE41DD6.html",
							"GUID-22E72B1B-A789-4A9B-85FD-C1830AE41DD6.html",
							"GUID-4078553E-F3E2-4E02-8F41-2D9C261A8DF9.html",
							"GUID-4078553E-F3E2-4E02-8F41-2D9C261A8DF9.html",
							"GUID-4078553E-F3E2-4E02-8F41-2D9C261A8DF9.html",
							"GUID-4078553E-F3E2-4E02-8F41-2D9C261A8DF9.html",
							"GUID-4078553E-F3E2-4E02-8F41-2D9C261A8DF9.html",
							"GUID-6D689B6A-8D10-44E3-8C28-0D17E58D870B.html",
							"GUID-6D689B6A-8D10-44E3-8C28-0D17E58D870B.html",
							"GUID-6D689B6A-8D10-44E3-8C28-0D17E58D870B.html",
							"GUID-6D689B6A-8D10-44E3-8C28-0D17E58D870B.html",
							"GUID-6D689B6A-8D10-44E3-8C28-0D17E58D870B.html",
							"GUID-BFBA4374-C877-4873-A71E-6E5324F5324F.html",
							"GUID-BFBA4374-C877-4873-A71E-6E5324F5324F.html",
							"GUID-BFBA4374-C877-4873-A71E-6E5324F5324F.html",
							"GUID-BFBA4374-C877-4873-A71E-6E5324F5324F.html",
							"GUID-BFBA4374-C877-4873-A71E-6E5324F5324F.html",
							"GUID-5FC6D5A2-B8C3-4AD8-AC31-0AABE237A2F7.html","GUID-99583057-8B1A-42F2-84E8-CFC7717FA5D1.html","GUID-9C28F407-4879-4174-9963-2CF34161398E.html","GUID-F8FE2886-8A2C-4FC0-9956-C094CE44D162.html","GUID-0FB3F908-88EE-45CE-94F5-E97AF9049C9B.html","GUID-7551DC67-D79D-4F0C-B56F-7B17E12400E0.html","GUID-CDA512D8-0DE4-4672-8716-04CAC681CB38.html","GUID-F05182E4-B102-4775-A746-1FF37F465312.html","GUID-E8251634-7B15-4073-A103-5A5F128B8699.html","GUID-125F1A93-76CC-4BD7-BACA-01844FBD5F4F.html","GUID-21750586-F9F2-4E33-87FB-8F2994BF4744.html","GUID-07985EED-D525-413B-AEFE-78B563328687.html","GUID-02A694CF-88A5-4ADA-8785-7EEEC62D66EA.html"];

var SearchTitles = ["Introduction",
"Getting Started with WBZ451 Curiosity Board",
"Hardware",
"Preprogrammed Demo Software",
"BLE Demo Experience",
"Next Steps",
"Getting Started with Software Development",
"Install IDE and Compiler",
"Install Device Family Part Pack",
"Install MCC Plugin",
"Install Harmony 3 Dependencies",
"Creating a new MCC Harmony Project",
"Running a Precompiled Application Example",
"Next Steps",
"BLE Applications",
"Building Block Examples",
"Central",
"Central - FreeRTOS BLE Stack and App Initialize",
"BLE Legacy Scan",
"BLE Scanning Extended Advertisements",
"BLE Connection",
"BLE Transparent UART",
"BLE Multilink Transparent UART",
"Peripheral",
"Peripheral - FreeRTOS BLE Stack and App Initialize",
"BLE Sleep Mode Legacy Advertisements",
"BLE Extended Advertisements",
"BLE Deep Sleep Advertising",
"Known Issue:",
"BLE Connection",
"BLE Transparent UART",
"BLE Custom service",
"BLE Multilink Transparent UART",
"BLE Multirole Multilink Transparent UART",
"Chip Peripherals",
"UART -- Hello World",
"Advanced Applications",
"BLE Sensor App",
"Protocol Exchange",
"BLE Throughput",
"BLE Virtual Sniffer",
"How-to: Adding Chip Peripherals",
"How-to: Low Power Design",
"Low Power Design on PIC32CXBZ2 Devices",
"Low Power BLE Application Design",
"How-to: Firmware and OTA Updates",
"Bootloader",
"Device Firmware Upgrade Over Serial",
"Device Firmware Upgrade Over BLE",
"BLE OTA DFU Firmware Architecture",
"Memory Management",
"Microchip defined BLE OTA DFU Profile",
"BLE OTA DFU Image File Definition",
"BLE OTA DFU Image Distribution Procedure",
"BLE OTA DFU Implementation",
"MCC Component and Code Generation",
"OTA Application Development",
"Project Properties Configuration for Current/Running Firmware",
"Unified Image Generation",
"Programming the Current Application Image using MPLABX IDE",
"Upgradable image bin file generation",
"BLE OTA DFU Demo",
"Microchip Utility Tool",
"Introduction",
"Serial Bootloader Demo",
"Programming using IPECMD exe",
"Wireless System Services API",
"BLE_OTA",
"BLE_OTA Enums",
"APP_OTA_HDL_Mode_T",
"C",
"Description",
"BLE_OTA Functions",
"APP_OTA_EvtHandler",
"C",
"Description",
"Parameters",
"APP_OTA_HDL_Complete",
"C",
"Description",
"APP_OTA_HDL_ErrorHandle",
"C",
"Description",
"Parameters",
"APP_OTA_HDL_GetOTAMode",
"C",
"Description",
"Return values",
"APP_OTA_HDL_Init",
"C",
"Description",
"APP_OTA_HDL_Prepare",
"C",
"Description",
"Parameters",
"APP_OTA_HDL_Reset",
"C",
"Description",
"APP_OTA_HDL_SetOTAMode",
"C",
"Description",
"Parameters",
"APP_OTA_HDL_Start",
"C",
"Description",
"APP_OTA_HDL_Updating",
"C",
"Description",
"APP_OTA_Reboot_Handler",
"C",
"Description",
"APP_OTA_Timeout_Handler",
"C",
"Description",
"BLE_Conn_Handler",
"BLE_Conn_Handler Enums",
"APP_BLE_LinkState_T",
"C",
"Description",
"BLE_Conn_Handler Functions",
"APP_BleGapConnEvtHandler",
"C",
"Description",
"Events generated",
"Parameters",
"APP_GetBleState",
"C",
"Description",
"Return values",
"APP_GetConnHandleByIndex",
"C",
"Description",
"Parameters",
"Return values",
"APP_GetConnInfoByConnHandle",
"C",
"Description",
"Parameters",
"Return values",
"APP_InitConnList",
"C",
"Description",
"APP_SetBleState",
"C",
"Description",
"Parameters",
"BLE_Conn_Handler Structures",
"APP_BLE_ConnData_T",
"C",
"Description",
"Field Documentation",
"APP_BLE_ConnList_T",
"C",
"Description",
"Field Documentation",
"APP_TRPS",
"APP_TRPS Defines",
"Control Response ID status Length",
"C",
"Description",
"Macro Definition",
"Maximum Control List Size",
"C",
"Description",
"Macro Definition",
"APP_TRPS Enums",
"APP_TRPS_CTRL_STATUS_CODE_T",
"C",
"Description",
"APP_TRPS Functions",
"APP_TRPS_ConnEvtProc",
"C",
"Description",
"Parameters",
"APP_TRPS_deInit",
"C",
"Description",
"Parameters",
"APP_TRPS_DiscEvtProc",
"C",
"Description",
"Parameters",
"APP_TRPS_EventHandler",
"C",
"Description",
"Parameters",
"APP_TRPS_Init",
"C",
"Description",
"Parameters",
"Return values",
"APP_TRPS_SendNotification",
"C",
"Description",
"Parameters",
"Return values",
"APP_TRPS Structures",
"APP_TRPS_CmdResp_T",
"C",
"Description",
"Field Documentation",
"APP_TRPS_ConnList_T",
"C",
"Description",
"Field Documentation",
"APP_TRPS_Ctrl_T",
"C",
"Description",
"Field Documentation",
"APP_TRPS_CtrlCmd_T",
"C",
"Description",
"Field Documentation",
"APP_TRPS_NotifyData_T",
"C",
"Description",
"Field Documentation",
"APP_ERROR_DEF",
"APP_ERROR_DEF Defines",
"Error Codes Def-1",
"C",
"Description",
"Macro Definition",
"Error Codes Def-2",
"C",
"Description",
"Macro Definition",
"APP_Timer",
"APP_Timer Defines",
"APP_TIMER_TIMEOUT",
"C",
"Description",
"Macro Definition",
"APP_Timer Enums",
"APP_TIMER_TimerId_T",
"C",
"Description",
"Note",
"App_Timer Functions",
"APP_TIMER_IsTimerExisted",
"C",
"Description",
"Parameters",
"Return values",
"APP_TIMER_ResetTimer",
"C",
"Description",
"Parameters",
"Return values",
"APP_TIMER_SetTimer",
"C",
"Description",
"Parameters",
"Return values",
"APP_TIMER_StopTimer",
"C",
"Description",
"Parameters",
"Return values",
"Support Documentation",
"User Action",
"MPLAB Code Configurator(MCC) Code Generation",
"Import existing App Example Configuration",
"Microchip Information",
"The Microchip Website",
"Product Change Notification Service",
"Customer Support",
"Microchip Devices Code Protection Feature",
"Legal Notice",
"Trademarks",
"Quality Management System",
"Worldwide Sales and Service"];

var SearchInfo = [" Introduction This document covers evaluation development environment setup and application examples documentation to enable users create their product using PIC32CXBZ2_WBZ45 devices Users can evaluate the development platform by running the preprogrammed demo example BLE Sensor Application demo experience or running the precompiled appplication examples Documentation describing steps to test and develop the precompiled BLE application examples The precompiled application examples are a combination of simple and advanced applications Simple application examples otherwise referred to as building blocks provide user basic BLE Applications which cover individual concepts like advertisement (legacy and extended) data transer using a profile and service The advanced applications showcase more complex applications which involve multiple digital/analog peripherals running in parallel while maintaining a BLE link We recommend a user run the preprogrammed demo example then install the tool chain and other application examples run some of the precompiled application examples of interest and then start developing their own application by choosing a application example that best suits their needs The table below provides a list of resources available and a summary of information the sections within this documentation cover Section Concepts covered Getting Started with WBZ451 Curiosity Board This section covers evaluation board features and running the preprogrammed demo example Evaluation Board Features Running the preprogrammed demo example Getting Started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC Steps to install IDE tool chain BLE stacks and application examples on your PC BLE Applications Documentation describing steps to test and develop the precompiled BLE application examples Documentation describing steps to test and develop the precompiled application examples developed by us Chip Peripherals Guidance on how to add analog/digital peripherals to your application Guidance on how to add analog/digital peripherals to your application Low Power Design Enable low power modes - Sleep/Standby or Deep Sleep/Backup Modes in your design Enable low power modes - Sleep/Standby or Deep Sleep/Backup Modes in your design Bootloader and Device Firmware Upgrade This section documents how to enable FW updates in your design whether its serial or over the air Enable FW updates in your design whether its serial or over the air Support Documentation This section has documentation that is generic and used as supporting document with our application example documentation Documentation that is generic and used as supporting document with our application example documentation ",
							" Getting Started with WBZ451 Curiosity Board This section covers evaluation board features and running the preprogrammed demo example ",
							" Hardware The WBZ451 Curiosity Board is an efficient and modular development platform that supports rapid prototyping and demonstrates the features capabilities and interfaces of Microchip's BLE+Zigbee RF Module WBZ451 This board offers integrated programming/debugging features using PICkit™ On-Board (PKOB4) debugger and requires only a micro-USB cable to power-up and program the board Users can expand its functionality through MikroElectronika mikroBUS™ Click™ adapter boards and do rapid prototyping utilizing the BLE+Zigbee enabled RF Module The WBZ451 Curiosity Board supports a variety of applications such as wireless lighting home automation/Internet of Things (IoT) industrial automation and other BLE or Zigbee related applications Features WBZ451 BLE+Zigbee RF Module USB or Battery Powered On-board Programmer/Debug Circuit using PKoB4 based on Microchip SAME70 MCU Microchip MCP73871 Li-Ion/LiPo Battery Charger with Power Path Management On-board USB to UART Serial Converter with HW Flow Control based on Microchip MCP2200 mikroBUS™ Socket to Expand Functionality using MikroElectronika Click™ Adapter Boards RGB Lighting LED connected to PWM Reset Switch One User Configurable Switch One User LED • 32 768 kHz Crystal Microchip SST26VF064B 64 Mbit External QSPI Flash Microchip MCP9700A Low Power Analog Voltage Temperature Sensor 10 pin ARM SWD Header for External Programmer/Debugger WBZ451 Curiosity Board WBZ451 Curiosity Board Top View WBZ450 Curiosity Board WBZ451 Curiosity Board Bottom View ",
							" Preprogrammed Demo Software BLE Sensor Application demo experience Your WBZ451 Curiosity Board comes pre-programmed with example software that demonstrates two common BLE use-cases in a single application: BLE Sensor monitoring and BLE Lighting control The pre-programmed software implements a fully functional BLE Temperature Sensor The Curiosity on-board temperature sensor data is regularly read and made available via both advertising information (thus available without needing to connect) and also updated periodically after a BLE connection is initiated The pre-programmed software also implements full BLE control for the RGB LED populated on the Curiosity Board Once connected a user can control the LED's brightness color and on/off state via BLE Additionally the on/off state is made available via advertising information so that a user can know the status without connecting ",
							" BLE Demo Experience The demo consists of the WBZ451 Curiosity board with accompanying ble_senor_app Firmware the Microchip Bluetooth Data (MBD) Smartphone App The MBD app has the capability to scan for BLE Advertisements from WBZ451 module and to establish a connection Scan operation monitors temperature sensor and status of RGB LED (on or off) Establishing a BLE connection with WBZ451 module enables users to control the RGB status (on or off) as well as intensity and color of the RGB LED using slide controls BLE Sensor App Demo Install the Microchip Bluetooth Data (MBD) Smartphone App iOS/Android users can search for “Microchip Bluetooth Data” App in App Store and install Enable Bluetooth on the Smartphone Launch the MBD Smartphone App Supply power to WBZ451 Curiosity Board Connect a USB cable to the kit or a 4 2V Li-ion/Li-Po Battery For more information refer to the Power Supply section of the PIC32CX-BZ25 and WBZ451 Curiosity Board User's Guide The user-programmable blue LED starts blinking on the Curiosity Board when the board is in advertisement mode Monitor RGB LED state and Temperature WBZ451 Curiosity Board starts in advertisement mode to advertise its presence on a smartphone and to allow access to RGB LED on/off state and temperature sensor data Navigate through the Smartphone App as shown in the following figure to access the advertisement information Control RGB LED state on/off as well as intensity and color Click the device that shows up after initiating a scan to establish a connection with WBZ451 module The user programmable blue LED becomes solid once connection is established between the smartphone and WBZ451 module Controls the RGB LED state on/off Controls the color of RGB LED when the LED is “on” Controls the intensity of RGB LED when the LED is “on” Additional information To disconnect the MBD Application running on your smart phone you can do one of the following: Press the reset button on WBZ451 Curiosity Board Initiating a “Scan” on Smartphone App Upon successful disconnection the WBZ451 module starts in Advertisement Mode ",
							" Next Steps How to start developing your application The WBZ451 Curiosity Board is a fully functioning MCU for prototyping and developing your next BLE Application Once you a finished experimenting with the preprogrammed demo it is time to get your hands dirty and start building When you are ready to start developing code we recommend first reading the Getting Started with Software Development Guide Steps to install IDE compiler tool chain BLE stacks and application examples on your PC After you have set up your development environment then you can find (and compile and reprogram if necessary) the source code that implements the Preprogrammed Demo Software BLE Sensor Application demo experience from the Harmony 3 github repository Documentation and link to the repository can be found in BLE Sensor App ",
							" Getting Started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC  Prior to each release our Wireless Stack and Application Examples are thoroughly tested against a snapshot of tool versions and other software dependencies This guide will walk you through setting up your development environment with all required dependencies versions  Each section of this Guide will describe in detail the steps to fulfill all dependencies If you are already familiar Microchip Tools then you can find a table summarizing the dependencies below   Tools and Harmony Component Versions    Tool Chain         IDE Compiler and MCC plugin    Version    Location      MPLAB X IDE    6 00 or above    Web      XC32 Compiler    v4 10 or above    Web      Microchip Code Configurator(MCC)    5 1 9 or above    MPLAB X IDE Tools Plugins Installing MPLAB Code Configurator Plugin        Harmony Components        Harmony components to be cloned with MCC Content Manager    Version      csp    3 13 0      core    3 11 0      mhc    3 8 3      dev_packs    3 13 0      bsp    3 13 0      CMSIS-FreeRTOS    10 3 1      crypto    3 7 4      wolfssl    4 7 0      PIC32CX-BZ_DFP    1 0 107      wireless_ble    1 0 0      wireless_system_pic32cxbz_wbz    1 0 0      wireless_apps_pic32cxbz2_wbz45    1 0 0      wireless_pic32cxbz_wbz    1 0 0       ",
							" Install IDE and Compiler Links to Install MPLAB x IDE and Compiler Install the MPLAB X IDE Install the XC32 Compiler ",
							" Install Device Family Part Pack PIC32CXBZ Device Support is handled by Device Family Part Pack installation Installing PIC32CXBZ2 DFP Open the MPLAB X IDE and Select Tools Packs Search for \"BZ2\" in the search box available and select \"install\" Intrroduction to DFP gives background information on usage of Device Family Part Pack in application development ",
							" Install MCC Plugin Installing MPLAB Code Configurator Plugin Install MCC Plugin in the IDE Install MCC Plugin Install MCC Plugin Plugins Plugins MPLAB Code Configuration Plugin Configure the plugin options Plugin Options Several aspects of the operation of the MCC can be managed by using the “Options” panel (see figure below) which can be invoked by clicking Tools → Options → Plugins → MPLAB Code Configurator in the menu bar of the MPLAB X IDE ",
							" Install Harmony 3 Dependencies This section will describe in detail how to install the correct versions of the required Harmony 3 component dependencies The following table summarizes the components and versions that will be installed Harmony Components Harmony components to be cloned with MCC Content Manager Version csp 3 13 0 core 3 11 0 mhc 3 8 3 dev_packs 3 13 0 bsp 3 13 0 CMSIS-FreeRTOS 10 3 1 crypto 3 7 4 wolfssl 4 7 0 PIC32CX-BZ_DFP 1 0 107 wireless_ble 1 0 0 wireless_system_pic32cxbz_wbz 1 0 0 wireless_apps_pic32cxbz2_wbz45 1 0 0 wireless_pic32cxbz_wbz 1 0 0 Clone the Harmony repositories using MCC Content Manager Wizard Create a new “MCC Harmony” project (In order to clone the Harmony repositories user needs to create an empty project and clone the required repositories) Select \"New Project\" New Project Creation Select \"32-bit MCC Harmony Project\" MCC Harmony Project option Framework Selection Framework Selection Local PC directory where cloned repos would be placed Project Settings Project Settings Project Folder Path and Name Selection Configuration Settings and select the device WBZ451  Configuration Settings  Device Name and Configuration Settings   Open “MPLAB Code Configurator” after creation of project MCC Content Manager window will appear in IDE MCC in IDE Select “MPLAB Harmony” from the content manager window MCC Content Manager window Select \"Optional Content\" as shown below Optional Content Window MCC Ensure all components are selected as displayed in the image below Ignore version selection for now it will be taken care of at a later stage Required Content Select “Finish” The downloading of selected components from harmony repositories will take some minutes If all the selected components are cloned successfully MCC logs in IDE will display this information MCC Logs Snapshot when all selected components are cloned successfully If in the process a failure to download a particular component appears try redownloading again only the component that failed to download For example if user received a prompt from MCC saying “dev_packs” was not download close the MCC reopen MCC again and start from step 3 in this section with the “dev_packs” as the only missing component for downloading and select “Finish” \"dev_packs\" being redownloaded Select/Confirm the Harmony Framework Path Harmony Framework Path Selection Note: Framework Path selection window appears beneath the Initializing Project pop-up users should Choose Path as “C: mchp” Framework Selection Path Project Graph Window will appear after choosing the framework path and successful initialization of project Project Graph Change to content versions recommended for use during development in the table using the content manager from Device Resources and select “Apply” This step is important and should be followed by user as every wireless stack and app example release is tested with certain version of dependant component Changing content versions After successfully checking out the right version of content/components users can start developing application examples Stack Peripherals and other documentation  ",
							" Creating a new MCC Harmony Project 1 Create a new 32-bit MPLAB MCC Harmony Project 2 Select the Framework Path (Framework path must match SDK setup document)and select Next 3 Select Project Folder and select Next 4 Select the device and click Finish or 5 MPLABx Code Configurator will be launched automatically 6 Select \"Next\" 7 Select \"MPLAB Harmony\" 8 Select \"Finish\" 9 Project Graph window of the Configurator may have predefined components 10 Project and Device resources ",
							" Running a Precompiled Application Example Here is how to open build and program an existing application example Prerequisites Install MPLAB X IDE Links to Install MPLAB x IDE and Compiler Install XC32 Compiler Links to Install MPLAB x IDE and Compiler Install Device Family Part Pack PIC32CXBZ Device Support is handled by Device Family Part Pack installation Install MCC Plugin Installing MPLAB Code Configurator Plugin Install Harmony 3 Dependency Open Build and Program an existing application example Connect Curiosity Board to the PC using usb cable Open MPLAB X IDE Select File Open Project Browse to project location of choice (In this example we will open \"ble_sensor_app\") project select project from location \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble advanced applications ble_sensor firmware\"   If multiple projects are open within IDE IDE may not choose to build/program the \" ble_sensor \" project  Select the \" ble_sensor \" project Right click and select the setting \"Set as Main Project\"   Information related to the workings of the application example are available in readme md file available in the ble_sensor folder Open Project Properties Select WBZ451 Curiosity Board as hardware tool for programming Ensure correct DFP v1 0 xx is selected as mentioned in the Tools and Harmony Components Select XC32 compiler Select option Build Project in IDE to compile the application example Select option Run Project in IDE to program the target – the onboard debugger will program the example application Note: A smartphone App might be needed to explore the full feature set of BLE Application examples ",
							" Next Steps Stack Peripherals and other documentation Users who have completed the installation of tool chain and Harmony Components as mentioned in Getting Started with Software development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC can start developing their application using the following documentation BLE Stack Documenation Guides user on what API's are required to implement wireless BLE application Device Support Library Documentation It gives common system services like device driver library persistence data server library standalone bootloader and Bootloader services These services are created as components in Harmony Application Example Documentation Documentation describing steps to test and develop the precompiled BLE application examples Develop App examples from scratch Advanced Applications Adding Chip Peripherals to Application Guidance on how to add analog/digital peripherals to your application Device Firmware Upgrade This section documents how to enable FW updates in your design whether its serial or over the air ",
							" BLE Applications Documentation describing steps to test and develop the precompiled BLE application examples The BLE Application examples are divided into 2 categories There are both simple precompiled examples that can be tested by observing blinking LEDs on the board and more complex examples that can communicate with your smartphone using Bluetooth low energy These precompiled examples do not require you to set up the full toolchain Therefore programming and testing them should not take more than a few minutes Building Blocks - Building Blocks are training modules that teach users how to create a basic BLE application from scratch Each block demonstrates a basic BLE function such as \"How to Enable Legacy Adv \" \"How to Enable Long Range Advertising \" and so on This is recommended for users who are new to the Microchip BLE stack and other tool chains like MPLAB Code Configurator Advanced Applications - Advanced Applications are for users who are familiar with the Microchip BLE stack running on the PIC32CXBZ2 family of devices and also with the MPLAB Code Conigurator tool chain Advanced applications demonstrate features like hight throughput functionality monitoring and control of sensor and light functionality and automatic advertisement when a connection is lost ",
							" Building Block Examples This section covers PIC32CXBZ2 Application Building Blocks Building blocks are compact training modules revolving around implementing a particular BLE functionality/feature on PIC32CXBZ2 and WBZ451 Devices These training modules ease users' development experience by providing a step-by-step procedure to build a BLE Feature from Scratch Moving through the building blocks users will be able to gain familiarity with the SDK MPLAB Harmony software development framework MPLAB Code Configurator and API's necessary for implementing the BLE features of interest Users who have working knowledge of BLE and no familiarity with the Harmony framework Microchip BLE SDK tools etc are recommended to start their SW development process with Building Blocks New MPLAB Code Configurator users are recommended to go through the overview  Building blocks are divided into 3 categories based on the device roles and features users are interested in developing This segregation is important as users interested in developing only a certain type of device would be provided only the training modules and necessary reference examples related to the device type Peripheral Building Blocks Central Building Blocks Multirole Building Blocks ",
							" Central BLE Central devices are devices that discover and listen to BLE devices that are advertising These devices are capable of establishing connection to peripherals Central devices are also capable of establishing multiple connections(multilink) at the same time There are certain use cases where a connection between the devices (Peripheral Central) is not essential and scanning (Receive only no transmit) feature alone is sufficient These type of devices are called observers Tip: New MPLAB Code Configurator Users are recommended to go through the overview  Prerequisites Install tool chain and harmony components documented in Getting Started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC section Blocks  FreeRTOS and BLE Stack Setup Create a new MCC Harmony project configure Harmony components like FreeRTOS and BLE Stack Init BLE Stack  Adding UART print Hello World  Legacy Scan Receive Data Payload using BLE Legacy Scan(no BLE connection)  Scan Extended Advertisment Receive Data Payload using BLE Extended Scan(no BLE connection)  Connection Configure stack for Central Functionality Connection between Peripheral and Central Device Profiles and services  Microchip propreitary - Transparent UART Central (Legacy Scan + Connection + Data Exchange) Data Exchange using Microchip Transparent UART profile and service between 2 devices(peripheral and central) after a BLE connection  Multilink - Transparent UART Central (Legacy Scan + Multilink Connection + Data Exchange between Multiple Links) Data exchange using Microchip Transparent UART profile and service between 4 devices (1 central and 3 peripherals) after a BLE connection ",
							"  Central - FreeRTOS BLE Stack and App Initialize  Getting Started  Getting Started with Central Building Blocks  FreeRTOS and BLE Stack Setup   --  Adding UART  --  Legacy Scan Introduction This document will help users create a new MCC Harmony project configure FreeRTOS component and BLE stack component in the project generate code using the MPLAB MCC framework These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification Hardware Required None Software Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC Steps to Init BLE Stack This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New MPLAB Code Configurator Users are recommended to go through the overview of the plugin Create a new MCC Harmony Project -- link for instructions Open MPLAB Code Configurator Default MPLAB Code Configurator window Click Plus Symbol the BLE Stack component on to the project graph (BLE Stack is part of Wireless Component) Upon BLE Stack being added to project graph the different component dependencies will be requested to be added User has to select \"yes\" to add all the dependant component Activate the components (snapshot below does not cover all the necessary components that need to be activated Users are expected to select \"yes\" for all dependant components) Verify Project Graph Display FreeRTOS component configuration options by Selecting the component in Project Graph Tip: Upon selecting any component the default configuration options available for user are displayed Configure FreeRTOS component to the following The configuration chosen here should suit most application needs users are recommended to follow the FreeRTOS Customization documented here to meet their needs Display BLE Stack component configuration options by Selecting the component in Project Graph Default Configuration: Peripheral Device functionality is enabled by default Central configuration needs to enabled and peripheral configuration should be unchecked  Generate Code Switch to MPLAB X IDE window and Build Project The project should compile successfully Ensure correct compiler version as suggested in development environment Steps to install IDE compiler tool chain BLE stacks and application examples on your PC is chosen Build Project upon building project user action is required as mentioned here Where to go from here  UART ",
							" BLE Legacy Scan  Getting Started  Getting Started with Central Building Blocks  Adding UART  --  Legacy Scan  --  BLE Connection Introduction This document will help users to enable BLE Scanning on WBZ451 Curiosity board using MPLAB Code Configurator(MCC) BLE Scanning is scanning for devices that are advertising In BLE a central or observer always starts with scanning Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity Board and experience the demo or can go through the steps involved in developing this Application from scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification FreeRtos BLE App Initialize  Adding UART Hardware Required  Tool  Qty WBZ451 Curiosity Board 1 Micro USB cable 1 SDK Setup Getting Started with Sofware Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC Software  TeraTerm Smartphone App None Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central legacy_scan hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"legacy_scan x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central legacy_scan firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description This Application Example enables users to do passive scanning After programming the Application Example on reset user will be able to see the beginning of scan operation the Bluetooth addresses of devices scanned for the next 10 seconds the end of scanning operation Testing Connect the WBZ451 Curiosity board to PC program the precompiled hex file or application example as mentioned Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Scanning\" message is displayed on the TeraTerm Once scan operation has begun user will be able to display all the Bluetooth addresses that are advertising on channel 37 38 and 39 After 10 secs \"Scan Completed\" message is sent out Tera Term Users can use another WBZ451 Curiosity Board configured as BLE Advertiser set the address and scan Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project -- link for instructions Import component configuration -- This step helps users setup the basic components and configuration required to develop this application The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central legacy_scan firmware legacy_scan X\" Users should follow the instructions mentioned here to import the component configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Scan Configuration Select BLE_Stack component in project graph Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers Autogenerated Scan Parameters  Source Files  Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble app_ble_handler c All GAP GATT SMP and L2CAP Event handlers Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application | Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file Function Calls MCC generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c User Application Development Include user action is required as mentioned here definitions h in all the files where UART will be used to print debug information Tip: definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised Start Scanning BLE_GAP_SetScanningEnable(true BLE_GAP_SCAN_FD_ENABLE BLE_GAP_SCAN_MODE_OBSERVER 100); This API is called in the Applications initialstate - APP_STATE_INIT in app c Scan duration is 10 secs Scan Results BLE_GAP_EVT_ADV_REPORT event is generated upon finding Adverstisements on legacy channels // code snippet to print scan results uint8_t scanAddr[12]; //var to store ASCII address BLE_GAP_EvtAdvReport_T scanResults; scanResults addr = p_event- eventField evtAdvReport addr; APP_HexToAscii(6 scanResults addr addr scanAddr); SERCOM0_USART_Write((uint8_t *)\"0x\" 2); SERCOM0_USART_Write((uint8_t *)scanAddr 12); SERCOM0_USART_Write((uint8_t *)\" r n\" 2); // function to convert HEX to ASCII static void APP_HexToAscii(uint8_t byteNum uint8_t *p_hex uint8_t *p_ascii) { uint8_t i j c; uint8_t digitNum = byteNum * 2; if (p_hex == NULL || p_ascii == NULL) return; for (i = 0; i digitNum; i++) { j = i / 2; c = p_hex[j] 0x0F; if (c = 0x00 c = 0x09) { p_ascii[digitNum - i - 1] = c + 0x30; } else if (c = 0x0A c = 0x0F) { p_ascii[digitNum - i - 1] = c - 0x0A + 'A'; } p_hex[j] /= 16; } } Scan Timeout Event In app_ble_handler c BLE_GAP_EVT_SCAN_TIMEOUT event is generated when BLE Scan duration expires Users can exercise various other BLE Advertisement functionalities by using BLE Stack API Where to go from here  BLE Connection ",
							" BLE Scanning Extended Advertisements  Getting Started  Getting Started with Central Building Blocks  Adding UART  --   Extended Advertisements (you are here) Introduction This document will enable scanning of Extended Advertisements (ADV_EXT_IND ADV_AUX_IND) on WBZ451 Curiosity board For a successful scan of Extended Advertisement user needs to have a broadcaster transmitting these Advertisements In BLE a central or observer always starts with scanning Usage of scan_ext_adv Application example in combination with ext_adv example will enable users to test features like long range (Coded PHY) and sending data (1M 2M Coded PHY) over extended advertisements Users can run run the precompiled Application Example hex file on the WBZ451 Curiosity Board and go through the steps involved in developing this Application from scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification FreeRtos BLE App Initialize  Adding UART Hardware Required  Tool  Qty WBZ451 Curiosity Board 2 Micro USB cable 2 SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC Software  TeraTerm Smartphone App None Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central scan_ext_adv hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"scan_ext_adv x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central scan_ext_adv firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description This Application Example enables users to do scanning of Extended Advertisements (ADV_EXT_IND ADV_AUX_IND PDU's) Scanning of CODED PHY (125 kbps) is enabled by default in the application After programming the Application Example on reset \"ExtAdv Scan Enable Success\" will be printed in the terminal window and if there is a broadcaster sending extended advertisements the Green LED will toggle If this broadcaster is another WBZ451 module programmed with ext_adv example it will print the Application Data sent in Auxiliary packet - ADV_AUX_IND on TeraTerm (115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Green LED toggles denote the reception of Extended Advertisements Testing Users should use another WBZ451 Curiosity Board configured as BLE Ext Adv This section assumes that a user has already programmed the ext_adv and scan_ext_adv application on 2 WBZ451 Curiosity Boards Board1 = WBZ451 Curiosity Board with Ext Adv Programmed Board2 = WBZ451 Curiosity Board with Scan Ext Adv Programmed Board1: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Ext Adv Enable\" message is displayed on the TeraTerm Board2: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"ExtAdv Scan Enable Success\" message is displayed on the TeraTerm \"Microchip\" message will be displayed as soon the WBZ451 module performs an extended advertisement scan Data from advertiser is sent every 2 secs Green LED is toggled when the observer device receives these extended advertisements Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project - instructions Import component configuration -- This step helps users setup the basic components and configuration required to develop this application The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central scan_ext_adv firmware scan_ext_adv X \" Users should follow the instructions mentioned here to import the component configuration Tip: Import and Export functionality of component configuration will help users to start from a known working setup of configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Scan Configuration Select BLE_Stack component in project graph Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers Configuration for scanning extended advertisements is autogenerated Source Files Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble app_ble_handler c All GAP GATT SMP and L2CAP Event handlers app_user_edits c User Code Change instruction Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application | Header Files ble_gap h (Header Files config default ble lib include )- This header file contains BLE GAP functions and is automatically included in the app c file Function Calls MCC generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c User Application Development Include definitions h in all the files where UART will be used to print debug information Tip: definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised user action is required as mentioned User Action Enable Scanning of Extended Advertisement BLE_GAP_SetExtScanningEnable(BLE_GAP_SCAN_MODE_OBSERVER extScan ); API's mentioned in this section are called in the Applications initial state - APP_STATE_INIT in app c Configure LED Add the following piece of code in GPIO_Initialize() available in - Source Files config default peripheral gpio plib_gpio c GPIOB_REGS- GPIO_LAT = 0x0; /* Initial Latch Value */ GPIOB_REGS- GPIO_TRISCLR = 0x8; /* Direction Control */ GPIOB_REGS- GPIO_ANSELCLR = 0x8; /* Digital Mode Enable */ Scan Results BLE_GAP_EVT_EXT_ADV_REPORT event is generated upon finding Adverstisements on legacy channels // code snippet to print ext adv data // GPIO will toggle if it can scan any EXT ADV PDU near based on BLE_GAP_SCAN_PHY chosen GPIOB_REGS- GPIO_PORTINV = 0x08; // length value of 19 is chosen as a filter as ext_adv example sends 19 bytes of data // user can modify filter mechanism based on their requirements if (p_event- eventField evtExtAdvReport length == 19) { SERCOM0_USART_Write((uint8_t *)\" r n\" 2); SERCOM0_USART_Write( p_event- eventField evtExtAdvReport advData[5] 9); } Users can exercise various other BLE Scanning functionalities by using BLE Stack API Where to go from here  Getting Started with Central Building Blocks ",
							" BLE Connection  Getting Started  Getting Started with Central Building Blocks Legacy Scan  --  BLE Connection  --  BLE Transparent UART Introduction This document will help users to enable scan and connect functionality on the BLE Central Device ( WBZ451 ) For a successful BLE connection ADVERTISER must start sending advertisement packets on the three primary advertisement channels (or a subset of these channels) This allows the devices scanning for advertisers to find then and read their advertisement data the scanner can initiate a connection if advertiser allows it To demonstrate a BLE Connection on WBZ451 we need 2 device types Advertiser (Transmitting Connectable Adv) Scanner Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity Board and experience the demo or can go through the steps involved in developing this Application from scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification FreeRtos BLE App Initialize  BLE Legacy Scan Hardware Required  Tool  Qty WBZ451 Curiosity Board 2 Micro USB cable 2 SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC Software  TeraTerm Smartphone App None Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central central_conn hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"central_conn x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central central_conn firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description To experience this demo users are required to use central_connection and peripheral_connection application examples The 2 Application Example mentioned above will demonstrate a BLE Connection Establishment Process An advertiser (Peripheral) will start connectable scannable undirected BLE advertisement and the scanner (Central) will receive the advertisements and initiate a BLE connection enables users to transmit Connectable and Scannable Undirected BLE Advertisements Demo will print start of the scanning \"Scanning\" connected \"Connected \" and disconnected \"Disconnected\" \"Disconnected\" state on a terminal emulator like TeraTerm@ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Testing Users should use another WBZ451 Curiosity Board configured as peripheral connection This section assumes that a user has already programmed the peripheral_conn and central_conn application on 2 WBZ451 Curiosity Boards Board1 = WBZ451 Curiosity Board with peripheral_conn application Programmed Board2 = WBZ451 Curiosity Board with central_conn applicaton Programmed Board1: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Advertising\" message is displayed on the TeraTerm Board2: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Scanning\" message is displayed on the TeraTerm Upon finding peripheral device with public address {0xA1 0xA2 0xA3 0xA4 0xA5 0xA6} message \"Found Peer Node\" will be displayed and a connection request will be initiated \"Initiating connection\" Note: Scanner is configured to scan only for 100 secs user should ensure the peer device is advertising After connection establishment both the peripheral device (Board1) and central device(Board2) will display \"Connected \" message on respective terminal windows Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project -- link for instructions Import component configuration -- This step helps users setup the basic components and configuration required to develop this application The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central central_conn firmware central_conn X\" Users should follow the instructions mentioned here to import the component configuration Tip: Import and Export functionality of Harmony component configuration will help users to start from a known working setup of MCC configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Scan and Connection Configuration Select BLE_Stack component in project graph Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers  Source Files  Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble app_ble_handler c All GAP GATT SMP and L2CAP Event handlers Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application | Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file Function Calls MPLAB Code Configurator generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c User Application Development Include user action is required as mentioned here definitions h in all the files where UART will be used to print debug information Tip: definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised Start Scanning BLE_GAP_SetScanningEnable(true BLE_GAP_SCAN_FD_ENABLE BLE_GAP_SCAN_MODE_OBSERVER 1000); This API is called in the Applications initialstate - APP_STATE_INIT in app c Scan duration is 100 secs Scan Results and initiating a BLE connection BLE_GAP_EVT_ADV_REPORT event is generated upon finding Adverstisements on legacy channels BLE connection can be initiated by using the API BLE_GAP_CreateConnection( createConnParam_t); // code snippet to filter scan results and initiate connection if (p_event- eventField evtAdvReport addr addr[0] == 0xA1 p_event- eventField evtAdvReport addr addr[1] == 0xA2) { SERCOM0_USART_Write((uint8_t *)\"Found Peer Node r n\" 17); BLE_GAP_CreateConnParams_T createConnParam_t; createConnParam_t scanInterval = 0x3C; // 37 5 ms createConnParam_t scanWindow = 0x1E; // 18 75 ms createConnParam_t filterPolicy = BLE_GAP_SCAN_FP_ACCEPT_ALL; createConnParam_t peerAddr addrType = p_event- eventField evtAdvReport addr addrType; memcpy(createConnParam_t peerAddr addr p_event- eventField evtAdvReport addr addr GAP_MAX_BD_ADDRESS_LEN); createConnParam_t connParams intervalMin = 0x10; // 20ms createConnParam_t connParams intervalMax = 0x10; // 20ms createConnParam_t connParams latency = 0; createConnParam_t connParams supervisionTimeout = 0x48; // 720ms SERCOM0_USART_Write((uint8_t *)\"Initiating Connection r n\" 23); BLE_GAP_CreateConnection( createConnParam_t); } Connected Disconnected Events All the possible GAP GATT SMP and L2CAP Event handlers are available in file app_ble_handler c users can implement application code to denote Connection State here BLE_GAP_EVT_CONNECTED event is generated after a successful BLE Connection with peripheral device Scan Timeout Event In app_ble_handler c BLE_GAP_EVT_SCAN_TIMEOUT event is generated when BLE Scan duration expires Users can exercise various other BLE Advertisement functionalities by using BLE Stack API Where to go from here BLE Transparent UART ",
							" BLE Transparent UART  Getting Started  Getting Started with Central Building Blocks BLE Connection  -- BLE Transparent UART(you are here)  --  BLE Multilink Transparent UART Introduction This document will help users create a central device and send/receive characters between 2 connected BLE devices over Microchip proprietary Transparent UART Profile The central and peripheral devices in this tutorial are 2 WBZ451 devices The instructions mentioned below are applicable for a BLE Central device Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity board and experience the demo or can go through the steps involved in developing this Application from scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification BLE Connection(central) Hardware Required  Tool  Qty WBZ451 Curiosity Board 2 Micro USB cable 2 SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC Software  TeraTerm Smartphone App None Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central profiles_services central_trp_uart hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"central_trp_uart x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central profiles_services central_trp_uart firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description Upon programming the demo application central device ( WBZ451 ) will start scanning for near by peripheral devices to connect After a connection has been made data can be sent back and forth over UART between the two devices that are connected Demo will print start of the scanning \"Scanning\" connected \"Connected \" and disconnected \"Disconnected\" state on a terminal emulator like TeraTerm@ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Application Data to be sent to the connected peripheral device should be entered in the terminal emulator Testing Users should use another WBZ451 Curiosity Board configured as BLE Transparent UART(peripheral) Demo Experience when using 2 WBZ451 Curiosity boards configured as Peripheral and Central device This section assumes that a user has already programmed the peripheral_trp_uart and central_trp_uart application on 2 WBZ451 Curiosity Boards Board1 = WBZ451 Curiosity Board with peripheral_trp_uart application Programmed Board2 = WBZ451 Curiosity Board with central_trp_uart applicaton Programmed Board1: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Advertising\" message is displayed on the TeraTerm Board2: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Scanning\" message is displayed on the TeraTerm Upon finding peripheral device with public address {0xA1 0xA2 0xA3 0xA4 0xA5 0xA6} message \"Found Peer Node\" will be displayed and a connection request will be initiated \"Initiating connection\" Note: Scanner is configured to scan only for 100 secs user should ensure the peer device is advertising After connection establishment both the peripheral device (Board1) and central device(Board2) will display \"Connected \" message on respective terminal windows Users can now start sending data back and forth between the central and peripheral device using the terminal emulator Characters entered on either terminals will immediately be sent to the peer devices Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator(MCC) are recommended to go through the overview  Create a new MPLAB MCC Harmony Project -- link for instructions Import component configuration -- This step helps users setup the basic components and configuration required to develop this application The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central profiles_services central_trp_uart firmware central_trp_uart X\" Users should follow the instructions mentioned here to import the component configuration Tip: Import and Export functionality of component configuration will help users to start from a known working setup of configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Scan Connection and Transparent UART Profile Configuration Select BLE_Stack component in project graph Select Transparent Profile component in project graph Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers  Source Files  Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble app_ble_handler c All GAP GATT SMP and L2CAP Event handlers app_ble app_trspc_handler c All Transparent UART Client related Event handlers ble_trspc c All Transparent Client Functions for user application app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file ble_trspc h is the Header File associated with API’s and structures related to BLE Transparent Client functions for Application User Function Calls MCC generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c User Application Development Include \"ble_trspc h\" in app c BLE Transparent UART Server related API's are available here \"osal/osal_freertos_extend h\" in app_trsps_handler c OSAL related API's are available here definitions h in all the files where UART will be used to print debug information Tip: definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised user action is required as mentioned here Start Scanning BLE_GAP_SetScanningEnable(true BLE_GAP_SCAN_FD_ENABLE BLE_GAP_SCAN_MODE_OBSERVER 1000); This API is called in the Applications initialstate - APP_STATE_INIT in app c Scan duration is 100 secs Scan Results and initiating a BLE connection BLE_GAP_EVT_ADV_REPORT event is generated upon finding Adverstisements on legacy channels BLE connection can be initiated by using the API BLE_GAP_CreateConnection( createConnParam_t); // code snippet to filter scan results and initiate connection if (p_event- eventField evtAdvReport addr addr[0] == 0xA1 p_event- eventField evtAdvReport addr addr[1] == 0xA2) { SERCOM0_USART_Write((uint8_t *)\"Found Peer Node r n\" 17); BLE_GAP_CreateConnParams_T createConnParam_t; createConnParam_t scanInterval = 0x3C; // 37 5 ms createConnParam_t scanWindow = 0x1E; // 18 75 ms createConnParam_t filterPolicy = BLE_GAP_SCAN_FP_ACCEPT_ALL; createConnParam_t peerAddr addrType = p_event- eventField evtAdvReport addr addrType; memcpy(createConnParam_t peerAddr addr p_event- eventField evtAdvReport addr addr GAP_MAX_BD_ADDRESS_LEN); createConnParam_t connParams intervalMin = 0x10; // 20ms createConnParam_t connParams intervalMax = 0x10; // 20ms createConnParam_t connParams latency = 0; createConnParam_t connParams supervisionTimeout = 0x48; // 720ms SERCOM0_USART_Write((uint8_t *)\"Initiating Connection r n\" 23); BLE_GAP_CreateConnection( createConnParam_t); } Connected Disconnected Events In app_ble_handler c BLE_GAP_EVT_CONNECTED event will be generated when a BLE connection is completed Connection Handler Connection handle associated with the peer peripheral device needs to be saved for data exchange after a BLE connection p_event- eventField evtConnect connHandle has this information Transmit Data Add \"APP_MSG_UART_CB\" to the generated APP_MsgId_T BLE_TRSPC_SendData(conn_hdl 1 data); is the API to be used for sending data towards the central device Note: The precompiled application example uses a UART callback to initiate the data transmission upon receiving a character on UART Example Implementation for Transmitting the received data over UART using the BLE_TRSPC_SendData API uint16_t conn_hdl;// connection handle info captured @BLE_GAP_EVT_CONNECTED event uint8_t uart_data; void uart_cb(SERCOM_USART_EVENT event uintptr_t context) { APP_Msg_T appMsg; // If RX data from UART reached threshold (previously set to 1) if( event == SERCOM_USART_EVENT_READ_THRESHOLD_REACHED ) { // Read 1 byte data from UART SERCOM0_USART_Read( uart_data 1); appMsg msgId = APP_MSG_UART_CB; OSAL_QUEUE_Send( appData appQueue appMsg 0); } } void APP_UartCBHandler() { // Send the data from UART to connected device through Transparent service BLE_TRSPC_SendData(conn_hdl 1 uart_data); } // Register call back when data is available on UART for Peripheral Device to send // Enable UART Read SERCOM0_USART_ReadNotificationEnable(true true); // Set UART RX notification threshold to be 1 SERCOM0_USART_ReadThresholdSet(1); // Register the UART RX callback function SERCOM0_USART_ReadCallbackRegister(uart_cb (uintptr_t)NULL); //If msg received in Queue handle the Queue message based on msgID if (OSAL_QUEUE_Receive( appData appQueue appMsg OSAL_WAIT_FOREVER)) { if(p_appMsg- msgId==APP_MSG_BLE_STACK_EVT) { // Pass BLE Stack Event Message to User Application for handling APP_BleStackEvtHandler((STACK_Event_T *)p_appMsg- msgData); } else if(p_appMsg- msgId==APP_MSG_BLE_STACK_LOG) { // Pass BLE LOG Event Message to User Application for handling APP_BleStackLogHandler((BT_SYS_LogEvent_T *)p_appMsg- msgData); } else if(p_appMsg- msgId==APP_MSG_UART_CB) { // Transparent UART Client Data transfer Event APP_UartCBHandler(); } } Receive Data BLE_TRSPC_EVT_RECEIVE_DATA is the event generated when data is sent from central device Users need to use the BLE_TRSPC_GetDataLength( data_len) API to extract the length of application data received BLE_TRSPC_GetData( conn_hdl data); API is used to retrieve the data conn_hdl is the value obtained from Connection Handler section BLE_TRSPC_Event_T p_event structure stores the information about BLE transparent UART callback functions Example Implementation for printing the received data from peripheral device over UART /* TODO: implement your application code */ uint16_t data_len; uint8_t *data; // Retrieve received data length BLE_TRSPC_GetDataLength(p_event- eventField onReceiveData connHandle data_len); // Allocate memory according to data length data = OSAL_Malloc(data_len); if(data == NULL) break; // Retrieve received data BLE_TRSPC_GetData(p_event- eventField onReceiveData connHandle data); // Output received data to UART SERCOM0_USART_Write(data data_len); // Free memory OSAL_Free(data); Users can exercise various other BLE functionalities by using BLE Stack API Where to go from here  BLE Multilink Transparent UART ",
							" BLE Multilink Transparent UART  Getting Started  Getting Started with Central Building Blocks BLE Multilink Transparent UART  --  BLE Multilink Transparent UART Introduction This document will help users create a multilink central device and send/receive characters between connected BLE devices over Microchip proprietary Transparent UART Profile The multilink central will enable users to connect multiple peripheral devices to a central device The central and peripheral devices in this tutorial are WBZ451 devices Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity board and experience the demo or can go through the steps involved in developing this Application from scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification BLE Connection(central)  BLE Transparent UART(central) Hardware Required  Tool  Qty WBZ451 Curiosity Board 3 (min) Micro USB cable 3 SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC Software TeraTerm Smartphone App None Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central profiles_services multilink hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"central_ml_trp_uart x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central profiles_services multilink firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description Upon programming the demo application central device ( WBZ451 ) will start scanning for near by peripheral devices to connect After a connection has been made data can be sent back and forth over UART between the two devices that are connected The central device continues scanning until 100 secs and allows new peripheral devices that are advertising to join For this example we are going to demonstrate 2 BLE links ------------------Central Device------------------ | | | | | | Peripheral Device Peripheral Device Peripheral Device Demo will print start of the scanning \"Scanning\" connected \"Connected \" and disconnected \"Disconnected\" state on a terminal emulator like TeraTerm@ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Application Data to be sent to the connected peripheral device should be entered in the terminal emulator Testing Users should use 3 WBZ451 Curiosity Boards configured as BLE Transparent UART(peripheral) Note For demo testing with multiple links users need to configure the BLE Device Address for the 3 peripheral devices as follows Device 1 will have PUBLIC address of {0xA1 0xA2 0xA3 0xA4 0xA5 0xA6} Device 2 will have PUBLIC address of {0xB1 0xB2 0xB3 0xB4 0xB5 0xB6} Device 3 will have PUBLIC address of {0xC1 0xC2 0xC3 0xC4 0xC5 0xC6} Precompiled Hex files for peripheral devices with different addresses as mentioned above are available here Demo Experience when using 4 WBZ451 Curiosity boards 3 configured as Peripheral and 1 configured as Central device This section assumes that a user has already programmed the peripheral_trp_uart and central_trp_uart application on 2 WBZ451 Curiosity Boards Board1 = WBZ451 Curiosity Board with central_trp_uart applicaton Programmed Board2(Device1) = WBZ451 Curiosity Board with peripheral_trp_uart application Programmed Board3(Device2) = WBZ451 Curiosity Board with peripheral_trp_uart application Programmed Board4(Device3) = WBZ451 Curiosity Board with peripheral_trp_uart application Programmed Note It is recommended to reset central device first and then the peripheral devices one by one Board1: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Scanning\" message is displayed on the TeraTerm Upon finding peripheral device with public address {0xA1 0xA2 0xA3 0xA4 0xA5 0xA6} message \"Found Peer Node\" will be displayed and a connection request will be initiated \"Initiating connection\" During the scan time if more devices are available which will be true in this case central device will keep initiating connections with the new peer nodes Board2/Board3/Board4: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Advertising\" message is displayed on the TeraTerm Note: Scanner is configured to scan only for 100 secs user should ensure the peer device is advertising After connection establishment both the peripheral device (Board2/3/4) and central device(Board1) will display \"Connected \" message on respective terminal windows Users can now start sending data back and forth between the central and peripheral device using the terminal emulator Characters entered on any peripheral device's (Board2 3 4) terminal emulator will appear on central device's (Board1) terminal emulator Characters entered on central devices terminal emulator will appear on peripheral devices emulator in a round-robin fashion without priority For example in order to send character \"a\" to all peripheral devices \"aaa\" needs to be entered on terminal emulator of the central device Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project -- link for instructions Import component configuration -- This step helps users setup the basic components and configuration required to develop this application The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks central profiles_services multilink firmware central_ml_trp_uart X\" Users should follow the instructions mentioned here to import the component configuration Tip: Import and Export functionality of component configuration will help users to start from a known working setup of configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Scan Connection and Transparent UART Profile Configuration Select BLE_Stack component in project graph Select Transparent Profile component in project graph Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers  Source Files  Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble app_ble_handler c All GAP GATT SMP and L2CAP Event handlers app_ble app_trspc_handler c All Transparent UART Client related Event handlers config default ble profile_ble ble_trspc ble_trspc c All Transparent Client Functions for user application Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file ble_trspc h is the Header File associated with API’s and structures related to BLE Transparent Client functions for Application User Function Calls MCC generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c User Application Development Include \"ble_trspc h\" in app c BLE Transparent UART Server related API's are available here \"osal/osal_freertos_extend h\" in app_trsps_handler c OSAL related API's are available here definitions h in all the files where UART will be used to print debug information Tip: definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised user action is required as mentioned here Start Scanning BLE_GAP_SetScanningEnable(true BLE_GAP_SCAN_FD_ENABLE BLE_GAP_SCAN_MODE_OBSERVER 1000); This API is called in the Applications initialstate - APP_STATE_INIT in app c Scan duration is 100 secs Scan Results and intiating a BLE Connection BLE_GAP_EVT_ADV_REPORT event is generated upon finding Adverstisements on legacy channels BLE connection can be initiated by using the API BLE_GAP_CreateConnection( createConnParam_t); // code snippet to filter scan results and initiate connection // Filter Devices based of Address for this example address checking only 2 bytes if ((p_event- eventField evtAdvReport addr addr[0] == 0xA1 p_event- eventField evtAdvReport addr addr[1] == 0xA2) || (p_event- eventField evtAdvReport addr addr[0] == 0xB1 p_event- eventField evtAdvReport addr addr[1] == 0xB2) || (p_event- eventField evtAdvReport addr addr[0] == 0xC1 p_event- eventField evtAdvReport addr addr[1] == 0xC2)) { SERCOM0_USART_Write((uint8_t *)\"Found Peer Node r n\" 17); BLE_GAP_CreateConnParams_T createConnParam_t; createConnParam_t scanInterval = 0x3C; // 37 5 ms createConnParam_t scanWindow = 0x1E; // 18 75 ms createConnParam_t filterPolicy = BLE_GAP_SCAN_FP_ACCEPT_ALL; createConnParam_t peerAddr addrType = p_event- eventField evtAdvReport addr addrType; memcpy(createConnParam_t peerAddr addr p_event- eventField evtAdvReport addr addr GAP_MAX_BD_ADDRESS_LEN); createConnParam_t connParams intervalMin = 0x10; createConnParam_t connParams intervalMax = 0x10; createConnParam_t connParams latency = 0; createConnParam_t connParams supervisionTimeout = 0x48; SERCOM0_USART_Write((uint8_t *)\"Initiating Connection r n\" 23); BLE_GAP_CreateConnection( createConnParam_t); } Connected Disconnected Events In app_ble_handler c BLE_GAP_EVT_CONNECTED event will be generated when a BLE connection is completed Connection Handler Connection handle associated with the peer peripheral device needs to be saved for data exchange after a BLE connection p_event- eventField evtConnect connHandle has this information In Multilink Application unique connection handler's will be generated for all the peripheral links Transmit Data Add \"APP_MSG_UART_CB\" to the generated APP_MsgId_T BLE_TRSPC_SendData(conn_hdl 1 data); is the API to be used for sending data towards the central device Note: The precompiled application example uses a UART callback to initiate the data transmission upon receiving a character on UART Example Implementation for Transmitting the received data over UART using the BLE_TRSPC_SendData API uint16_t conn_hdl[3] = {0xFFFF 0xFFFF 0xFFFF};// connection handle info captured @BLE_GAP_EVT_CONNECTED event uint8_t no_of_links;// No of connected peripheral devices uint8_t i = 0;// link index uint8_t uart_data; void uart_cb(SERCOM_USART_EVENT event uintptr_t context) { APP_Msg_T appMsg; // If RX data from UART reached threshold (previously set to 1) if( event == SERCOM_USART_EVENT_READ_THRESHOLD_REACHED ) { // Read 1 byte data from UART SERCOM0_USART_Read( uart_data 1); appMsg msgId = APP_MSG_UART_CB; OSAL_QUEUE_Send( appData appQueue appMsg 0); } } void APP_UartCBHandler() { // Send the data from UART to connected device through Transparent service BLE_TRSPC_SendData(conn_hdl[i] 1 uart_data); i++; if(i==no_of_links) i = 0; //reset link index } //If msg received in Queue handle the Queue message based on msgID if (OSAL_QUEUE_Receive( appData appQueue appMsg OSAL_WAIT_FOREVER)) { if(p_appMsg- msgId==APP_MSG_BLE_STACK_EVT) { // Pass BLE Stack Event Message to User Application for handling APP_BleStackEvtHandler((STACK_Event_T *)p_appMsg- msgData); } else if(p_appMsg- msgId==APP_MSG_BLE_STACK_LOG) { // Pass BLE LOG Event Message to User Application for handling APP_BleStackLogHandler((BT_SYS_LogEvent_T *)p_appMsg- msgData); } else if(p_appMsg- msgId==APP_MSG_UART_CB) { // Transparent UART Client Data transfer Event APP_UartCBHandler(); } } Receive Data BLE_TRSPC_EVT_RECEIVE_DATA is the event generated when data is sent from central device Users need to use the BLE_TRSPC_GetDataLength( data_len) API to extract the length of application data received BLE_TRSPC_GetData( conn_hdl data); API is used to retrieve the data conn_hdl is the value obtained from Connection Handler section Tip: BLE_TRSPC_Event_T p_event structure stores the information about BLE transparent UART callback functions Example Implementation for printing the received data from peripheral device over UART /* TODO: implement your application code */ uint16_t data_len; uint8_t *data; // Retrieve received data length BLE_TRSPC_GetDataLength(p_event- eventField onReceiveData connHandle data_len); // Allocate memory according to data length data = OSAL_Malloc(data_len); if(data == NULL) break; // Retrieve received data BLE_TRSPC_GetData(p_event- eventField onReceiveData connHandle data); // Output received data to UART SERCOM0_USART_Write(data data_len); // Free memory OSAL_Free(data); Users can exercise various other BLE functionalities by using BLE Stack API ",
							" Peripheral BLE Peripheral devices send advertisement packets and accept connection requests from another central device Connected BLE devices enable bi-directional data transfer using the profiles and services There are certain use cases where a connection between the devices (Peripheral Central) is not essential and advertisement feature (transmit only no receive) is sufficient SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC Note: SDK Setup is mandatory step before users start developing app examples based of Building Blocks Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Blocks  Create FreeRTOS project and configure BLE stack using MPLAB X Harmony Code Configurator 3 Create a new MCC Harmony project configure components like FreeRTOS and BLE Stack Init BLE Stack  Adding UART print Hello World  Legacy Advertisments Transmit Data Payload using BLE Legacy Adv(no BLE connection)  Extended Advertisment Transmit Data Payload using BLE Extended Adv(no BLE connection)  Connection Configure stack for Peripheral Functionality Connection between Peripheral and Central Device  Profiles and services     Transparent UART Peripheral (Legacy Adv + Connection + Data Exchange)    Data Exchange between 2 devices(peripheral and central) after a BLE connection using Microchip Transparent UART profile and service       Custom Service Peripheral (Legacy Adv + Connection + Data Exchange)    Data Exchange between 2 devices(peripheral and central) after a BLE connection using Custom Service      ",
							"  Peripheral - FreeRTOS BLE Stack and App Initialize  Getting Started  Getting Started with Peripheral Building Blocks   FreeRTOS and BLE Stack Setup   --  Adding UART --  Legacy Advertisements(sleep) Introduction This document will help users create a new MCC Harmony project configure FreeRTOS component and BLE stack component in the project generate code using the MPLAB Code Configurator These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification Hardware Required None Software Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC Steps to Init BLE Stack This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project -- link for instructions Open MPLAB Code Configurator Default MPLAB Code Configurator window In Available component window expand Wireless BLE and click plus symbol the BLE stack component on to the project graph Upon BLE Stack being added to project graph the different component dependencies will be requested to be added User has to select \"yes\" to add the dependant component Activate the components select \"yes\" Verify Project Graph Display FreeRTOS component configuration options by Selecting the component in Project Graph Configure FreeRTOS component to the following The configuration chosen here should suit most application needs users are recommended to follow the FreeRTOS Customization documented here to meet their needs Tip: Upon selecting any component the default configuration options available for user are displayed Display BLE Stack component configuration options by Selecting the component in Project Graph Default Configuration: Peripheral Device functionality is enabled by default  Generate Code Switch to IDE window right click on project and open Project Properties Ensure correct compiler version as suggested in Getting Started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC is chosen Build Project upon building project user action is required as mentioned here Build Project The project will compile successfully Where to go from here  UART ",
							" BLE Sleep Mode Legacy Advertisements  Getting Started  Getting Started with Peripheral Building Blocks   BLE Sleep Mode Legacy Advertisements  Introduction This document will help users to enable \"sleep/standby\" mode with BLE Advertisements on WBZ451 Curiosity board using MPLAB Code Configurator(MCC) In this basic application example the advertisement interval will be set to 1 sec The advertisement interval will dictate the application sleep time Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity Board and experience the demo or can go through the steps involved in developing this Application from scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification FreeRtos BLE App Initialize  Low Power Notes Hardware Required  Tool  Qty WBZ451 Curiosity Board 1 Micro USB cable 1 Power Debugger /Multimeter 1 SDK Setup Gettting Started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC Software  TeraTerm Smartphone App Light Blue Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral legacy_adv hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"legacy_adv x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral legacy_adv firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description This Application Example enables users to enable sleep mode while transmitting non Connectable Undirected BLE Advertisements On reset demo will print \"Advertising\" on a terminal emulator like TeraTerm this denotes start of advertisements Device will enter sleep mode periodically based on the advertisement interval which is set to 1 sec for this example Testing Connect the WBZ451 Curiosity board to PC program the precompiled hex file or application example as mentioned Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Advertising\" message is displayed on the TeraTerm User can open the LightBlue App on Smartphone to scan for Advertisements Device with device name \"Microchip\" will appear Light Blue App users using a wireshark sniffer can examine the complete Application Payload sent Light Blue App Users can use another WBZ451 Curiosity Board configured as BLE scanner Current Consumption Measurement Connect the Multimeter/Power Debugger to Power Measurement Header J6 Power on the Board If using Power Debugger users can use Data Visualizer to measure the current consumption Current measured in sleep/standby mode is 577 9 uA and avg current consumption is around 624 8 uA Users of this Early adopter package should go through the known issues document and understand the limitations if any with the current low power mode implementation Light Blue App Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project -- link for instructions Import component configuration --This step helps users setup the basic components and configuration required to develop this application The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral legacy_adv firmware legacy_adv X\" Users should follow the instructions mentioned here to import the component configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Advertisement system sleep and RTC Clock Source Configuration Select BLE_Stack component in project graph Tip: advertisement payload can be configured by user here Select clock configuration Configure RTC clock configuration Tip: The configuration bits will be generated after user Generates code Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers During system sleep clock (system PLL) will be disabled and syatem tick will be turned off FreeRTOS timer needs to be componsated for the time spent in sleep RTC timer which works in the sleep mode is used to accomplish this RTC timer will be initialized after BLE stack initialization Autogenerated adverisement Data Format  Source Files  Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble_handler c All GAP GATT SMP and L2CAP Event handlers Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application | Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file Function Calls MCC generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c User Application Development Include user action is required as mentioned here definitions h in all the files where UART will be used to print debug information Tip: definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised Set PUBLIC Device Address BLE_GAP_SetDeviceAddr( devAddr); This API can be called in APP_BleConfig() located in file app_ble c BLE_GAP_Addr_T devAddr; devAddr addrType = BLE_GAP_ADDR_TYPE_PUBLIC; devAddr addr[0] = 0xA1; devAddr addr[1] = 0xA2; devAddr addr[2] = 0xA3; devAddr addr[3] = 0xA4; devAddr addr[4] = 0xA5; devAddr addr[5] = 0xA6; // Configure device address BLE_GAP_SetDeviceAddr( devAddr); Start Advertisement BLE_GAP_SetAdvEnable(0x01 0); This API is called in the Applications initialstate - APP_STATE_INIT in app c Users can exercise various other BLE Advertisement functionalities by using BLE Stack API Where to go from here  BLE Connection ",
							" BLE Extended Advertisements  Getting Started  Getting Started with Peripheral Building Blocks  Adding UART  --  Extended Advertisements Introduction This document will help users enable Extended Advertisements (1M 2M coded PHY -- 125kbps) on WBZ451 Curiosity Board This example (ext_adv) enables users to send application data using extended advertisements Extended Advertisements are used to send more data than the legacy advertisements allow and allow long range functionality when using Coded PHY Use of Extended Advertisements also enables the users to select between different PHYs (1M 2M and LE Coded ) which are not permitted when using legacy advertisements In BLE a peripheral or broadcaster always starts with advertisements Advertisement packets enable a central or observer to discover a peripheral or broadcaster Extended Advertisements implemented in this example can be used for sending more data (2M PHY) or do range tests (Coded PHY) For testing these features a scanner Application can be used which is configured to scan the extended advertisement packets To save power low power mode can be enabled If conditions are met then WBZ451 will enter into sleep mode Details will be discussed in later section Users can run the precompiled Application Example hex file provided with this example on the WBZ451 Curiosity Board and go through the steps involved in developing this Application application from the scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification FreeRtos BLE App Initialize  Adding UART  Low Power Details Hardware Required  Tool  Qty WBZ451 Curiosity Board 1 (2 if testing with a scanner) Micro USB cable 1 Optional Power Debugger /Multimeter/OscilloScope to measure power SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC Software  TeraTerm Smartphone App None Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral ext_adv hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"ext_adv x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral ext_adv firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description This Application Example enables users to transmit Extended Advertisements @ Coded PHY data rate of 125 Kbps PDU types of ADV_EXT_IND and ADV_AUX_IND will be transmitted Application data (\"Microchip\") is transmitted in Auxiliary packets (ADV_AUX_IND) ADV_EXT_IND carries the Auxiliary Packet Information (ADV_AUX_IND) for scanner to collect the data Demo will print \"Ext Adv Enabled\" information indicating the successful start of Coded PHY Advertisements on a terminal emulator like TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Coded PHY Advertisements are configured to be sent every 2 secs BLE Extended Advertisements (125 kbps 500 kbps)cannot be scanned using a smartphone app This could be due to support of only legacy advertisements on the smartphone or disabled extended adv API's in smartphone app Testing Users can use another WBZ451 Curiosity Board configured as BLE Scan Ext Adv This section assumes that a user has already programmed the ext_adv and scan_ext_adv application on 2 WBZ451 Curiosity Boards Board1 = WBZ451 Curiosity Board with Ext Adv Programmed Board2 = WBZ451 Curiosity Board with Scan Ext Adv Programmed Board1: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Ext Adv Enable\" message is displayed on the TeraTerm Board2: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"ExtAdv Scan Enable Success\" message is displayed on the TeraTerm \"Microchip\" message will be displayed as soon the WBZ451 module performs an extended advertisement scan Current Consumption Measurement Connect the Multimeter/Power Debugger/Oscillo Scope to Power Measurement Header J6 If using Power Debugger users can use Data Visualizer to measure the current consumption Current measured in sleep/standby mode is 575 6 uA and avg current consumption is around 723 0 uA Users of this package should go through the known issues document and understand the limitations if any with the current low power mode implementation Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Setup Harmony framework EA release package has all the neccessary component and should be downloaded individually from the link provided in the package It is recommended to create framework in the root directory The framework looks like Create a new MCC Harmony project - instructions Drag and drop BLE_Stack in the project graph and select Yes to all pop ups Drag and Drop SERCOM0 from Peripherals into project graph for UART messages Project Graph will look like Enable Low Power Enable Low power mode by selecting Low Power Enable in BLE_Stack Configuration Select Yes to all pop ups Click on Window- MCC- Harmony- Clock Configuration Enable SOSC clock Configure Advertisement Configuration Select BLE_Stack component in project graph and make modifications as shown below Configure UART Uart Configuration Details can be found here Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers Autogenerated extended adverisement Data Format  Source Files  Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble app_ble_handler c All GAP GATT SMP and L2CAP Event handlers app_user_edits c User Code Change instruction Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop the application| Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file Function Calls MCC generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c RTC_Timer32Start() defined in plib_rtc_timer c It call to start RTC Timer clock to facilitate low power mode User Application Development Include definitions h in all the files where UART will be used to print debug information Tip: definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised user action is required as mentioned here Start Ext Advertisement BLE_GAP_SetExtAdvEnable(true 0x01 extAdvEnableParam); This API is called in the Applications initialstate - APP_STATE_INIT in app c Parameters for extended advertisement should be chosen Below is an example Users can exercise various other BLE Advertisement functionalities by using BLE Stack API Where to go from here  Getting Started with Peripheral Building Blocks ",
							" BLE Deep Sleep Advertising  Getting Started  Getting Started with Peripheral Building Blocks BLE Deep Sleep Advertising Introduction This document will help users to enable \"Deep sleep\" mode with BLE Advertisements on WBZ451 Curiosity board using MPLAB Code Configurator(MCC) In this basic application example the Deep Sleep advertisement interval will be set to 960 millisecond The advertisement interval will dictate the application Deep sleep time Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity Board and experience the demo or can go through the steps involved in developing this Application from scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification FreeRtos BLE App Initialize Low Power Notes Hardware Required Tool Qty WBZ451 Curiosity Board 1 Micro USB cable 1 Power Debugger /Multimeter 1 SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC Software  TeraTerm Smartphone App Light Blue Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral deep_sleep_adv hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"ble_deep_sleep_adv x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral deep_sleep_adv firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description This Application Example enables users to enter Deep sleep mode while transmitting Connectable Undirected BLE Advertisements On power on reset demo will enter \"Deep Sleep Mode\" when the USR_BTN(SW2) is pressed the device onboard led(green) starts blinking which denotes start of advertisements Device will enter Deep sleep mode periodically based on the advertisement interval which is set to 960 milliseconds for this example When device connects with the mobile App the onboard led start to glow solid which indicates the connection established and the device will enter Standby Sleep Mode during Idle state Testing Connect the WBZ451 Curiosity board to PC program the precompiled hex file or application example as mentioned Upon flashing there will not be any indication on the board since the device enters deep sleep mode User can press the USR_BTN(SW2) available on the board to start Deep sleep Advertising To connect to the WBZ451 User can open the Light Blue App on Smartphone to scan for Advertisements Device name \"BLE_DSADV\" will appear Current Consumption Measurement Connect the Multimeter/Power Debugger to Power Measurement Header J6 Power on the Board If using Power Debugger users can use Data Visualizer to measure the current consumption Current measured in Deep sleep mode is around 1 6 uA Current measured in Deep sleep + Advertising mode is around 225 3 uA average Current measured in connected + standby sleep mode is 626 1uA and average current consumption is around 1 26mA Users of this Early adopter package should go through the known issues document and understand the limitations if any with the current low power mode implementation Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview Create a new MCC Harmony Project -- link for instructions Import component configuration --This step helps users setup the basic components and configuration required to develop this application Users should follow the instructions mentioned here to import the component configuration Tip: Import and Export functionality of component configuration will help users to start from a known working setup of configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Deep Sleep Advertisement system sleep and RTC Clock Source Configuration Select BLE_Stack component in project graph Note: Advertising Interval Min can be modified to adjust Deep Sleep Advertising interval Tip: Advertisement payload can be configured by user here Select clock configuration Configure RTC clock configuration Select Device Support Configure PMU Mode configuration Configure LED GPIO Configuration Note: The above GPIO configuration is used for indication of the device state in this example and is optional Tip: The configuration bits will be generated after user Generates code Generate Code Instructions on how to Generate Code After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers During system sleep clock (system PLL) will be disabled and system tick will be turned off FreeRTOS timer needs to be componsated for the time spent in sleep RTC timer which works in the sleep mode is used to accomplish this RTC timer will be initialized after BLE stack initialization Source Files Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble_handler c All GAP GATT SMP and L2CAP Event handlers app_ble_dsadv c Source Code for utilizing the deep sleep advertising functionality device_deep_sleep c Source Code for deep Sleep and wake up related system configurations Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file Function Calls MCC generates and adds the following code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() and Deep Sleep Advertising Functionality in APP_BleDsadvStart(flag) function APP_BleStackInit() and APP_BleDsadvStart(flag) are the API's that will be called inside the Applications Initial State -- APP_STATE_INIT in app c System Manual Configurations The following code modifications needs to be done to utilize the deep sleep Advertising functionality Step 1 - Initialization c CLK_Initialize(); This API call will be originally available in SYS_Initialize function and should be called part of _on_reset() function inside initialization c file void SYS_Initialize (void* data) The below generated code should be removed from the SYS_Initialize Function Add the below code inside SYS_Initialize Function DEVICE_DeepSleepWakeSrc_T wakeSrc; DEVICE_GetDeepSleepWakeUpSrc( wakeSrc); if (wakeSrc == DEVICE_DEEP_SLEEP_WAKE_NONE) //Initialize RTC if wake source is none(i e power on reset) { RTC_Initialize(); } Step 2 - startup_xc32 c PCHE_SetupRam() Copy the below code into the startup_xc32 c __attribute__((ramfunc long_call section(\" ramfunc\") unique_section)) void PCHE_SetupRam(void) { // Set Flash Wait states and enable pre-fetch // clear PFMWS and ADRWS PCHE_REGS- PCHE_CHECON = (PCHE_REGS- PCHE_CHECON (~(PCHE_CHECON_PFMWS_Msk | PCHE_CHECON_ADRWS_Msk | PCHE_CHECON_PREFEN_Msk))) | (PCHE_CHECON_PFMWS(1) | PCHE_CHECON_PREFEN(1)); // write completion delay for(int i=1; i 10; i++) { asm (\"NOP\"); } } Copy the below code into the Reset_Handler Handler Function after __pic32c_data_initialization() Function Call if ( (DSU_REGS- DSU_DID DSU_DID_REVISION_Msk)) //HW A0 version { PCHE_SetupRam(); } Step 3 - heap_4 c Modify with the below code inside heap_4 c (available as part of FreeRTOS-- MemMang) static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ]; -- Original Code static uint8_t __attribute__((section (\" bss ucHeap\") noload)) ucHeap[ configTOTAL_HEAP_SIZE ]; -- Modified Code Step 4 - device_deep_sleep c (optional) Include the Below code inside device_deep_sleep c to configure the GPIO setting for deep sleep Device_GpioConfig(); User Application Development Include user action is required as mentioned here app_ble_dsadv h into app c file definitions h in all the files where port pin macros are used Tip: definitions h is not specific to just port peripheral instead it should be included in all application source files where peripheral functionality will be exercised Enter Deep Sleep mode DEVICE_EnterDeepSleep(false 0); This API can be called to put the device to deep sleep mode Start Deep Sleep Advertisement APP_BleDsadvStart(false); This API can be called to start the Deep sleep Advertising This API is called in the Applications initialstate - APP_STATE_INIT in app c Users can exercise various other BLE Advertisement functionalities by using BLE Stack API  ",
							" Known Issue: System sleep Implementation source(device_sleep c) and header(device_sleep h) files may not include sometimes when regenerated the project through MCC Note: It is recommended to follow the below steps to avoid the mentioned known issue whenever deep sleep project is opened through MCC Step1: Please uncheck and re-enable the Enable Sleep Mode and Enable Deep Sleep Advertising option inside BLE stack Component Configuration Options as shown in the figure below and accept the dependencies requested Step2: Enable force update option and press Generate Where to go from here  BLE Connection ",
							" BLE Connection  Getting Started  Getting Started with Peripheral Building Blocks Legacy Advertisements  --  BLE Connection  -- BLE Transparent UART Introduction This document will help users enable advertisements and connection on WBZ451 Curiosity board using MPLAB Code Configurator(MCC) BLE Advertisement is Broadcasting of small packets to peer devices In BLE a peripheral device always starts with advertisements Advertisement packets enable a central or observer to discover and connect to a peripheral Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity Board and experience the demo or can go through the steps involved in developing this Application from scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification FreeRtos BLE App Initialize  BLE Legacy Advertisements Hardware Required  Tool  Qty WBZ451 Curiosity Board 1 Micro USB cable 1 SDK Setup Getting started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC Software  TeraTerm Smartphone App Light Blue Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral peripheral_conn hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"peripheral_conn x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral peripheral_conn firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description This Application Example enables users to transmit Connectable and Scannable Undirected BLE Advertisements On reset demo will print \"Advertising\" on a terminal emulator like TeraTerm this denotes start of advertisements Central device scanning these advertisements can issue connection request and get connected with this device Upon connection demo prints \"Connected\" message on terminal window Testing Connect the WBZ451 Curiosity board to PC program the precompiled hex file or application example as mentioned Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Advertising\" message is displayed on the TeraTerm User can open the LightBlue App on Smartphone to scan for Advertisements Device with device name \"Microchip\" will appear Select the device to get connected after successful connection user can view the advertisement data Terminal output Users can use another WBZ451 Curiosity Board configured as BLE Connection(central) instead of using a Smartphone App Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project -- link for instructions Import component configuration --This step helps users setup the basic components and configuration required to develop this application The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral peripheral_conn firmware peripheral_conn X\" Users should follow the instructions mentioned here to import the component configuration Tip: Import and Export functionality of Harmony component configuration will help users to start from a known working setup of MCC configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Advertisement and Connection Configuration Select BLE_Stack component in project graph Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers Autogenerated advertisement data format  Source Files  Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble app_ble_handler c All GAP GATT SMP and L2CAP Event handlers Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application | Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file Function Calls MCC generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c User Application Development Include user action is required as mentioned here definitions h in all the files where UART will be used to print debug information Tip: definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised Set PUBLIC Device Address BLE_GAP_SetDeviceAddr( devAddr); BLE_GAP_Addr_T devAddr; devAddr addrType = BLE_GAP_ADDR_TYPE_PUBLIC; devAddr addr[0] = 0xA1; devAddr addr[1] = 0xA2; devAddr addr[2] = 0xA3; devAddr addr[3] = 0xA4; devAddr addr[4] = 0xA5; devAddr addr[5] = 0xA6; // Configure device address BLE_GAP_SetDeviceAddr( devAddr); Start Advertisement BLE_GAP_SetAdvEnable(0x01 0); Connected Disconnected Events All the possible GAP GATT SMP and L2CAP Event handlers are available in file app_ble_handler c users can implement application code to denote Connection State here Users can exercise various other BLE Advertisement functionalities by using BLE Stack API Where to go from here BLE Transparent UART ",
							" BLE Transparent UART  Getting Started  Getting Started with Peripheral Building Blocks BLE Connection  --  BLE Transparent UART Introduction This tutorial will help users create a peripheral device and send/receive characters between 2 connected BLE devices over Microchip proprietary Transparent UART Profile Peripheral device will be WBZ451 Device and Central device can either be a Smartphone with Light Blue App or another WBZ451 Device The instructions mentioned below are applicable for a BLE Peripheral device Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity board and experience the demo or can go through the steps involved in developing this Application from scratch These examples each build on top on one and other We strongly recommend that you follow the examples in order to learn the basics concepts before progressing to the more advanced topics Recommended Reads BLE Software Specification BLE Connection(peripheral) Hardware Required  Tool  Qty WBZ451 Curiosity Board 1 Micro USB cable 1 SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC Software  TeraTerm Smartphone App Light Blue Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral profiles_services peripheral_trp_uart hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"peripheral_trp_uart x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral profiles_services peripheral_trp_uart firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description Upon programming the demo application WBZ451 will start Advertising (connectable) central device (Smartphone or another WBZ451 ) scanning for these advertisements will connect to the device In case of using Light Blue App search for “Microchip” and connect After a connection has been made data can be sent back and forth over UART between the two devices that are connected Demo will print start of the advertisement “Advertising” connection “BLE Scanning” “Connected” and “Disconnected” state on a terminal emulator like TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Application Data to be sent to the connected central device (Smartphone or another WBZ451 ) should be entered in the terminal emulator Testing This section assumes that user has programmed the Application Example on the WBZ451 Curiosity Board Demo Experience when using a Smartphone (Light Blue App) as Central Device Reset the WBZ451 Curiosity board Open Terminal emulator like Tera Term select the right COM port@ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) open Light Blue App on your smartphone Search and select the advertisement with Device Name \"Microchip\" To receive data from WBZ451 Curiosity Board (peripheral) device to central device users need to select the UUID: 49535343-1E4D-4BD9-BA61-23C647249616 and select listen for notifications Enter \"test\" on Teraterm and data should be displayed on Light Blue App To send data from central device to WBZ451 Curiosity Board (peripheral) users need to select the UUID: 49535343-8841-43F4-A8D4-ECBE34729BB3 and select write new value Enter \"trp uart\" on App and data should be displayed on Terminal Window Demo Experience when using another WBZ451 as Central device Users can use another WBZ451 Curiosity Board configured as BLE Transparent UART(central) instead of using a Smartphone App as central device Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project -- link for instructions Import component configuration --This step helps users setup the basic components and configuration required to develop this application The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral profiles_services peripheral_trp_uart firmware peripheral_trp_uart X\" Users should follow the instructions mentioned here to import the component configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Advertisement Connection and Transparent UART Profile Configuration Select BLE_Stack component in project graph Select Transparent Profile component in project graph Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers Autogenerated advertisement data format  Source Files  Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble app_ble_handler c All GAP GATT SMP and L2CAP Event handlers app_ble app_trsps_handler c All Transparent UART Server related Event handlers ble_trsps c All Transparent Server Functions for user application Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file ble_trsps h is the Header File associated with API’s and structures related to BLE Transparent Client functions for Application User Function Calls MCC generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c User Application Development Include \"ble_trsps h\" in app c BLE Transparent UART Server related API's are available here \"osal/osal_freertos_extend h\" in app_trsps_handler c OSAL related API's are available here definitions h in all the files where UART will be used to print debug information Tip: definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised user action is required as mentioned here Set PUBLIC Device Address BLE_GAP_SetDeviceAddr( devAddr); BLE_GAP_Addr_T devAddr; devAddr addrType = BLE_GAP_ADDR_TYPE_PUBLIC; devAddr addr[0] = 0xA1; devAddr addr[1] = 0xA2; devAddr addr[2] = 0xA3; devAddr addr[3] = 0xA4; devAddr addr[4] = 0xA5; devAddr addr[5] = 0xA6; // Configure device address BLE_GAP_SetDeviceAddr( devAddr); Start Advertisement BLE_GAP_SetAdvEnable(0x01 0); Connected Disconnected Events In app_ble_handler c BLE_GAP_EVT_CONNECTED event will be generated when a BLE connection is completed Connection Handler Connection handle associated with the peer peripheral device needs to be saved for data exchange after a BLE connection p_event- eventField evtConnect connHandle has this information Transmit Data Add \"APP_MSG_UART_CB\" to the generated APP_MsgId_T BLE_TRSPS_SendData(conn_hdl 1 data); is the API to be used for sending data towards the central device Note: The precompiled application example uses a UART callback to initiate the data transmission upon receiving a character on UART Example Implementation for Transmitting the received data over UART using the BLE_TRSPS_SendData API uint16_t conn_hdl;// connection handle info captured @BLE_GAP_EVT_CONNECTED event uint16_t ret; uint8_t uart_data; void uart_cb(SERCOM_USART_EVENT event uintptr_t context) { APP_Msg_T appMsg; // If RX data from UART reached threshold (previously set to 1) if( event == SERCOM_USART_EVENT_READ_THRESHOLD_REACHED ) { // Read 1 byte data from UART SERCOM0_USART_Read( uart_data 1); appMsg msgId = APP_MSG_UART_CB; OSAL_QUEUE_Send( appData appQueue appMsg 0); } } void APP_UartCBHandler() { // Send the data from UART to connected device through Transparent service BLE_TRSPS_SendData(conn_hdl 1 uart_data); } // Register call back when data is available on UART for Peripheral Device to send // Enable UART Read SERCOM0_USART_ReadNotificationEnable(true true); // Set UART RX notification threshold to be 1 SERCOM0_USART_ReadThresholdSet(1); // Register the UART RX callback function SERCOM0_USART_ReadCallbackRegister(uart_cb (uintptr_t)NULL); else if(p_appMsg- msgId==APP_MSG_BLE_STACK_LOG) { // Pass BLE LOG Event Message to User Application for handling APP_BleStackLogHandler((BT_SYS_LogEvent_T *)p_appMsg- msgData); } else if(p_appMsg- msgId==APP_MSG_UART_CB) { // Pass BLE UART Data transmission target BLE UART Device handling APP_UartCBHandler(); } Receive Data BLE_TRSPS_EVT_RECEIVE_DATA is the event generated when data is sent from central device Users need to use the BLE_TRSPS_GetDataLength(p_event- eventField onReceiveData connHandle data_len; API to extract the length of application data received BLE_TRSPS_GetData(p_event- eventField onReceiveData connHandle data); API is used to retrieve the data Tip: BLE_TRSPC_Event_T p_event structure stores the information about BLE transparent UART callback functions Example Implementation for printing the received data from central device over UART /* TODO: implement your application code */ uint16_t data_len; uint8_t *data; // Retrieve received data length BLE_TRSPS_GetDataLength(p_event- eventField onReceiveData connHandle data_len); // Allocate memory according to data length data = OSAL_Malloc(data_len); if(data == NULL) break; // Retrieve received data BLE_TRSPS_GetData(p_event- eventField onReceiveData connHandle data); // Output received data to UART SERCOM0_USART_Write(data data_len); // Free memory OSAL_Free(data); Users can exercise various other BLE functionalities by using BLE Stack API Where to go from here Advanced Application (BLE Sensor App) - BLE Sensor App utlizes the Transparent UART building block ",
							" BLE Custom service Getting Started Getting Started with Peripheral Building Blocks BLE Connection  –  BLE Custom Service Introduction This tutorial will help users create a peripheral device with custom profile and control the RGB LEDs on the WBZ451 Curiosity board and button on the WBZ451 Curiosity board shall be used to enable or disable the LED status Peripheral device will be WBZ451 Device and Central device can be a Smartphone with Light Blue App The instructions mentioned below are applicable for a BLE Peripheral device Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity board and experience the demo or can go through the steps involved in developing this Application from scratch Recommended Reads BLE Software Specification BLE Connection Hardware Required Tool Required Qty WBZ451 Curiosity Board 1 Micro USB Cable 1 SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC Software TeraTerm Smartphone App Light Blue Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral profiles_services custom_service hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"peripheral_trp_uart x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral profiles_services custom_service firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description Upon programming the demo application WBZ451 will start Advertising (connectable) central device (Smartphone) scanning for these advertisements will connect to the device In case of using Light Blue App search for “pic32cx-bz” and connect After a connection has been made Button and RGB LED status can be read and RGB LED can be controlled from the central device (Smartphone - Light Blue App) Button status will be notified if subscribed from central device (Smartphone) Demo will print various events on a terminal emulator like Tera Term @ (Speed: 115200 Data: 8-bit Partity: none stop bits: bit Flow control: none) Start of the advertisement - \"[BLE] Device Initialized Ready for connection\" Connection completed - \"[BLE] Connected to Peer Device: \" \" [BLE ] Connection Handle:\" Write Request Received - \"[BLE] GATT Write ATTR Handle 0x\" Read Request Received - \"[BLE] GATT Read ATTR Handle 0x\" Received RGB Data - \"[BLE] RGB LED data 0x 0x 0x\" Button press event - “[BLE] Custom Service Button Event : RGB LED ON” “[BLE] Custom Service Button Event : RGB LED OFF” BLE Disconnected - “[BLE] Disconnected Handle: %d Reason: 0x reason_code ” Testing This section assumes that user has programmed the Application Example on the WBZ451 Curiosity Board Demo Experience when using a Smartphone (Light Blue App) as Central Device Reset the WBZ451 Curiosity board Open Terminal emulator like Tera Term select the right COM port@ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) open Light Blue App on your smartphone Search and select the advertisement with Device Name \"pic32cx-bz\" Once connected on Blue App on your smartphone basic info like Adervetisement Data and Device information will be avilable\" Once connected on Blue App on your smartphone find the custom service with the UUID 4d434850-5255-42d0-aef8-881facf4ceea\" Two characteristics will be avilable on the custom service Button characteristics with Readable Notify property and RGB LED characteristics with Readable Writable property Click on the button characteristics which will have read option and subscribe Read will give the current status of the button Click on the button characteristics subscribe option to listen for button change events Button press activity will be notified to the central device without read intiated and toggle the RGB LEDs Click on the RGB LED characteristics which will have read and write option Read will give the current values stored for the RGB LEDs Value of zero will turn off the LED Other than zero value will turn on LED Click on the button characteristics write option provides option to write info which will change the RGB LED on/off condition Read again to get the updated value for RGB LEDs press back to disconnect the ble connection Disconnected device will advertise again Every event will be notified in the terminal emulator Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project -- link for instructions Import component configuration -- This step helps users setup the basic components and configuration required to develop this application The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks peripheral profiles_services custom_service firmware custom_service X\" Users should follow the instructions mentioned here to import the component configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Custom Service Configuration Select BLE_Stack component in project graph Select FreeRTOS component in project graph Select SERCOM0 component in project graph Select System component in project graph Select EIC component in project graph Select Customized Service component in project graph Verify the Clock Configuration from tools option as per low power guide  Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC Source Files Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble app_ble_handler c All GAP GATT SMP and L2CAP Event handlers ble_button_led_svc c All Custom Service button RGB LEDs configurations and functions app_ble_custom_service header and source files can be copied from the reference application Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC User Application Development Initialize Advertisement Custom Service and EIC in APP_Tasks function in file app c Add the code for enable advertisement customer service intilization and button external interrupt callback functions in the APP_STATE_INIT /* Application's initial state */ case APP_STATE_INIT: { bool appInitialized = true; //appData appQueue = xQueueCreate( 10 sizeof(APP_Msg_T) ); APP_BleStackInit(); RTC_Timer32Start(); BLE_GAP_SetAdvEnable(0x01 0); //Enable BLE Advertisement BLE_BUTTON_LED_Add(); APP_Button_Init(); SYS_CONSOLE_PRINT(\"[BLE] Device Initialized Ready for connection r n\"); Handle the button and RGB LED events in APP_Tasks function in file app c Add the RGB and button handlers to the function APP_Tasks() in app c file case APP_STATE_SERVICE_TASKS: { if (OSAL_QUEUE_Receive( appData appQueue appMsg OSAL_WAIT_FOREVER)) { // if(p_appMsg- msgId==APP_MSG_BLE_STACK_EVT) // { // // Pass BLE Stack Event Message to User Application for handling // APP_BleStackEvtHandler((STACK_Event_T *)p_appMsg- msgData); // } switch (p_appMsg- msgId) { case APP_MSG_BLE_STACK_EVT: { APP_BleStackEvtHandler((STACK_Event_T *)p_appMsg- msgData); } break; case APP_MSG_BLE_CS_LED_EVT: { APP_CustomService_RGB_Handler((uint8_t *)((STACK_Event_T *)p_appMsg- msgData)); } break; case APP_MSG_BLE_CS_BUTTON_EVT: { APP_CustomService_Button_Handler(); } break; } } break; } Add the msg ids for the button and RGB LED events in file app h typedef enum APP_MsgId_T { APP_MSG_BLE_STACK_EVT APP_MSG_ZB_STACK_EVT APP_MSG_ZB_STACK_CB APP_MSG_BLE_CS_LED_EVT APP_MSG_BLE_CS_BUTTON_EVT APP_MSG_STACK_END } APP_MsgId_T; Add the custom service file( custom_service firmware src app_ble_custom_service c/ h) which has the supporting functions for Button LED Custom service file Print the required information on the connect and discoonect events in file app_ble_handler c Add the required variables functions and callback handlers for GATT read/write response in the file ble_handler c along with the connect and disconnect void APP_BleGapEvtHandler(BLE_GAP_Event_T *p_event) { switch(p_event- eventId) { case BLE_GAP_EVT_CONNECTED: { /* TODO: implement your application code */ SYS_CONSOLE_PRINT(\"[BLE] Connected to Peer Device: 0x\"); for(int8_t idx=(GAP_MAX_BD_ADDRESS_LEN-1); idx =0; idx--) { SYS_CONSOLE_PRINT(\"%02x\" p_event- eventField evtConnect remoteAddr addr[idx]); } SYS_CONSOLE_PRINT(\" n r[BLE] Connection Handle: %d n r\" p_event- eventField evtConnect connHandle); G_ConnHandle = p_event- eventField evtConnect connHandle; } break; case BLE_GAP_EVT_DISCONNECTED: { /* TODO: implement your application code */ SYS_CONSOLE_PRINT(\"[BLE] Disconnected Handle: %d Reason: 0x%X n r\" p_event- eventField evtDisconnect connHandle p_event- eventField evtDisconnect reason); G_ConnHandle = 0; BLE_GAP_SetAdvEnable(0x01 0); //Enable BLE Advertisement } break; Add the functions for the GATT read and write handlers which will act on the received GATT request in file app_ble_handler c void APP_GattSEvtReadHandler(GATT_EvtRead_T p_event) { uint8_t error = 0; uint16_t status; SYS_CONSOLE_PRINT(\"[BLE] GATT Read ATTR Handle 0x%X r n\" p_event attrHandle); if ((p_event attrHandle = BUTTON_LED_START_HDL) || (p_event attrHandle BUTTON_LED_END_HDL)) { /* Not BLE Custom Service characteristic */ return; } switch(p_event attrHandle) { case BUTTON_LED_HDL_CHAR_0: /** Handle of characteristic 0 */ case BUTTON_LED_HDL_CCCD_0: /** Handle of characteristic 0 CCCD */ case BUTTON_LED_HDL_CHAR_1: /** Handle of characteristic 1 */ case BUTTON_LED_HDL_CHARVAL_1: /** Handle of characteristic 1 value */ error = ATT_ERRCODE_APPLICATION_ERROR; break; case BUTTON_LED_HDL_CHARVAL_0: /** Handle of characteristic 0 value */ // SYS_CONSOLE_PRINT(\" ATTR Handle Read 0x%X r n\" p_event attrHandle); break; } if ((p_event readType == ATT_READ_REQ) || (p_event readType == ATT_READ_BLOB_REQ)) { if ( error) { sp_trsReadRespParams = (GATTS_SendReadRespParams_T *)OSAL_Malloc(sizeof(GATTS_SendReadRespParams_T)); if (sp_trsReadRespParams == NULL) { return; } trsRespErrConnHandle = p_event connHandle; sp_trsReadRespParams- responseType = ATT_READ_RSP; sp_trsReadRespParams- attrLength = 0x01; sp_trsReadRespParams- attrValue[0]= bleCSdata rgbOnOffStatus; // sp_trsReadRespParams- attrLength = 0x03; // sp_trsReadRespParams- attrValue[0]= bleCSdata RGB_LED Red; // sp_trsReadRespParams- attrValue[1]= bleCSdata RGB_LED Green; // sp_trsReadRespParams- attrValue[2]= bleCSdata RGB_LED Blue; status = GATTS_SendReadResponse(p_event connHandle sp_trsReadRespParams); if (status == MBA_RES_SUCCESS) { OSAL_Free(sp_trsReadRespParams); sp_trsReadRespParams = NULL; } } else { sp_trsErrParams = (GATTS_SendErrRespParams_T *)OSAL_Malloc(sizeof(GATTS_SendErrRespParams_T)); if (sp_trsErrParams == NULL) { return; } trsRespErrConnHandle = p_event connHandle; sp_trsErrParams- reqOpcode = p_event readType; sp_trsErrParams- attrHandle = p_event attrHandle; sp_trsErrParams- errorCode = error; status = GATTS_SendErrorResponse(p_event connHandle sp_trsErrParams); if (status == MBA_RES_SUCCESS) { OSAL_Free(sp_trsErrParams); sp_trsErrParams = NULL; } } } } void APP_GattSEvtWriteHandler(GATT_EvtWrite_T p_event) { uint8_t error = 0; uint16_t status; SYS_CONSOLE_PRINT(\"[BLE] GATT Write ATTR Handle 0x%X r n\" p_event attrHandle); if ((p_event attrHandle = BUTTON_LED_START_HDL) || (p_event attrHandle BUTTON_LED_END_HDL)) { /* Not BLE Custom Service characteristic */ error = ATT_ERRCODE_INVALID_HANDLE; return; } switch(p_event attrHandle) { case BUTTON_LED_HDL_CHAR_0: /** Handle of characteristic 0 */ case BUTTON_LED_HDL_CHARVAL_0: /** Handle of characteristic 0 value */ case BUTTON_LED_HDL_CCCD_0: /** Handle of characteristic 0 CCCD */ case BUTTON_LED_HDL_CHAR_1: /** Handle of characteristic 1 */ error = ATT_ERRCODE_APPLICATION_ERROR; break; case BUTTON_LED_HDL_CHARVAL_1: /** Handle of characteristic 1 value */ // SYS_CONSOLE_PRINT(\" ATTR Handle %d r n\" p_event attrHandle); APP_CustomService_RGB_Callback(p_event writeValue); break; } if ((p_event writeType == ATT_WRITE_REQ) || (p_event writeType == ATT_PREPARE_WRITE_REQ)) { if ( error) { sp_trsRespParams = (GATTS_SendWriteRespParams_T *)OSAL_Malloc(sizeof(GATTS_SendWriteRespParams_T)); if (sp_trsRespParams == NULL) { return; } trsRespErrConnHandle = p_event connHandle; sp_trsRespParams- responseType = ATT_WRITE_RSP; status = GATTS_SendWriteResponse(p_event connHandle sp_trsRespParams); if (status == MBA_RES_SUCCESS) { OSAL_Free(sp_trsRespParams); sp_trsRespParams = NULL; } } else { sp_trsErrParams = (GATTS_SendErrRespParams_T *)OSAL_Malloc(sizeof(GATTS_SendErrRespParams_T)); if (sp_trsErrParams == NULL) { return; } trsRespErrConnHandle = p_event connHandle; sp_trsErrParams- reqOpcode = p_event writeType; sp_trsErrParams- attrHandle = p_event attrHandle; sp_trsErrParams- errorCode = error; status = GATTS_SendErrorResponse(p_event connHandle sp_trsErrParams); if (status == MBA_RES_SUCCESS) { OSAL_Free(sp_trsErrParams); sp_trsErrParams = NULL; } } } } Tip: Manual read and write response permissions and other standard events like GAP and GATT can be executed in the app_ble_handler Users can exercise various other BLE functionalities by using BLE Stack API ",
							" BLE Multilink Transparent UART Enter a short description of your topic here (optional)  This is the start of your topic  ",
							" BLE Multirole Multilink Transparent UART  Getting Started  Getting Started with Peripheral Building Blocks  Getting Started with Central Building Blocks BLE Transparent UART -- BLE Multilink Transparent UART Introduction This document will help users create a multirole multilink device and send/receive characters between connected BLE devices over Microchip proprietary Transparent UART Profile The multilink central will enable users to connect multiple peripheral devices to a central device The multilink central device will act as peripheral device and will be connected to an another central device(MBD application) The central is MBD application and peripheral devices in this tutorial are WBZ451 devices Users of this document can choose to just run the precompiled Application Example hex file on the WBZ451 Curiosity board and experience the demo or can go through the steps involved in developing this Application from scratch Recommended Reads BLE Software Specification BLE Connection BLE Transparent UART Hardware Required Tool Qty WBZ451 Curiosity Board 3 (min) Micro USB cable 3 SDK Setup  Getting Started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC Software  TeraTerm Smartphone App Light Blue Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks multirole multilink hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"mr_ml_trp_uart x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks multirole multilink firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description Upon programming the demo application multirole multilink device ( WBZ451 ) will start scanning for near by peripheral devices to connect After a connection has been made data can be sent back and forth over UART between the two devices that are connected The multirole multilink device continues scanning until 100 secs and allows new peripheral devices that are advertising to join For this example we are going to demonstrate 2 BLE links Central Device → MultiRole MultiLink Device → Peripheral Device1 Peripheral Device2 Peripheral Device3 Demo will print start of the scanning \"Scanning\" connected \"Connected \" and disconnected \"Disconnected\" state on a terminal emulator like TeraTerm@ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Application Data to be sent to the connected peripheral device should be entered in the terminal emulator Testing Users should use 3 WBZ451 Curiosity boards Note For demo testing with multiple links users need to configure the BLE Device Address for the 3 peripheral devices as follows Device 1 will have PUBLIC address of {0xA1 0xA2 0xA3 0xA4 0xA5 0xA6} Device 2 will have PUBLIC address of {0xB1 0xB2 0xB3 0xB4 0xB5 0xB6} Device 3 will have PUBLIC address of {0xC1 0xC2 0xC3 0xC4 0xC5 0xC6} Precompiled Hex files for peripheral devices with different addresses as mentioned above are available here Demo Experience when using 4 WBZ451 Curiosity boards 3 configured as Peripheral and 1 configured as MultiRole device This section assumes that a user has already programmed the peripheral_trp_uart application on 3 WBZ451 Curiosity Boards Board1 = WBZ451 Curiosity Board with mr_ml_trp_uart applicaton Programmed Board2(Device1) = WBZ451 Curiosity Board with peripheral_trp_uart application Programmed Board3(Device2) = WBZ451 Curiosity Board with peripheral_trp_uart application Programmed Board4(Device3) = WBZ451 Curiosity Board with peripheral_trp_uart application Programmed Note : It is recommended to reset multirole multilink device first and then the peripheral devices one by one Board1: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Scanning\" message is displayed on the TeraTerm Upon finding peripheral device with public address {0xA1 0xA2 0xA3 0xA4 0xA5 0xA6} message \"Found Peer Node\" will be displayed and a connection request will be initiated \"Initiating connection\" During the scan time if more devices are available which will be true in this case multirole multilink device will keep initiating connections with the new peer nodes Board2/Board3/Board4: Open TeraTerm @ (Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) Reset the board Upon reset \"Advertising\" message is displayed on the TeraTerm Note: Scanner is configured to scan only for 100 secs user should ensure the peer device is advertising After connection establishment both the peripheral device (Board2/3/4) and multirole multilink device(Board1) will display \"Connected \" message on respective terminal windows Users can now start sending data back and forth between the multirole multilink device and central/peripheral device using the terminal emulator Characters entered on any peripheral device's (Board2 3 4) terminal emulator will appear on central device's (Board1) terminal emulator Characters entered on any central device(MBD app) terminal will appear on multirole device's (Board1) terminal emulator and also send to all peripheral devices connected Characters entered on multirole multilink device terminal emulator will appear on peripheral devices emulator in a round-robin fashion without priority For example in order to send character \"a\" to all peripheral devices \"aaa\" needs to be entered on terminal emulator of the central device Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview Create a new MCC Harmony Project -- link for instructions Import component configuration -- This step helps users setup the basic components and configuration required to develop this application Users should follow the instructions mentioned here to import the component configuration Tip: Import and Export functionality of component configuration will help users to start from a known working setup of configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify Scan Advertisement and Transparent Profile Configuration Select BLE_Stack component in project graph Note: Advertising Interval Min and Max can be modified Tip: Advertisement payload can be configured by user here Select Transparent Profile configuration Generate Code Instructions on how to Generate Code After generating the program source from MCC interface by clicking Generate Code the BLE configuration can be found in the following project directories The OSAL RF System BLE System initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC The BLE stack initialization routine excuted during Application Initialization can be found in project files This intitialization routine is automatically generated by the MCC This call initializes and configures the GAP GATT SMP L2CAP and BLE middleware layers During system sleep clock (system PLL) will be disabled and system tick will be turned off FreeRTOS timer needs to be componsated for the time spent in sleep RTC timer which works in the sleep mode is used to accomplish this RTC timer will be initialized after BLE stack initialization Source Files Usage app c Application State machine includes calls for Initialization of all BLE stack (GAP GATT SMP L2CAP) related component configurations app_ble c Source Code for the BLE stack related component configurations code related to function calls from app c app_ble_handler c All GAP GATT SMP and L2CAP Event handlers app_trspc_handler c All Transparent UART Client related Event handlers app_trsps_handler c All Transparent UART Server related Event handlers ble_trspc c All Transparent Client Functions for user application ble_trsps c All Transparent Server Functions for user application Tip: app c is autogenerated and has a state machine based Application code sample users can use this template to develop their application Header Files ble_gap h- This header file contains BLE GAP functions and is automatically included in the app c file ble_trspc h is the Header File associated with API’s and structures related to BLE Transparent Client functions for Application User ble_trsps h is the Header File associated with API’s and structures related to BLE Transparent Server functions for Application User Function Calls MCC Framework generates and adds the code to initialize the BLE Stack GAP GATT L2CAP and SMP in APP_BleStackInit() function APP_BleStackInit() is the API that will be called inside the Applications Initial State -- APP_STATE_INIT in app c User Application Development Include \"ble_trspc h\" in app c BLE Transparent UART client related API's are available here \"ble_trsps h\" in app c BLE Transparent UART Server related API's are available here \"osal/osal_freertos_extend h\" in app_trsps_handler c OSAL related API's are available here definitions h in all the files where UART will be used to print debug information Tip : definitions h is not specific to just UART peripheral instead it should be included in all application source files where peripheral functionality will be exercised user action is required as mentioned here Start Scanning BLE_GAP_SetScanningEnable(true BLE_GAP_SCAN_FD_ENABLE BLE_GAP_SCAN_MODE_OBSERVER 1000); This API is called in the Applications initialstate - APP_STATE_INIT in app c Scan duration is 100 secs Scan Results and intiating a BLE Connection BLE_GAP_EVT_ADV_REPORT event is generated upon finding Adverstisements on legacy channels BLE connection can be initiated by using the API BLE_GAP_CreateConnection( createConnParam_t); // code snippet to filter scan results and initiate connection // Filter Devices based of Address for this example address checking only 2 bytes if ((p_event- eventField evtAdvReport addr addr[0] == 0xA1 p_event- eventField evtAdvReport addr addr[1] == 0xA2) || (p_event- eventField evtAdvReport addr addr[0] == 0xB1 p_event- eventField evtAdvReport addr addr[1] == 0xB2) || (p_event- eventField evtAdvReport addr addr[0] == 0xC1 p_event- eventField evtAdvReport addr addr[1] == 0xC2)) { SERCOM0_USART_Write((uint8_t *)\"Found Peer Node r n\" 17); BLE_GAP_CreateConnParams_T createConnParam_t; createConnParam_t scanInterval = 0x3C; // 37 5 ms createConnParam_t scanWindow = 0x1E; // 18 75 ms createConnParam_t filterPolicy = BLE_GAP_SCAN_FP_ACCEPT_ALL; createConnParam_t peerAddr addrType = p_event- eventField evtAdvReport addr addrType; memcpy(createConnParam_t peerAddr addr p_event- eventField evtAdvReport addr addr GAP_MAX_BD_ADDRESS_LEN); createConnParam_t connParams intervalMin = 0x10; createConnParam_t connParams intervalMax = 0x10; createConnParam_t connParams latency = 0; createConnParam_t connParams supervisionTimeout = 0x48; SERCOM0_USART_Write((uint8_t *)\"Initiating Connection r n\" 23); BLE_GAP_CreateConnection( createConnParam_t); } Connected Disconnected Events In app_ble_handler c BLE_GAP_EVT_CONNECTED event will be generated when a BLE connection is completed Connection Handler Connection handle associated with the peer peripheral device needs to be saved for data exchange after a BLE connection p_event- eventField evtConnect connHandle has this information In Multilink Application unique connection handler's will be generated for all the peripheral links Scan Timeout Handler The initiated scan operation will provide scan timeout event we can start the advertisement to connect with another central device Transmit Data Add \"APP_MSG_UART_CB\" to the generated APP_MsgId_T BLE_TRSPC_SendData(conn_hdl[i] 1 uart_data); is the API to be used for sending data towards the Client device BLE_TRSPS_SendData(conn_hdl[i] 1 uart_data); is the API to be used for sending data towards the Server device Note: * The precompiled application example uses a UART callback to initiate the data transmission upon receiving a character on UART Example Implementation for Transmitting the received data over UART using the BLE_TRSPC_SendData API uint16_t conn_hdl[3];// connection handle info captured @BLE_GAP_EVT_CONNECTED event uint8_t uart_data; uint8_t no_of_links;// No of connected peripheral devices uint8_t i = 0;// link index void uart_cb(SERCOM_USART_EVENT event uintptr_t context) { APP_Msg_T appMsg; // If RX data from UART reached threshold (previously set to 1) if( event == SERCOM_USART_EVENT_READ_THRESHOLD_REACHED ) { // Read 1 byte data from UART SERCOM0_USART_Read( uart_data 1); appMsg msgId = APP_MSG_UART_CB; OSAL_QUEUE_Send( appData appQueue appMsg 0); } } void APP_UartCBHandler() { // Send the data from UART to connected device through Transparent service BLE_TRSPC_SendData(conn_hdl[i] 1 uart_data); i++; if(i==no_of_links) i = 0; //reset link index } // Register call back when data is available on UART for Peripheral Device to send // Enable UART Read SERCOM0_USART_ReadNotificationEnable(true true); // Set UART RX notification threshold to be 1 SERCOM0_USART_ReadThresholdSet(1); // Register the UART RX callback function SERCOM0_USART_ReadCallbackRegister(uart_cb (uintptr_t)NULL); Receive Data BLE_TRSPC_EVT_RECEIVE_DATA is the event generated when data is sent from central device Users need to use the BLE_TRSPC_GetDataLength( data_len) BLE_TRSPS_GetDataLength( data_len) API to extract the length of application data received BLE_TRSPC_GetData( conn_hdl data); BLE_TRSPS_GetData( conn_hdl data); API is used to retrieve the data conn_hdl is the value obtained from Connection Handler section Tip: BLE_TRSPC_Event_T p_event structure stores the information about BLE transparent UART callback functions Tip: BLE_TRSPS_Event_T p_event structure stores the information about BLE transparent UART callback functions Example Implementation for printing the received data from peripheral device over UART /* TODO: implement your application code */ uint16_t data_len; uint8_t *data; // Retrieve received data length BLE_TRSPC_GetDataLength(p_event- eventField onReceiveData connHandle data_len); // Allocate memory according to data length data = OSAL_Malloc(data_len); if(data == NULL) break; // Retrieve received data BLE_TRSPC_GetData(p_event- eventField onReceiveData connHandle data); // Output received data to UART SERCOM0_USART_Write((uint8_t *)\" r nClient Data :\" 15); SERCOM0_USART_Write(data data_len); // Free memory OSAL_Free(data); Users can exercise various other BLE functionalities by using BLE Stack API ",
							" Chip Peripherals Application Examples that showcase BLE Stack Init + Chip Peripheral running ",
							" UART -- Hello World  Getting Started  Getting Started with Peripheral Building Blocks  Getting Started with Central Building Blocks BLE Peripheral Developers: FreeRTOS and BLE Stack Setup  --  Adding UART  --  Legacy Advertisements BLE Central Developers: FreeRTOS and BLE Stack Setup  --  Adding UART  --  Legacy Scan Introduction This document will help users to enable UART functionality on WBZ451 Curiosity board using MPLAB Code Configurator Users of this document can choose to just run the precompiled Application Example hex on the WBZ451 Curiosity Board and experience the demo or can go through the steps involved in enabling UART from scratch using MPLAB Code Configurator Recommended Reads BLE Software Specification FreeRtos BLE App Initialize (Peripheral)  FreeRtos BLE App Initialize (Central) Hardware Required  Tool  Qty WBZ451 Curiosity Board 1 Micro USB cable 1 SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC Software  TeraTerm Programming the precompiled hex file or Application Example Programming the hex file using MPLABX IPE Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks chip_peripherals uart_hello_world hex\" folder Follow the steps mentioned here Caution: Users should choose the correct Device and Tool information Programming the Application using MPLABX IDE Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document Open and program the Application Example \"uart_hello_world x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks chip_peripherals uart_hello_world firmware\" using MPLABX IDE Harmony Content Path  how to find what is my Harmony Content Path Demo Description This Application Example enables users to print data over a terminal emulator like TeraTerm Testing Connect the WBZ451 Curiosity board to PC program the application example Open Terarerm(Speed: 115200 Data: 8-bit Parity: none stop bits: 1 bit Flow control: none) and select the COM port that is enumerated when connecting the WBZ451 Curiosity Board Reset the board and Demo will print \"Hello World\" Developing this Application from scratch using MPLAB Code Configurator This section explains the steps required by a user to develop this application example from scratch using MPLABx Code Configurator Tip: New users of MPLAB Code Configurator are recommended to go through the overview  Create a new MCC Harmony Project -- link for instructions Import component configuration -- This step helps users setup the basic components required to start their Application Development component configuration related to this Application is available The imported file is of format mc3 and is located in the path \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble building_blocks chip_peripherals uart_hello_world firmware uart_hello_world X\" Users should follow the instructions mentioned here to import the component configuration Tip: Import and Export functionality of component configuration will help users to start from a known working setup of configuration Accept Dependencies or satisfiers select \"Yes\" Verify if the Project Graph window has all the expected configuration Verify UART Configuration Select SERCOM0 component in project graph Select system component in project graph Direct - Digital peripheral is enabled on the default dedicated pins and can operate with Maximum Clock Frequency PPS - Digital peripheral is enabled on pins selected by the MCC pin configurator and can operate with Maximum Clock Frequency/2 Generate Code Instructions on how to Generate Code Files and Routines Automatically generated by the MCC After generating the program source from MCC interface by clicking Generate Code the peripheral libraries (PLIBs) configuration can be found in the following project directories The sercom initialization routine executed during program initialization can be found in the project files This initialization routine is automatically generated by the MCC according to the user settings Header Files Header File associated with the sercom0 peripheral library or any other peripheral library for a different example is included in definitions h file Tip: To use all the SERCOM0 functionality include the definitions h file in Application code Function Calls MCC generates and adds the code to initialize the UART peripheral in SYS_Initialize() function SERCOM0_USART_Initialize() is the API that will be called inside the SYS_Initialize() function User Application Development Include definitions h in app c (definitions h is called to include the peripheral h files) app_idle_task h in app c Transfer Data using UART Add app_idle_task() in the function vApplicationIdleHook() in freertos_hooks c SERCOM0_USART_Write() is the used to submit a write buffer to the given USART peripheral to transfer data user can call this API in APP_STATE_INIT: Users can exercise various other UART/SERCOM functionalities by using the peripheral library documentation Where to go from here Central role BLE Scanner Peripheral Role BLE Advertisements Peripheral Role BLE Extended Advertisements (sleep) ",
							" Advanced Applications ",
							" BLE Sensor App WBZ451 Curiosity Board Devices (Device):  PIC32CX1012BZ25048 (MCU) on WBZ451 module Devices (Used On-Board): Analog Temperature Sensor RGB LED User Button User LED USB-UART converter  WBZ451 Curiosity Board   Hardware Block Diagram - Curiosity Board Hardware Required Tool Qty WBZ451 Curiosity Board 1 Micro usb cable 1 Andrioid/iOS Smartphone 1  Software Teraterm Smrtphone App Microchip Bluetooth Data (MBD) iOS/Android app available in stores   Programming the precompiled hex file or Application Example  Programming the hex file using MPLABX IPE    Precompiled Hex file is located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble advanced_applications ble_sensor precompiled_hex ble_sensor X production signed unified_gpiobased hex\" folder    Follow the steps mentioned here    Caution: Users should choose the correct Device and Tool information  Programming the Application using MPLABX IDE    Follow steps mentioned in of Running a Precompiled Example Here is how to open build and program an existing application example document    Open and program the Application Example \"ble_sensor x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble advanced_applications ble_sensor firmware\" using MPLABX IDE    Harmony Content Path  how to find what is my Harmony Content Path   Demo Description This application demonstrates the capability of WBZ451 module to connect to a mobile phone through Bluetooth Low Energy(BLE) The RGB LED on the Curiosity board can be controlled by mobile app The WBZ451 device will also report the temperature data periodically to mobile phone through Bluetooth low energy (BLE)    The WBZ451 module will be a BLE peripheral device and will advertise on startup The user can initiate the connection through mobile application The advertisement payload holds the temperature information and the RGB ON/OFF status    Uses \"BLE Sensor\" sub app from the Microchip Bluetooth Data (MBD) mobile app for BLE demonstration    Application is supported by iOS and Andrioid OS    Available in respective app stores/play stores      When Connected(ING) to the application the BLUE color \"User LED\" will turn on    Blinks the \"User LED\" with 500 ms blink interval when the device sending advertisement packets    Once connected the \"User LED\" turns on solid      From the Smartphone App the following actions can be performed    The RGB LED can be switched On/Off from MBD mobile app    When LED is switched On the RGB color can be changed from mobile app color wheel   The RGB color value is received as HSV (Hue Saturation Value) from mobile app through TRPS transparent profile and service   The HSV value is converted to RGB equivalent value in the device The corresponding PWM duty cycle for R G B will be calculated and the PWM pulse is provided on R G B LEDs        From the WBZ451 module the following actions can be performed    The RGB LED can be switched on/off by pressing the On board \"User Button\"    When the \"User Button\" is pressed and released the RGB LED is switched ON with default color GREEN or the last stored color    When the \"User Button\" is pressed and released again then the RGB LED will be toggled from the previous state      Read the temperature sensor every 1 sec once and send the temperature value to mobile app when the temperature changes about 1 degree C      Testing  Power Up: Connect the curiosity board using Micro USB to PC Power Supply Green LED will turn on when connected to PC UART Console Behavior The application activity is shown as \"Console Log\" through on board UART-USB converter Open Terminal (eg: Tera Term) to look for these logs - UART baud settings: 115200 8-N-1 without flow control BLE Not Connected Behavior The Blue \"User LED\" will be blinking Scanned from mobile app as \"BLE_Sensor_XXXX\" where 'XXXX' is a uniqu number associated with this board Launch MBD mobile app and follow the below screenshots   BLE Connected Behavior (Connected to \"BLE Sensor\" MBD Mobile Application) The Blue \"User LED\" will be solid On when connected        Firmware Version Bluetooth SIG defined \"Device Info Service\" is implemented in the device to share the device information like \"firmware version\" \"manufacture name\" etc Verify the firmware version shown on console with MBD app The BLE Sensor mobile app will show the temperature (deg C) and LED status received from device as well as allow the user to vary the RGB color and brightness  The RGB LED can also be switched On/Off by pressing the On board \"User Button ( SW2 )\" The On/Off LED status will also be reported to mobile app if connected When the \"User Button ( SW2 )\" is pressed and released RGB LED is switched ON When pressed and released again the state will be toggled from the previous state  Protocol Exchange The communication protocol exchange between BLE sensor mobile app (BLE central) and WBZ451 module (BLE peripheral) is explained here Application Flow Diagram Expanding/Customising the Application The BLE Sensor demo protocol based on TRPS profile is a transparent request response based and not tied only to this BLE sensor application It can be expanded and customized as per the users need  The protocol parser is implemented in app_trps c and app_trps h  Request and Response: when user wants to get and modify data on the device  Notify: when there is a new data to be sent to mobile app    The protocol commands are defined in app_ble_sensor h and related sensor functionalities are implemented in app_ble_sensor c  Request and Response: When a command request is received from mobile app app_trps c parse the data and forward to specific command callback handler in app_ble_sensor c  Notify: When specific Sensor data to be sent to mobile app app_ble_sensor c places the data in data base and calls for notify handler in app_trps c (/ref APP_TRPS_SendNotification())   Example: To add a command to get temperature in Fahrenheit Complete the SDK Setup and open the \"ble_sensor x\" located in \" Harmony Content Path wireless_apps_pic32cxbz2_wbz45 apps ble advanced_applications ble_sensor firmware\" using MPLABX IDE Changes to - app_ble_sensor h Define request response size of response payload (not including size of length byte and response ID) Define a new control command ID Define a new control command response Define the length for the new response command Inside the existing APP_TRPS_SensorData_T structure add the new data structure which holds the response data Increase the list size BLE_SENSOR_CMD_RESP_LST_SIZE by one Add new command request/response set in BLE_SENSOR_DEFINE_CTRL_CMD_RESP() list Changes to - app_ble_sensor c Read the temperature periodically and store in above defined data structure Add the below code in App_TRPS_Sensor_TimerHandler() After doing the above changes follow the instruction in select option Build Project in IDE to compile the application example   Select option Run Project in IDE to program the target – the onboard debugger will program the example application  Testing with MBD mobile app The \"BLE Sensor\" sub app in MBD mobile app is designed only to work with specific functionality So if new command is added in BLE sensor application \"BLE Sensor\" mobile app will not know about it To test the above newly added code \"BLE Smart\" sub app in MBD can be used Follow the below screenshots after launching MBD mobile app Using MPLAB Code Configurator MPLABX Harmony provides the MPLAB® Code Configurator (MCC) tool a set of modular device and middleware libraries and numerous example applications all of which are designed to help developers to quickly and easily develop powerful and efficient embedded software MPLAB® Code Configurator (MCC) is a free graphical programming environment that generates seamless easy-to-understand C code to insert into your project Using an intuitive interface it enables and configures a rich set of peripherals and functions specific to your application The following steps can be followed to open MCC tool and generate the code Open MCC tool from MPLABX Once the MCC tool is launched the \"Project Graph\" shows the list of MCC components used in the specific project Clicking on the specific component block will allow to change the configuration of that component eg:SERCOM0 is shown in the screenshot New component can also be added by drag and drop from \"Device Resources\" to \"Project Graph\" Then configure the component as in step #3 eg: SERCOM1 can be added into \"Project Graph\" Once all the required components and configurations are done Generate Code ",
							" Protocol Exchange The communication protocol exchange between mobile app (BLE central) and WBZ451 module (BLE peripheral) is explained here 1 BLE Sensor Data in Advertising Beacon: Advertisement Data: Service UUID: 16-bit Service UUID 0xFEDA is purchased by Microchip from Bluetooth SIG BLE Sensor data: 0x40+Light ON/Off status (1 Byte)+ 0x41+Temperature data (2 bytes) Scan Response Data: The device name is part of the scan response Device name is set as \"BLE_SENSOR_XXXX” (XXXX means the last two bytes of the device address) 2 Transparent Profile and Service (TRP/TRS): Transparent Profile and Service (TRP/TRS) is the proprietary BLE service by microchip to establish data and control channel between BLE Central (Phone) and Peripheral (device) Transparent Profile (TRP) enables higher layer application to control and allow data exchange between TRP Client and Server devices Transparent Service (TRS) includes both Ctrl and Data Pipes which are custom 128-bit GATT characteristics The Transparent Server shall be a GATT Server The Transparent Client shall be a GATT Client Definition of Transparent Service and Characteristics UUID's Characteristic Name UUID Properties TRS Service 49535343-FE7D-4AE5-8FA9-9FAFD205E455 TRS TxD- Tx Data to Client role (Data pipe) 49535343-1E4D-4BD9-BA61-23C647249616 Notify Write TRS TxD - Client Characteristic Configuration Descriptor Read Write TRS RxD- Rx Data from Client role (Data pipe) 49535343-8841-43F4-A8D4-ECBE34729BB3 Write Write without response TRS Ctrl Pt - Command and Response (Ctrl pipe) 49535343-4C8A-39B3-2F49-511CFF073B7E Notify Write Write without response TRS Ctrl Pt - Client Characteristic Configuration descriptor Read Write 3 BLE Sensor Application over Transparent Service Control Point (TRS Ctrl Pt): BLE Sensor application uses TRS Control Point Characteristic of TRPS profile to exchange data between mobile phone and device The BLE Sensor application follows the below protocol format on TRS control point characteristic Item Opcode Length Sensor/Control ID Payload Size 1 Byte 1 Byte 1 Byte Variable The description of each element is as below: - The Opcode: (0x8A) is fixed 1 byte in size and related to BLE Sensor/Control commands - Length: 1 byte in size (size of Sensor/Control ID + size of Payload) - The Sensor/Control ID: 1 byte in size It could be divided into Control request Control response Sensor notify data described in detail in following sections - The Sensor/control data and payload size depends on the Sensor/Control ID as listed in the below table BLE sensor application control and sensor command/response Control Cmd Opcode Control Request ID Parameter Parameter Length (Byte) Control Response ID Control Response Payload Control Response Payload Length (Byte) Description RGB LED On/Off Set 0x8A 0x10 On/Off 1 0x20 Status code 1 Switch On/Off the RGB LED with the default/last set color RGB LED On/Off Get 0x8A 0x11 0x21 Status code + On/Off status 2 Send the RGB LED on/off status RGB Color Set 0x8A 0x12 Color value (HSV) 3 0x22 Status code 1 Set RGB color value in HSV format RGB Color Get 0x8A 0x13 0x23 Status code + RGB color value 4 Send RGB color value in HSV format Sensor Data Sensor ID Parameter Parameter Length (Byte) Description RGB LED On/Off status 0x8A 0x40 On/Off status 1 RGB LED On/Off Status Temperature data 0x8A 0x41 Temperature sensor data 2 Temperature value in Celsius with 0 1 resolution The MSB bit will be set when the negative temperature is reported 3 1 Control Command Request and Response The Control command request is used by mobile app to send the command to device The control request channel is opened only after Client Characteristic Configuration Descriptor of TRS Ctrl Pt Characteristic notification is enabled; it is closed when such notification is disabled The format of Control command is an 8bit Opcode an 8bit request ID followed by optional control payload Format of Control Command Item Op Code Length Control Request ID Control Payload Size (Octet) 1 1 1 Variable The control response is used by the device to send feedback to mobile app The format of Response is an 8bit Opcode an 8bit response ID and response status followed by optional Response payload Format of Control Response Data Item Op Code Length Control Response ID Status Control Response Payload Size (Octet) 1 1 1 1 Variable Status code 0x00 means successful execution of control command Any status code other than 0x00 means error code as shown in below Table An error status does not have optional control Response payload Definition of Status Code Status Code Definition Description 0x00 Success Response for successful operation 0x01 Op Code Not Supported Response if unsupported Op Code is received 0x02 Invalid Parameter Response if Parameter received does not meet the requirements of the service 0x03 Operation Fail Response for fail operation 0x04-0xFF Reserved for Future use 3 2 Sensor Notify Data The Sensor data is sent to mobile app periodically by WBZ451 device The sensor data channel is opened only after Client Characteristic Configuration Descriptor of TRS Ctrl Pt notification is enabled; it is closed when such notification is disabled The format of sensor data is an 8bit Opcode an 8bit Sensor ID followed by sensor data payload Format of Sensor Data Item Op Code Length Sensor ID Sensor Payload Size (Octet) 1 1 1 Variable ",
							" BLE Throughput This document is to illustrate the example of PIC32CXBZ2 BLE throughput evaluation using Microchip MBD APP At the same time the factors affecting the BLE throughput are also discussed 1 Introduction The purpose of this document is to illustrate the user-guide of the BLE_THROUGHPUT Application for PIC32CXBZ2 The BLE_THROUGHPUT Application is designed to demonstrate several functionalities including: Connection with mobile phone via BLE Data transmission between PIC32CXBZ2 and mobile phone via BLE and throughput evaluation Data transmission from PIC32CXBZ2 to mobile phone via BLE and throughput evaluation Data transmission from mobile phone to PIC32CXBZ2 via BLE and throughput evaluation 1 1 Data Format for Advertising - Advertising Data The Service Data type is used in advertising data The data format is shown as below: Advertisement Data Format *Note: 0xFEDA is a 16-bit Service UUID which is purchased by Microchip from Bluetooth SIG - Scan Response Data The device name is put in the scan response And the device name is set as \"BLE_UART_XXXX\" (XXXX are the last two bytes of the device address ) 1 2 Supported Services and Profiles The supported service and profile are listed in the below section - Services Transparent Service MCHP proprietary service see Reference [1] for the detail Device Information Service Bluetooth SIG standard service see Reference [3] for the detail - Profiles Transparent Profile (TRP) MCHP proprietary profile see Reference [4] for the detail 1 3 LED Indication The LED indication is defined as below based on the different role and state: Advertising State (No LE link existed) Green LED flashes one time every 500 ms Connected with peer device Green LED is solid on 2 Interaction with MBD App 2 1 Work with iOS MBD App - How to Scan and Connect to the Device The steps to scan and connect to the device via MBD app are described as below: Tap \"BLE UART\" in MBD App MBD App iOS Version Tap \"PIC32CXBZ\" BLE UART GUI Tap \"START\" PIC32CXBZ GUI Tap \"BLE_UART_XXXX\" (XXXX are the last two bytes of the device address) \"START\" Scanning GUI - Firmware Version After LE is connected tap the setting button: \"Connected\" GUI The firmware version is shown as the below screenshot: Firmware Revision in \"Setting\" GUI - Select Transparent Profile There are two profiles supported by the MBD \"BLE UART\" APP but \"BLE_THROUGHPUT\" firmware supports TRP only Legacy Transparent Profile (TRP) This is supported by \"BLE_THROUGHPUT\" firmware Transparent Credit Based Profile (TRCBP) This is NOT supported by \"BLE_THROUGHPUT\" firmware - Select GATT WriteType TRP profile supports both \"Write with Response\" and \"Write without Response\" which is much higher than the former GATT WriteType in \"Setting\" GUI - Demo Modes There are two demo modes: Burst Mode and Text Mode Burst Mode is designed for the throughput evaluation via massive data transmission Text Mode is designed for the simple text typing Demo Modes in \"Setting\" GUI A Burst Mode There are four data transfer modes supported in Burst Mode: Checksum mode MBD App to the device (Uni-direction) Fixed pattern mode Device to MBD App (Uni-direction) Loopback mode MBD App → Device → MBD App (Bi-direction) UART mode MBD App → Device → UART output to PC ; UART input from PC → Device → MBD App (Bi-direction) This mode is NOT supported by \"BLE THROUGHPUT\" firmware BLE UART Mode in \"Setting\" GUI B Text Mode There are two data transfer modes supported in Text Mode: Loopback mode MBD App → Device → MBD App (Bi-direction) UART mode MBD App → Device → UART output This mode is NOT supported by \"BLE THROUGHPUT\" firmware Text Mode \"Setting\" GUI 2 2 Work with Android MBD App The operation of Android MBD App is quite the same as the iOS version MBD App 3 Throughput Evaluation In this section we will describe the throughput evaluation steps and a list of throughput figures tested with a list of phone models for reference only Finally we also discuss the factors affecting the throughput 3 1 Throughput Evaluation Steps Connect a USB cable to a WBZ451 CURIOSITY board Download the BLE_THROUGHPUT firmware Run a terminal tool like \"Tera Term\" Open the serial port connecting to WBZ451 CURIOSITY and configure the setting as below: Serial Port Setup Press the reset button on the WBZ451 CURIOSITY board and the initialization string will be shown as below Initialization Output Connect the \"BLE UART\" of MBD APP to WBZ451 CURIOSITY board Select \"Burst mode\" Select \"Demo Mode\" in setting page Except UART mode all the other modes are supported by \"BLE_THROUGHPUT\" Select Text file size in setting page The TRP profile is automatically selected Select \"GATT WriteType\" \"Write without Response\" will achieve much higher throughput Tap \"Done\" and back to the previous page Tap \"START\" After sending the file the throughput is evaluated and shown as below: Throughput Evaluation GUI 3 2 Throughput Test Report The below tables show the throughput test result with iOS and Android devices with the configuration as Profile TRP GATT Write Type Write without Response Downlink Tested with \"Checksum\" data transfer mode Uplink Tested \"Fixed pattern\" data transfer mode iOS Devices Reference Throughput with iOS Devices Android Devices Reference Throughput with Android Devices 3 3 Factors affecting Throughput In BLE_THROUGHPUT example the WBZ451 is the GATT server while the MBD App is the GATT client There are 7 main factors affecting the throughput Some factors are negotiated and determined by the BLE stack of the GATT client and server And some factors can be modified or requested by the user level application code using the APIs exposed by underneath BLE stack ATT MTU size Larger MTU size achieves higher throughput Assuming the MTU size is x then the Max application data payload in one operation is of x minus 3( excluding 1byte of GATT operation code and 2 bytes of the attribute handle ) In PIC32CX1012BZ25048 BLE stack the Max MTU is set to 247 bytes The final MTU used by the GATT client and server will depends on the negotiation initiated by the GATT client For iOS the MTU size is determined by the underneath BLE stack while the user level application can use API to learn the determined MTU For Android the MTU size can be requested by the user level application code using API of \" requestMtu (int mtu) \" and the user application code should observe the result from \" onMtuChanged \" callback Operation Type For downlink operation the \"Write without Response\"(Write Command) is always faster than the \"Write with Response\"(Write Request) For uplink operation the Notify operation is always faster than the Indication operation which requires a confirm from peer device It's the responsibility of BLE_THROUGHPUT firmware to define the property of the GATT characteristics The property in turn defines the permitted operation type Data Length Extension(DLE) Link layer data packet length by default is 27 bytes From BLE 4 2 onward the link layer data packet length can be extended to as long as 251bytes This feature is called Data Length Extension(DLE) Note that some phone models might not support DLE while PIC32CX1012BZ25048 BLE stack supports it DLE negotiation is conducted by underneath BLE stack of both the client and the server User level application code has no API to modify the link layer data packet length Connection Interval(CI) The CI defines the frequency of the Connection Event Shorter CI causes higher frequency of the Connection Event Certain number of data packets can be sent during one connection event It is obvious that the shorter CI the lesser number of data packets can be sent in one Connection Event In contrast the longer CI the higher opportunity to send larger number of data packets in one Connection Event The iOS device might limit the CI parameter according to the peripheral type See reference[6] for more details PIC32CX1012BZ25048 BLE stack provides API of \" BLE_DM_ConnectionParameterUpdate \" to update the connection parameter The final connection parameter is decided by negotiation of both the client and the server stack On Android the equivalent API is \" requestConnectionPriority \" while there is no such similar API available on iOS Number of Data Packets per Connection Event The number varies from iOS to Android and from revision to revision There is no direct API available on either iOS or Android to define this number User can fine tune the CI to get ideal value and verify the result in the air log PHY Selection From BLE 5 0 onward LE 2M PHY is introduced It is 2x faster than the former LE 1M PHY Gradually the phone models in the market will embrace this new feature Either the GATT client or server might request to update the PHY to LE 2M according to PHY Update Procedure defined by SIG see reference [7] for details WBZ451 is born to support this feature and the API of \" BLE_GAP_SetPhy \" is available to user level application code to change the PHY selected PHY Update Procedure In BLE_THROUGHPUT example the API \" BLE_GAP_SetPhy \" is called on writing the handle of TRP TX characteristic CCCD(Client Characteristic Configuration Descriptor) operated by peer device illustrated as below image For more details on TRP see reference[1] PHY Update Procedure in Example Firmware A event of BLE_GAP_EVT_PHY_UPDATE will be generated on the completion of this procedure then the user can check the result in this event This event is handled by APP_BleGapEvtHandler( ) of GAP handler in this example The RF Factor The noisy RF environment can decrease the throughput The well designed RF circuit can achieve higher throughput Finally the casing condition of the end product containing the BLE device can also affect the throughput 4 The BLE_THROUGHPUT Example Firmware Diagram The BLE_THROUGHPUT firmware is designed for WBZ451 CURIOSITY board The firmware is based on TRP service There are 3 data transfer modes supported by the BLE_THROUGHPUT firmware including Checksum mode Fixed pattern mode and Loopback mode To simplify the UART mode is not implemented in this example The firmware diagram below illustrates the main part of the firmware Example Firmware Diagram References [1] Microchip Transparent Service_v1 1 [2] Microchip Transparent Credit Based Service v1 0 [3] https://www bluetooth com/specifications/gatt/ [4] Microchip Transparent Profile_v1 1 [5] Microchip Transparent Credit Based Profile_v1 0 [6] https://developer apple com/accessories/Accessory-Design-Guidelines pdf [7] https://www bluetooth com/specifications/specs/core-specification-5-3/ ",
							" BLE Virtual Sniffer This document explains how to use the MPLAB Code Configurator(MCC) framework to add BLE Virtual Sniffer system service component for capturing the HCI packets and feed it to the sniffer tool for debugging purposes Introduction The BLE Virtual Sniffer uses BLE LOG middleware available as part of BLE Stack (BLE stack dependency) for restructuring of the HCI protocol packets The BLE Virtual Sniffer has dependency of UART(To Output the HCI packet) which can be satisfied through Harmony CONSOLE system services Hardware Required Tool Qty WBZ451 Curiosity Board 1 Micro USB cable 1 SDK Setup Getting Started with Software Development Steps to install IDE compiler tool chain BLE stacks and application examples on your PC Software Wireless Protocol Suite(WPS) Microchip_BLE_Sniffer_Tool Developing an Application with BLE SNIFFER component using MPLAB Code Configurator(MCC) This section explains the steps required by a user to integrate and use the BLE Virtual Sniffer component into any application Tip: New users of MPLAB Code Configurator (MCC) are recommended to go through the overview of MCC Users can add/remove different components like peripheral support and other wireless functionality by following steps mentioned here  Create a new MCC Harmony Project -- link for instructions Ensure that wireless_system_pic32cxbz2_wbz45 repo is available locally in the development repo Open MCC The Wireless System Service components will be displayed in available Device Resources -- Wireless -- System Services as shown in the below figure Drag BLE SNIFFER component from Device Resources to project graph area and accept all Dependencies or satisfiers(auto-activation components) select \"Yes\" BLE SNIFFER will automatically enable the BLE LOG FEATURE(Enable BLE Log option) inside Ble stack as shown in the figure Connect the BLE SNIFFER with one of instances of SERCOM to satisfy the \"UART\" dependency of BLE SNIFFER Ensure that the Transmit pinout and Receive pinout settings are configured properly inside SERCOM plib configuration options as shown in the figure NOTE: Please refer device data sheet for pin and pad configurations Generate the code Refer link for more details After generating the program source from MCC interface by clicking Generate Code the BLE LOG application service can be found in the following project directories Compile and Run the project in WBZ45x device Capturing and Parsing the HCI Sniffer Packets through Microchip BLE Sniffer Tool Make sure to install Wireless Protocol Suite open the WPS installed location and copy the following files as shown in the figure liveimport and LiveImportAPI dll (available inside Executables- core as part of WPS installation) Microchip_BLE_Sniffer_Tool (available in the link in software section) Open command prompt from the WPS installed location and run Microchip_BLE_Sniffer_Tool using the following command Microchip_BLE_Virtual_Sniffer_Tool exe \"com_port\" \"Baud_Rate\" (eg: Microchip_BLE_Virtual_Sniffer_Tool 23 921600) as shown in the figure NOTE: It is recommended to Configure the Virtual sniffer SERCOM at highest Baud Rate(921600) and is fixed to 921600 for efficient usage of the sniffer Open WPS tool and virtual sniffing data capture option in the startup page and start record as shown in the figure below Reset the WBZ451 device and the captured packet will appear in WPS Tool and the total number HCI packets captured will be displayed in the Microchip_BLE_Sniffer_Tool command prompt as shown in the figure ",
							" How-to: Adding Chip Peripherals Guidance on how to add analog/digital peripherals to your application The Chip Support Package(csp) which is downloaded as part of installing Harmony 3 Dependancy is used to configure and generate code related to peripherals of choice Once a peripheral is added to Project Graph a user can configure a variety of settings applicable to the peripheral Upon code generation users will have a code generated specific to the peripheral Initialization of the peripheral for example SERCOM0_Initiliaze() will be added automatically to the SYS_Initialize() function call Documentation to understand the usage of various API's available for a particular peripheral is available here There are also precompiled application examples available as part of csp_apps_pic32cx_bz24_bz25 repo which give users ready to use examples to follow Adding UART logs to the BLE application ",
							" How-to: Low Power Design Enable low power modes - Sleep/Standby or Deep Sleep/Backup Modes in your design ",
							"  Low Power Design on PIC32CXBZ2 Devices PIC32CXBZ2 examples and stacks supports Sleep and Deep Sleep low power modes as part of Harmony framework for WBZ451 Sleep and Deep Sleep Modes are synonymous to Standby and Backup Modes Throughout this document we refer to Sleep Mode as Standby and Deep Sleep mode as Backup mode Diffrence between Sleep and Deep Sleep Low Power Mode Sleep Low Power Mode Application layer calls BLE stack to enable advertising BLE stack will continue sending and receiving advertising Tx and Rx periodically until the application layer disables it System continues to operate between Active Mode and Sleep Mode periodically based on the ADV Tx and Rx Application layer can have peripherals running in sleep/standby low power mode Deep Sleep Low Power Mode Application layer calls BLE stack to enable Deep Sleep Advertisement BLE stack will backup advertisement parameters and data into backup SRAM and perform one time advertising event After entering Deep Sleep low power mode the system wakes up from reset whereby all parameters are lost Backup SRAM (retained in deep sleep low power mode)is used to save the advertisement parameters when waking up from reset Application layer will put system into Deep Sleep low power mode and control the wakeup time based on RTC timer (which runs in Deep Sleep low power mode) Once the system wakes up from Deep Sleep low power mode application layer triggers advertisement again by recovering the adverstisement and data partamters that are stored in backup SRAM Low Power Design of a system involves optimizing power both in Hardware and Software To name a few System Design MLDO vs Buck Mode (DC DC) Operating in Buck Mode yields to power consumption savings of about Board design to be able to measure the current consumed by the PIC32CXBZ2 device alone as there can be multiple components in the system Device Errata needs to be verified and special attention to issues that affect Device Power Consumption Lower System Clock speed from 64 MHz to 48 MHz some applications can operate with a lower system clock speed of 48 MHz Hardware Design Configuring the Transmitter power - @ 0dBm with Buck Mode on @ 64 MHz the PIC32XCBZ2 device draws 22 72 mA @+12 dBm Transmitter (Buck Mode @64 MHz) current consumption is 42 82 mA @+4 dBm Transmitter (Buck Mode @64 MHz) current consumption is 24 98 mA At Power up all GPIO's are inputs Unused GPIOs should be configured as input and pull down configuration Software Design Low Power BLE Application Design Low Power BLE Application Design ",
							" Low Power BLE Application Design Low Power BLE Application Design When designing a wireless Bluetooth Application BLE stack advertisement/connection intervals are the driving factors determining sleep mode entries and exit There are 2 low power/sleep modes that are supported by the BLE stack Sleep Deep Sleep Sleep and Deep Sleep Modes are synonymous to Standby and Backup Modes and this document may use these terminologies interchangeably The following table lists the various functionality/modules of the device that are available in the low power modes supported by BLE stack Function Sleep Deep Sleep Legacy ADV Available Available Extended ADV (Coded PHY) Available Not Supported BLE Connection Available Device can start with advertisement in \"Deep Sleep\" low power mode and post a BLE connection shift to \"Sleep\" low power mode Peripherals Available (see product datasheet for more info) Limited - wakeup sources are available Device Wakesup from reset after exiting Sleep Mode No Yes System RAM Available Not retained Backup RAM Not used by Application or BLE stack Available and used by Application and BLE stack Timer used to manage sleep and wakeup times Wireless Subsystem manages time intervals based on ADV/Connection intervals setup by API calls to BLE Stack library RTC ADV intervals recommended No min/max ADV interval Min ADV interval = 500 ms for power consumption savings Sleep/ Standby Low Power Mode What determines Application Sleep Duration and How to control it BLE stack allows system to enter low power mode if there is no active data tx/reception or the ble advertisement interval/connection interval So the system sleep cannot be directly edited as a parameter/ API call Device operation in Sleep low power mode During system sleep clock (system PLL) will be disabled and syatem tick will be turned off FreeRTOS timer needs to be componsated for the time spent in low power mode RTC timer can continue operating in the low power modes will adjust the FreeRTos timer offset So overall system sleep time is determined by the following factors - BLE activity interval external interrupt (like GPIO) or peripheral interrupts Peripherals that are allowed to run in standby/sleep low power mode can continue to run in the \"Sleep\" low power mode \"Deep Sleep/Backup Mode\" only allows for certain peripherals like RTC and INT0 to continue operating in this low power mode How to enable \"Sleep/Standby\" Low Power Mode Reference application examples BLE Legacy Adv Implements sleep low power mode with periodic ble legacy adv BLE Extended Adv Implements sleep low power mode with periodic ble extended (coded PHY) adv BLE Sensor App Implements sleep low power mode in a ble connection oriented application and data exchage using Microchip Transparent UART Service This application also has peripherals that are enabled to run in standby/sleep low power mode BLE Custom Service Building Block Implements sleep low power mode in a ble connection oriented application and data exchage using custom service This application does not have peripherals continuing to run in standby/sleep low power mode How to use MPLAB Code Configurator to Generate Sleep Mode low power mode code Sytem Sleep Mode needs to be enabled in BLE stack H3 compoenent configuration after enabling this dependant components like RTC (Timer source during sleep) will be requested to be enabled Upon enabling sleep mode FreeRTOS related settings will be set automatically Tick Mode will be set to Tickless_Idle Expected idle time before sleep will be set to 5 (ms) Tick Hook will be enabled (For user to add any custom code needed to be executed within each tick interrupt) RTC peripheral library will be added and configured Note: RTC counter should not be reset (RTC_Timer32CounterSet()) arbitrarily when the system is running RTC clock source should be set manually there are 4 options to choose from FRC (±1% offset) LPRC ( with larger offset ±5%) POSC - Candidate of the clock source (better clock accuracy) SOSC - Candidate of the clock source (better clock accuracy) Note: Users must select POSC/SOSC as the RTC clock source as choosing other clock sources will impact BLE connection stability Manually Setting RTC clock source - POSC open MCC select \"Clock Configuration\" and configure as highlighted Manually Setting RTC clock source - SOSC open MCC select \"Clock Configuration\" and configure as highlighted Note: Users can only select one clock source POSC or SOSC steps are mentioned to choose either It is recommended to use 48MHz as SYS_CLOCK for better power savings This can be configured by setting SPLLPOSTDIV1 to 2 as shown below Ensure that JTAG Enable is disabled by clearing the JTAGEN bit in CFGCON0 (Configuration Control Register 0) as shown below This code snippet can be added to SYS_Initialize() CFG_REGS- CFG_CFGCON0CLR = CFG_CFGCON0_JTAGEN_Msk; All Unused pins in the application needs to be set in input mode and the pulldown should be enabled for these pins This can be configured through pin configuration in Harmony3 Configurator as shown below Generate Code link for instructions Where can i find Sleep related code implementation after code generation step Implementation Location BT Sleep Mode BLE Stack Library System Sleep Mode device_sleep c Execute BT/System Sleep app_idle_task c RTC Based Tickless Idle Mode app_idle_task c What is code the user has to implement after code generation for sleep/standby low power mode entry FreeRTOS provides Tickless IDLE Mode for power saving this can be used to stop periodic tick interrupts during idle periods (periods when there are no application tasks that are able to excute) For the lost count on time during the IDLE mode RTC timer is used to make a correcting adjustment to the RTOS tick count value when it is restarted (after waking up from sleep) More information on low power tickless mode is available here The Tickless Idle Mode will be executed automatically when the Idle task is the only task able to run because all the application tasks are either in blocked or suspended state To prevent the system from entering sleep/standby low mode and waking up immediately the minimum sleep time(IDLE time) is automatically set to 5 ms Note: maximum sleep time is equal to the maximum period of the RTC 32 bit counter - 134217 8 sec (around 37 hours) In order for the system to enter sleep system needs to request bluetooth wireless subsystem to sleep This is accomplished by calling API - BT_SYS_EnterSleepMode() for BLE The API to call to ensure subsytem is sleeping (inactive) or ready for system to enter sleep mode is - BT_SYS_AllowSystemSleep If the expected sleep time is greater than 5 ms system is allowed to enter sleep mode by checking for 2 conditions Bluetooth subsystem is inactive eTaskConfirmSleepModeStatus() returns eNoTasksWaitingTimeout more information here  Tip: User can also add their own condition to be checked before system goes to sleep for example do not enter system sleep if data transmission over UART is active Pseudo code in RTC based Tickless Idle Mode: ``` if ((BT_SYS_AllowSystemSleep() || ZB_ReadyToSleep()) ( eTaskConfirmSleepModeStatus() = eAbortSleep ) (user_condition)) { //Enter System Sleep Mode DEVICE_EnterSleepMode (); //RTC Based Tickless Idle Mode } ``` When both the conditions as mentioned in point 3 are met we enter RTC based Tickless Idle mode (Stop the system tick use of RTC timer to set the sleep time disable interrupts) System will enter sleep mode after setting the RTC based Tickless Idle Mode by calling API - Device_EnterSleepMode() and then wait for Interrupt (WFI) instruction is executed How does the system exit from sleep mode Sytem when in sleep/standby mode can be waken up by RTC timeout BLE or GPIO interrupt Sleep mode exit is initiated by calling API - DEVICE_ExitSleepMode() Upon exiting the sleep mode interrupts need to be reenabled to allow the inteerupt service routine to be executed Interrupts are disabled as the sys tick needs to be compensated (Tickless IDLE mode) HW and FW state during System wake up and Sleep Mode Deep Sleep/Backup Low Power Mode What determines Application Sleep Duration and How to control it User Application determines the duration application stays in Deep Sleep low power mode When user selects an advertisement interval and enables deep sleep mode in the BLE_Stack component of Microchip Code configurator all the necessary API's required to enter and exit deep sleep low power mode are generated User application holds the responsibility to enable deep sleep adv and determine the sleep and wakeup duration based on the advertisement interval requirements Unlike sleep mode which uses a timer in the wireless subsystem to determine sleep and wakeup duration deep sleep mode does not use this timer (as it is unavailable in Deep Sleep low power mode) Hence we utilize the RTC timer(as it is available to run in Deep Sleep) and its interrupt based on the Deep Sleep adv interval that is set in application to wakeup the device from sleep sleep User can enter Deep Sleep low power mode post a succesful reception of \"BLE_GAP_EVT_ADV_COMPL\" event from BLE stack Device operation in Deep Sleep low power mode When the application layer initiates the BLE stack to enable Deep Sleep Advertisement the BLE stack backs up advertising parameters and application data into backup RAM and performs a one-time advertisement event Application layer will put the system in Deep Sleep mode and control Deep Sleep wakeup time using RTC timer User is responsible for putting the system in deep sleep mode and control the wakeup from RTC Based on the RTC Timer interval the device wakes up from Deep Sleep low power mode Exiting Deep Sleep mode is similar to Power on Reset Backup RAM saves the adv parameters through a reset upon wakeup BLE stack will be able to continue advertisements based on the data retained in backup RAM What is the device startup and initialization time when waking up from deep sleep low power mode since the device wakes up from reset Device startup and initialization code is diffrent and more optimizied to enable fast completion of initialization post a reset caused by waking up from deep sleep low power mode MPLAB code configurator generates API \"DEVICE_DeepSleepIntervalCal\" to calibrate the sleep duration based on the ADV interval chosen The device's startup and initialization procedures are optimized to make the device enter deep sleep low power mode as soon as possible Total time spent during device startup and firmware initialization is approximately 10 ms Average device startup time is 1 5 ms The firmware intialization time for various applications can change based on the user choice of peripherals and clocks to be initialized How to maintain I/O state when device comes out of reset when using deep sleep low power mode Device needs to backup all GPIO register settings prior to entering the deep sleep mode and recover these settings when devices wakes up from deep sleep prior to clearing the Deep Sleep register \"DSCON\" This register is cleared by the following generated API \"DEVICE_ClearDeepSleepReg()\" How to use MPLAB Code Configurator to Generate Deep Sleep Mode low power mode code Add the Harmony Components to project graph some components are optional based on Application being developed Configuration settings for \"BLE stack\" component Configuration settings for \"RTC\" component \"POSC\" as Low Power Clock Source (LPCLK) select clock configuration POSC Config bits generated after code generation \"SOSC\" as Low Power clock source(LPCLK) select clock configuration SOSC Config bits generated after code generation Clock Switching mechanism if LPCLK source is set as POSC clock source using clock configuration the FW switch to LPRC as LPCLK source as POSC clock source is unavailable in Deep Sleep Low Power Mode How to enable \"Deep Sleep/Backup\" Low Power Mode Reference application examples BLE Deep Sleep Advertisement On reset Device starts in Deep Sleep Mode upon press of SW1 button on curiosity board the sytem starts Deep Sleep Advertisements once connected to a central device the device will switch to Sleep low power mode Recommendations for using Deep Sleep ADV mode Deep Sleep ADV should be used when the ADV interval is = 500 ms What are the BLE Advertisements supported when using Deep Sleep Low Power Mode BLE Legacy Advertisement types \"ADV_IND\" \"ADV_SCAN_IND\" \"ADV_DIRECT_IND_LOW\" and \"ADV_NONCONN_IND\" are supported when using Deep Sleep mode What is the procedure for retaining Application data in backup RAM User should define the variable as persistent Persistent variables are variables that should not be cleared by the runtime startup code such as during a reset User should initialize a persistent variable as follows The data read/write into backup RAM must be single word (4 bytes) uint32_t __attribute__((persistent)) backup1; User firmware should not assign initial value for persistent variables Bootloader Firmware Authentication when using deep sleep low power mode If the bootloader has Firmware Authentication enabled the bootloader checks for Firmware Authentication upon all types of resets like POR BOR etc Firmware Authentication is skipped only when the device wakes up from Deep Sleep Low Power Mode RTC Clock Sources that are recommended to be used when using deep sleep low power mode SOSC or LPRC are the clock sources recommended when using deep sleep mode ",
							" How-to: Firmware and OTA Updates This section documents how to enable FW updates in your design whether its serial or over the air ",
							" Bootloader Introduction A bootloader is a small application that can be used to upgrade firmware on a target device without the need for an external programmer or debugger For PIC32CXBZ2 standalone bootloader it provides below functionalities: Device Firmware Upgrade over Serial(UART) interface this is also called DFU over Serial Provide functionality support for wireless Over The Air Update which is also called OTAU Provide various approaches to verify and authenticate firmware if enabled Display Console message if enabled PIC32CXBZ2 Standalone Bootloader Component PIC32CXBZ2 bootloader is a standalone Harmony component used to configure bootloader code for PIC32CXBZ2 device Click here to know about PIC32CXBZ2 standalone bootloader component user can find more information as listed below: Memory layout of PIC32CXBZ2 device Boot memory information Image metadata definition Working of Bootloader Flow diagram of Bootloader Bootloader configuration options Bootloader and DFU API usage Bootloader Example Code PIC32CX-BZ2/WB45 bootloader provided two methods to enter DFU mode one is GPIO Trigger another is Timber Based Trigger Later section will have more detailed information about them For bootloader using GPIO Trigger method user can find example code in wireless_apps_pic32cxbz2_wbz45 apps bootloader bootloader and precompiled hex file at wireless_apps_pic32cxbz2_wbz45 apps bootloader bootloader precompiled_hex bootloader X production hex For bootloader using Timer Based Trigger method user can find a precompiled hex file at wireless_apps_pic32cxbz2_wbz45 apps bootloader bootloader precompiled_hex bootloader_timer X production hex Since Timer Based Trigger bootloader creation is very similar to GPIO Trigger there is no example code provided for it Creating Bootloader From Scratch Using MCC This section explains the steps required by a user to configure and generate a PIC32CXBZ2 standalone bootloader from scratching using MCC User can find the bootloader example code(GPIO Trigger) generated using MCC in the path wireless_apps_pic32cxbz2_wbz45 apps bootloader bootloader Generated Bootloader example has the following configurations: Enabled UART DFU Enabled console to display messages Enabled GPIO Trigger Hardware requried is WBZ451 Curiosity Board DFU mode is triggered by pressing SW2(GPIO PB4) on the board Automatically reboot firmware after DFU is finished WBZ451 Curiosity Board is the hardware required to run this bootloader example the board top view is shown in figure-1 WBZ451 Curiosity Board WBZ451 Curiosity Board Top View Followings are steps to create the bootloader example(GPIO Trigger) from scratch Tip: New users of MPLAB Code Configurator are recommended to go through the overview  1 Create a new MCC Harmony Project -- link for instructions selecting WBZ451 as Target Device 2 After MCC is launched in Device Resource window expand Harmony – Wireless – Driver select Bootloader and add the component Accept all the dialog messages by clicking Yes on message prompt This will resolve dependencies among components and add connection in the graph Device Resources Window Harmony-Wireless-Dirver select Bootloader Confirmation for Components Auto-activiation Click all YES 3 In the project graph window select Bootloader component to show its Configuration Options In the Configuration Options enable Bootloader UART DFU verify it is GPIO Trigger mode and port PB4 is selected as GPIO trigger port PB4 is chosen as it is connected to SW2 on WBZ451 Curiosity board Then enable Console and leave ECC Public Key and Supported Authentication Methods to default Project Graph Window Select Bootloader to Configure Bootloader Options for GPIO Trigger GPIO Trigger mode options GPIO Trigger is the option to trigger DFU mode where user needs to hold the GPIO button during reset to put the bootloader into DFU mode Use GPIO Port and GPIO Pin option to change the port and pin based on user hardware Tip : Other than GPIO Trigger another trigger option Timer Based Trigger is also provided where bootloader will be in DFU mode for amount of time before jumping to the user application User can change the DFU Wait Time in Milliseconds to change the amount of time By selecting Timer Based Trigger a 32bit timer component TC0 is asked to be activated click YES to accept adding TC0 and accept its connection Following figures show Timer Based Trigger options and message prompt of adding TC0 Bootloader Options for Timer Based Trigger Timer Based Trigger mode options Comfirmation for Components Auto-activiation Click YES to Activate TC0 Component Tip : For Supported Authentication Methods 3 methods are provided: None  SHA256 and ECDSA256 Authentication methods with ECC Public Key are used to configure firmware authentication methods including verifying firmware completion status and authenticating firmware vendor For more details about these configurations user can refer to here  4 In the project graph window selecting the Bootloader component right click the dependency of UART select SERCOM0 in the Satisfiers list Then SERCOM0 component will be added into project graph Dependency of UART Select SERCOM0 in UART Satisfiers Project Graph Window Select SERCOM0 to Configure 5 Select SERCOM0 component to open its Configuration Options change Receive Pinout and Transmit Pinout according to WBZ451 Curiosity board Leave other settings to default SERCOM0 Options Configure Receive Pinout and Transmit Pinout 6 Expand tree of Peripherals select and add RCON component Verify RCON options just leaving it as default is okay Device Resources Window Harmony - Peripherals - RCON Project Graph Window Select RCON to Check its Options Tip : RCON provides software reset function adding RCON component is for enabling automatical firmware reboot after DFU completion 7 Then press Generate button to generate the code Generate Bootloader Code Press MCC Generate Button to Generate the Code 8 To make the Bootloader code be fit into 24KB boot memory of PIC32CXBZ2 manually find and replace ecc c and crypt_ecc_pukcl c with files provided in wireless_pic32cxbz_wbz utilities pic32cx-bz tempBtl 9 To enable firmware auto reboot after DFU completion it need host end to send a new command to bootloader This new command is device Reset command defined to 0x12 To add this command definition open file progexec h add code as below: #define DEVICE_RESET_CMD 0x12 Code Change in File progexec h Add RESET_CMD Definition Then in file progexec c function program_exec_main() add code to handle device Reset command call RCON_SoftwareReset() to start software reset Code added is shown in below figure Code Change in File progexec c Add RESET_CMD Command Handler Tip : firmware auto reboot also needs host end modification to send 0x12 command to reset device after DFU completion so far only PC GUI tool(MicrochipUtilityTool exe) is modified and supported it Python scripts as another way have not been modified to support it 10 On the IDE Tools bar click Clean and Build Main Project to build the code bootloader X production hex file will be generated User can also find precompiled hex files under folder wireless_apps_pic32cxbz2_wbz45 apps bootloader bootloader precompiled_hex  Build Bootloader Code Click Clean and Build Main Project to Build Code While generated bootloader hex file should be added to user aplication as Loadable File they shouldn't be used alone Followings are talking about a few simple steps need to be handled at user application side Configure User Application to Use Bootloader To use Bootloader with a user application there are a few steps to be configured at user application project These steps are common to any user application that wants to have Bootloader capability these steps include: Add Bootloader Services component onto user application project and generate code Add Bootloader as Loadable File/Project to create unified image Program unified image to device Add Bootloader Services Component and Generate Code Open any user application project with MPLAB X IDE click on MCC icon on Tools bar to launch MPLAB Code Configurator to open project graph In Device Resource window expand Harmony – Wireless – Driver select Bootloader Services component and add it This component generates the supporting linker file and MPLABX script needed for adding metadata header into application image(Project Properties is added with SignFirmware settings) Use Firmware Signature Verification API in Bootloader is the only option in Bootloader Services component For DFU via UART it is not necessary to enable firmware signature and verification although user can do so if needs While for OTAU user must enable firmware signature and verification by clicking on check box to Use Firmware Signature Verification API in Bootloader  (Following project graph is just an example user may have different graph depending on their application ) User Application Add Bootloader Services Add Bootloader Services and Configure After Bootloader Services component is added and configured press Generate button to generate the user application code In the generated new code some code about bootloader service is added as well as project’s linker script file is also automatically changed to reflect bootloader functionality Generate User Application Code Press Generate button to Generate User Application Code Also in the updated new project SignFirmware setting is added into Project Properties (if not see it try close and open MPLABX to refresh the project ) It's strongly recommended to enable Authen Method as SHA256 or ECDSA256-SHA256 in SignFirmware setting If user choose None since there is no firmware integrity check if any issue happens during image saving into slot1 as new image may not be complete the firmware may become non-functional at next restart So None option is not secure for firmware upgrade ECDSA256-SHA256 : firmware signature validation and data integrity check SHA256 : firmware data integrity check None : no security no integrity check SignFirmware - Auth Method - ECDSA256-SHA256 Firmware signature and integrity check SignFirmware - Auth Method - SHA256 Firmware integrity check Tip : Sequence Number cannot be 0x00000000 or 0xffffffff which are invalid values Add Bootloader as Lodable File/Project to Create Unified Image Once the new code is generated and configured user need to add Bootloader as a loadable project/loadable hex file in the updated project This enables MPLAB X IDE to merge both user application and bootloader and make an unified firmware by creating an unified image file To add Bootloader as loadable file expand application project’s tree right click Loadables select Add Loadable File then browse and add the bootloader hex file User Application Add Loadable File Right Click Loadables and Add Loadable File Add Loadable File Select Bootloader Precompiled Hex File as Loadable File To add bootloader as loadable project expand application project’s tree right click Loadables select Add Loadable Project then browse and add the bootloader project User Application Add Loadable Project Right Click Loadables and Add Loadable Project Add Loadable Project Select Bootloader Project as Loadable Project After Loadable File or Project is added then on the IDE Tools bar click Clean and Build Main Project icon to rebuild the project Build to Create Unified Image Click Clean and Build Main Project to Create Unified Image Merged Both User Application and Bootloader After code is built a few files is generated under path f irmware ble_sensor X dist default production The file named as signed unified hex is the unified image merged with both user application and bootloader By programing this unified image user application will have bootloader capability The file named as signed bin file is the target binary image file that bootloader use for DFU If user has any modifications on user application firmware user can build and generate this binary file then use bootloader to upgrade device to new image Program Unified Image As mentioned above user need to program device with unified image to make user application to have bootloader capability to do this on the IDE Tools bar click Make and Program Device Main Project icon to program device the unified image will be programmed into device Program Unified Image Click Make And Program Device Main Project to Program Unified Image Now the device with user application will have bootloader functionality referring the guidance in Device Firmware Upgrade Over Serial user can run Device Firmware Upgrade by using the bootloader ",
							" Device Firmware Upgrade Over Serial Device Firmware Upgrade(DFU) over serial is the functionality in Bootloader that user uses it to load new image received over serial interface and write into the flash PC GUI tool(MicrochipUtilityTool exe) and Python Script are two methods used for DFU over serial Followings are user guide and demostrantion steps using these two methods to do DFU over serial the demonstration is to upgrade ble_sensor user application with a new image DFU over Serial Using MicrochipUtility Tool MicrochipUtility is a GUI tool it suppors OTAU over serial Zigbee OTAU The utility tool is provided in Microchip website link For its user guide and demonstration using this tool to do serial DFU click Serial Bootloader Demo  DFU over Serial Using Python Script Pre-requisite: ble_sensor project as current user application(version 1 0 0 0) wireless_apps_pic32cxbz2_wbz45 apps ble advanced_applications ble_sensor firmware Precompiled ble_sensor new image(binary file): wireless_apps_pic32cxbz2_wbz45 apps ble advanced_applications ble_sensor precompiled_hex ble_sensor X production signed_uart_1 0 0 1 bin Bootloader : Precompiled hex file for GPIO Trigger mode DFU: wireless_apps_pic32cxbz2_wbz45 apps bootloader bootloader precompiled_hex bootloader X production hex Precompiled hex file for Timer Based Trigger DFU: wireless_apps_pic32cxbz2_wbz45 apps bootloader bootloader precompiled_hex bootloader_timer X production hex Python Script Files: For GPIO Trigger mode DFU: flash_load_2ndSlot py progctrl py ( wireless_pic32cxbz_wbz utilities pic32cx-bz dfuPythonScripts ) For Timer Based Trigger DFU: flash_load_2ndSlot_timer py progctrlOptimized py ( wireless_pic32cxbz_wbz utilities pic32cx-bz dfuPythonScripts ) Hardware: WBZ451 Curiosity Board How to Run Python Script: For GPIO Trigger DFU execute python script by below command: python flash_load_2ndSlot py -i image bin For Timer Based Trigger DFU execute python script by below command: python flash_load_2ndSlot_timer py -i image bin image bin is the binary file of new user image this binary file is generated from user application by MPLAB X IDE It could be other file name from user’s own application it may have path name before the file DFU over Serial Demonstration: Following are steps to operate DFU over seiral programing a new user image by using Bootloader Preparation: Create and Program Unified image Before DFU operation make sure the unified image containing bootloader and current user application are created and programmed To do this open ble_sensor project with MPLAB X IDE If user click Lodables will see the bootloader precompiled hex file is already added into the project Verify Loadable File in ble_sensor Project Click Loadables Verify Bootloader Precompiled Hex file is Added Tip : For Timer Based Trigger DFU user need to remove this hex file that is for GPIO Trigger DFU and add another timer based bootloader hex( bootloader_timer X production hex ) as Loadable File  Then on the IDE Tools bar click Clean and Build Main Project icon to build the project Since the project has a loadable hex file added code building will create a unified image hex file ble_sensor X production signed unified hex Tip : Another binary file named ble_sensor X production signed bin is created at the same time This binary file will be the targe image file used by bootloader for DFU However in this demonstration we will use another precomipled binary file as target image since that image contains different firmware version to tell user DFU is successful Build Unified Image Unified Image Contains Both User Application and Bootloader Once code building is finished on the IDE Tools bar click Make and Program Device Main Project icon to program device the unified image will be programmed into WBZ451 Curiosity board Program Unified Image Program Unified Image to Board Now the board is ready followings we will use DFU over serial to upgrade it to a new image ble_sensor X production signed_uart_1 0 0 1 bin For creating unified image user can refer to Bootloader - section Configure User Application to use Bootloader - Add Bootloader as Lodable File/Project to Create Unified Image to know more details Enter into DFU Mode For the provided bootloader example DFU mode is triggered by SW2 Button on WBZ451 Curiosity board So press and hold SW2 Button first then short press Reset button(SW1) to restart the firmware the firmware will enter DFU mode Opening Tera Term on PC and configure it as 115200/8bit/none Parity/1 Stop bit will see the message output as “DFU Now ” Ener Into DFU Mode Display Message \"DFU Now \" in Tera Term This message means the board is under DFU mode Run Python Script to do DFU Close Tera Term and open Windows Command Prompt go to the directory where python script files and binary image file are located and execute python script as below: python flash_load_2ndSlot py -i ble_sensor X production signed_uart_1 0 0 1 bin To run above python script user may need to copy those python script files and binary image file into a same folder However python script also support file with aboslute path name or relative path name Run Python Script to Do DFU (GPIO Trigger Mode) Execute Python Script and see DFU Progress Tip : For Timer Based Trigger DFU it uses different python script files execute python script as below: python flash_load_2ndSlot_timer py -i ble_sensor X production signed_uart_1 0 0 1 bin For Timer Based Trigger DFU it will wait to capture DFU mode window of the bootloader so for operating Timer Based Trigger DFU need execute python script first then reset the board and wait for a while If python script has captured DFU window it will start DFU process Otherwise user will need another reset the board until DFU is started Referring to figure below after python script is executed it keep waiting and reminding user to reset the board until DFU progress starts to be shown Run Python Script (Timer Based Trigger) Execute Python Script Reset Board and see DFU Progress The % progress will tell the DFU progress Once it is finished as 100% the new image is copied to slot1 of internal flash memory Reset Board to Start New Firmware Python script has not supported firmware automatical reboot after DFU completion so need manually reset the board to start new firmware Once DFU progress achieves 100% complete close Windows Command Prompt and open Tera Term to see the message output On the board press the Reset button(SW1) to restart the bootloader will then copy new firmware from flash memory slot1 to slot0 After that bootloader will jump and start new user image in slot0 On Tera Term user will see messages as shown below original firmware version is 1 0 0 0 now firmware version is 1 0 0 1 the DFU is successful Reset Board to Star New Firmware Display Message About Firmware Erase/Copy/Verify in Tera Term Tip : For Timer Based Trigger DFU it doesn't need manual reset the board to start new image Timer Based Trigger bootloader will automatically copy new user image and jump to start it Tip : Depending on if user has enabled Use Firmware Signature Verification API in Bootloader in Bootloader Services component or not the bootloader code may or may not verify metaheader and firmware using specified method If bootloader has verified metaheader and firmware their verification result will be displayed in Tera Term ",
							" Device Firmware Upgrade Over BLE Introduction One of the highly important features of wirelessly-connected devices is the capability of Over-The-Air device firmware update (OTA DFU) The increasing demand by end-users for this functionality is To address issues and security vulnerabilities To ship products to market faster and have the option of delaying lower priority features and being able to roll them out to devices in the field  PIC32CXBZ2 / WBZ451 family of devices support Over-The-Air upgrade through BLE Microchip defined OTA profile and service enables firmware upgrade over the BLE link using Generic Attribute Profile (GATT) The BLE OTA protocol defines the communication between the OTAU target and OTAU manager The OTAU manager can be a mobile device (iOS/Android™) or any BLE device that implements the OTA GATT client protocol that transfers the upgrade firmware to the OTAU target The OTAU target implements the OTA GATT server protocol to receive the new firmware image Secure BLE OTA DFU Process With the increasing popularity of OTA DFU capability in IoT devices devices are getting exposed to vulnerabilities and security threats So it is important to make sure that the device’s OTA DFU process is secure and reliable One of the way of sending upgradable image reliably and securely is to sign and encrypt the image Here are the basics of how an over-the-air device firmware update (OTA DFU) process works over BLE link: BLE OTA DFU Process • BLE OTA DFU file (Firmware Image encrypted signed) is uploaded to the OTAU Manager OTAU Manager can be Smart phone or any BLE device that supports OTA Client • OTAU Target ( PIC32CXBZ2 / WBZ451 device) queries the OTAU Manager and fetches new firmware image • The image will be decrypted validated and applied ",
							" BLE OTA DFU Firmware Architecture The below figure shows the BLE OTA DFU Firmware Architecture of PIC32CXBZ2 / WBZ451 device BLE OTA DFU Firmware Architecture MCHP OTA Profile and Service Middleware: Defines and handles the MCHP defined BLE GATT Server and Profile for getting the upgradable image over BLE link Implements OTA state management and error handling Implements defragmentation and decryption of received new image DFU Middleware: DFU APIs for writing the OTA image into Embedded Flash This module provides Device Firmware Update (DFU) capabilities common across the different supported transport mediums like UART BLE OTA Event Handling: OTA events from \"MCHP OTA Profile and Service\" middleware is sent to application for DFU permission OTA DFU Encryption Key management: Trigger new Flash Image authentication by calling Bootloader API Timeout handling in case of failure/error while receiving the image Bootloader: Bootloader is responsible for authentication and activation of new firmware booting into the application optionally entering into Serial DFU mode to get new image over serial interface Please be noted that Bootloader code is running from Boot Flash in PIC32CXBZ2 / WBZ451 family of devices So it is not immutable BLE OTA DFU Firmware Architecture - H3 Code ",
							" Memory Management  PIC32CXBZ2 / WBZ451 family of devices has enough Embedded Flash memory to hold the new upgradable OTA image until new image is authenticated The image is received in blocks over BLE link If the image is encrypted will be decrypted and stored in Embedded Flash Slot1 Once the complete image is received image is validated for signature Then the device reset will trigger the bootloader in Boot Flash region to load the image from Slot1 to Slot0 Now the new firmware starts executing Here is the memory split for PIC32CXBZ2 / WBZ451 embedded Flash for OTA DFU: Memory Split for DFU The above memory split is handled in linker script as shown below: #ifndef PDS_LENGTH #define PDS_LENGTH 0x4000 #endif #define ROM_BASE_ADDR 0x01000000 #define METADATA_HEADER_SIZE 0x200 #define SLOT0_BASE_ADDR ROM_BASE_ADDR #define SLOT1_BASE_ADDR 0x01080000 #ifndef ROM_ORIGIN1 #define ROM_ORIGIN1 SLOT0_BASE_ADDR + METADATA_HEADER_SIZE #endif #ifndef ROM_LENGTH1 #define ROM_LENGTH1 (SLOT1_BASE_ADDR - SLOT0_BASE_ADDR - PDS_LENGTH - METADATA_HEADER_SIZE) #elif (ROM_LENGTH1 0x100000) #error ROM_LENGTH1 is greater than the max size of 0x100000-0x200 #endif #ifndef PDS_ORIGIN #define PDS_ORIGIN (ROM_ORIGIN1 + ROM_LENGTH1) #endif #ifndef ROM_ORIGIN2 # define ROM_ORIGIN2 SLOT1_BASE_ADDR #endif #ifndef ROM_LENGTH2 #define ROM_LENGTH2 0x0080000 #elif (ROM_LENGTH2 0x100000) #error ROM_LENGTH2 is greater than the max size of 0x100000 #endif #ifndef BOOT_ROM_ORIGIN # define BOOT_ROM_ORIGIN 0x0 #endif #ifndef BOOT_ROM_LENGTH # define BOOT_ROM_LENGTH 0x5e00 #elif (BOOT_ROM_LENGTH 0x5e00) # error BOOT_ROM_LENGTH is greater than the max size of 0x5e00 #endif ",
							" Microchip defined BLE OTA DFU Profile The BLE OTA DFU profile is a GATT based profile It is designed to perform device firmware update over the air In general mobile will perform the OTAU client role and the BLE device will be in server role OTAU service is a Microchip’s propriety service with a 16-byte service UUID There shall be only one instance of the OTAS in a device The OTAS shall be instantiated as a «Primary Service» The service Universally Unique Identifier (UUID) value shall be set to «4D434850-253D-46B3-9923-E61B8E8215D7» There are 3 characteristics defined under the service: Characteristic Name Universally Unique Identifier (UUID) Properties Permissions OTA Feature 4D434850-22E4-4246-AF03-0C4A2F906358 Read Encryption required OTA Data 4D434850-34D9-40A6-BA7E-56F57C8CD478 WriteWithoutResponse Notify Encryption required OTA Control Point 4D434850-9327-45DE-8882-C97F39028A76 Write Encryption required Further details on OTAU service and profile can be found in stack documents BLE OTA Profile BLE OTA Service ",
							" BLE OTA DFU Image File Definition #BLE OTA DFU Image File Definition BLE OTA DFU File contains the OTAU header and Upgradable Flash Image as shown in below figure This file is loaded into OTAU Manager (Smart phone/ GATT client) to send to OTAU Target over BLE link BLE OTA DFU Image File Definition • Flash Image: Meta-data Header + Executable Firmware This is Full image content which is programmed in the device Flash Slot1 • Meta-data Header: Flash Image will have a metadata header metadata payload and metadata footer that will give the Bootloader firmware information about where the firmware image is located security decryption information signature sequence number etc Digital signatures ensure the authenticity of the image and integrity of the data in the image A digital signature also ensures that the data within the image has not been modified (preserving integrity) and is intact as it was generated at the source Refer to meta data header format from stack document  • OTAU File Encryption: The executable firmware can be encrypted (This is configurable) Encrypting the image ensures the confidentiality of the data This makes that no unauthorized parties are able to peek at the contents of the image Only the end-device should be able to decrypt the image AES128-CBC method of encryption is used Only the firmware image is encrypted and OTAU Header is not encrypted • BLE OTAU Header: This holds the OTAU File information for BLE OTA DFU Client (Ex: mobile App) to perform OTA DFU procedures This header is not being sent over the air to OTAU Target BLE OTAU Header ◦ Total Header length: 16 bytes ◦ BLE OTAU Header Version (HEADER_VER): 1 byte 0x01: PIC32CXBZ2 / WBZ451 Others: RFU ◦ Flash Image is encrypted or not (FLASH_IMG_ENC): 1 byte 0x00: Firmware Image is not encrypted 0x01: Firmware Image is encrypted by AES-CBC method Others: RFU ◦ Checksum : 2 bytes Checksum value of full OTAU file ◦ Flash Image ID (FLASH_IMG_ID): 4 byte Identity number of Flash Image ◦ Flash Image Revision/version (FLASH_IMG_REV): 4 byte ◦ OTAU File Type (FILE_TYPE): 1 Byte 0x01: BLE OTAU File 0x02: BLE+Zigbee Combo OTAU File Others: RFU ◦ Reserved: 3 byte OTA file is bin file which can be generated from MPLABX Tools environment as shown below The detail steps for image generation is explained later • BLE OTA Header and Encryption Key Configuration: BLE OTA Header and Encryption Key Configuration in MPLABX • Meta-data Header Configuration: Meta-data Header Configuration in MPLABX ",
							" BLE OTA DFU Image Distribution Procedure Step 1: Encrypted and Signed BLE OTAU bin File generation using signature and OTA configurator from MPLABX Tools device properties Place the OTAU file in OTAU manager Step 2: Transfer the OTAU Flash image over BLE OTA profile/service to OTAU Target Step 3: Image is decrypted using AES Key in Target and stored in Embedded Flash Slot1 Step 4: Once the complete image is received the device is reset Bootloader will copy new image from Slot1 to Slot0 after image authentication is done BLE OTA DFU Image Distribution Procedure ",
							" BLE OTA DFU Implementation Follow the below steps to add the BLE OTA DFU functionality in any of the Microchip BLE application ",
							" MCC Component and Code Generation Pre-requisite Open any BLE application based on MCC (Example project/ Custom created project) Launch MPLABx Code Configurator (MCC) MPLABx Code Configurator Pull-in MCC Components The below steps explains the components/configurations needed for OTA functionality alone Click on \"+\" symbol \"BLE OTA APP SERVICE\" component from \"Device Resources\" of MCC to project graph When the component is added the dependent components also getting added automatically Accept Dependencies or satisfiers select \"Yes\" inorder to add the dependent components  Configure \"BLE OTA APP SERVICE\" component as below based on the need   Enable Flash Image ID - This option checks for Image ID If this option is enabled the upgradable image should have the same ID of current image only then OTA upgrade procedure will happen Use the same value as in BLE OTA DFU bin file generation configuration as shown below  Enable Image Decryption - If the upgradable image is secured (encrypted using AES128 CBC) this configuration has to be enabled to do decryption of the received image The AES Key should match with the Key in BLE OTA DFU bin file generation configuration as shown below        When the Image decryption option is enabled in the above step the dependent crypto components will get added (if not already present in project graph) Accept Dependencies or satisfiers select \"Yes\" in order to add the dependent components Verify the below configurations: wolfCrypto Library component - AES-CBC mode is enabled  System component - AES Hardware engine clock is enabled   Verify Configurations All the required configurations are automatically done when the \"BLE OTA APP SERVICE\" component is added Verify if the Project Graph window has all the expected MCC configurations  BLE OTA profile and OTA Service Components - Enable Server Role This module generates the code needed for MCHP defined BLE OTA profile and service           BLE_Stack component - DFU Module enable - This module generates the code needed for device firmware upgrade middleware for writing the OTA image into Embedded Flash      BLE_Stack component - Advertising and Scan data payload is configured for manufacturer specific service UUID and local name BLE OTA Microchip Data (MBD) mobile app expects service UUID as \"0xFEDA\" to filter the devices    FreeRTOS stack size - The minimum stack size required by OTA feature is 3584 bytes For example if the original stack size needed for user application is 1024 bytes then set the total stack size as 1024 + 3584 = 4608 bytes      Bootloader Services component - This component generates the supporting linker file and MPLABX script needed for Upgradable image bin file generation Also the crypto API's in bootloader section is called to verify the authenticity (signature verification) of the received image before performing device reset         App Timer Service component - The BLE OTA procedure requires error handling and initializing the state in case of failure in receiving the image There are 2 software timers based on FreeRTOS systick is used APP_TIMER_OTA_TIMEOUT for error handling APP_TIMER_OTA_REBOOT for resetting the device after successful image reception      RCON component - As mentioned above APP_TIMER_OTA_REBOOT timer is used for resetting the device after successful image reception Device reset is performed using SW reset in RCON module    DIS BLE Service - Device Info Service is BT SIG defined service This service can be used to hold the firmware version When upgrading the Image OTAU manager gets the current running image version OTA server in device can use firmware version from DIS and send to OTAU manager Using the FW from DIS is just optional   If DIS is not needed for customer application DIS component can be removed and the below code for sending firmware version should be modified   Generate Code Generate Code by Clicking on \" Generate \" button Files and Routines Automatically generated by MCC After generating the code from MCC tool by clicking Generate button below is the project folder structure ",
							" OTA Application Development Compile MCC auto generated project Compile the MCC auto generated project as below Addressing the mandatory error (if not already done): User action required in app_user_edits c Follow the steps mentioned in the note and do the necessary changes Then comment the #error message as below Call BLE OTA Init function in \"app c\" and add the include file APP_OTA_HDL_Init(); #include \"app_ota/app_ota_handler h\" Call BLE OTA event handler function in \"app_ble/app_otaps_handler c\" APP_OTA_EvtHandler(p_event); #include \" /app_ota/app_ota_handler h\" Uncomment timer message ID's in \"app_timer/app_timer c\" needed for OTA error handling and reboot timer When the timer is fired the related message is posted in freeRTOS application task queue Define the timer message ID's in APP_MsgId_T structure in \"app h\" APP_TIMER_OTA_TIMEOUT_MSG APP_TIMER_OTA_REBOOT_MSG Call OTA timer handlers in APP_Tasks() in \"app c\" else if(p_appMsg- msgId == APP_TIMER_OTA_TIMEOUT_MSG) { APP_OTA_Timeout_Handler(); } else if(p_appMsg- msgId== APP_TIMER_OTA_REBOOT_MSG) { APP_OTA_Reboot_Handler(); } Call DIS service Init function in \"app c\" and add the include file BLE_DIS_Add(); #include \"ble_dis/ble_dis h\" Call BLE gap connected/disconnected event handler in \"app_ble/app_ble_handler c\" app_ble_conn_handler c handles the events and also restarts the Advertising when disconnected APP_BleGapConnEvtHandler(p_event); #include \" /app_ble_conn_handler h\" If the \"Standby Sleep mode\" low power functionality is enabled in the application during the OTA upgrade procedues it is required to disable the device entering into sleep mode Add the below check in app_idle_task() when the BT_SYS_EnterSleepMode() is called if (APP_OTA_HDL_GetOTAMode() = APP_OTA_MODE_OTA) BT_SYS_EnterSleepMode(RTC_Timer32FrequencyGet() RTC_Timer32CounterGet()); Compile the project for no errors API Documentation Reference: OTA Profile Middleware API's OTA Application level API's ",
							" Project Properties Configuration for Current/Running Firmware By following the previous steps the BLE OTA capability is added into application project Referring to Memory management this belongs to \"Firmware\" in Slot0 section Metatdata header and \"Bootloader\" has to be added into this project to make as working project with OTA capability to receive new upgradable image over BLE link MPLABX Tools environment allows to configure and append the Metadata header into application image The needed script and sample private key pem files are added into project folder ( X) when the OTA code was generated from MCC Note: Before proceeding to below steps close the OTA application project and reopen the project This step is mandatory for \"SignFirmware\" and \"OTA\" bin generation MPLABX script to be loaded into project environment Right click on the project - Properties SignFirmware - Adds Metadata header into application image Refer to Meta-data Header Configuration for more details on header format There are configurable parameters like Firmware Rev (version) authentication method and manufacturer ID Configure as per requirement     Step1: \"Firmware Rev\" - Firmware version of current running firmware This should be same as version in DIS service    Step2:\"Auth Method\" - There are 3 Supported authenticated methods   Signature validation (ECDSA256-SHA256) – most secure and data integrity check Signature is encrypted using ECDSA private key 256-bit ECDSA Public key to be programmed in device to do signature decryption openssl (example commands: https://techdocs akamai com/iot-token-access-control/docs/generate-jwt-ecdsa-keys) is one of the open tools to generate ECDSA public/private key pair Sample private key is available in project folder X Public key is input in Bootloader project    Hash validation (SHA-256) – less security and data integrity check    No validation (None) – no security no integrity check     Make sure to keep \"Sequence number\" as non-zero value and not 0xFFFFFFFF  Bootloader - Standalone Bootloader project is available in bootloader folder of application GIT repo The bootloader code stays in Boot Flash section The bootloader project can be added as loadable project into OTA project When the OTA project is build unified image with Bootloader+Metadata Header+Firmware will be generated Add the loadable project/loadable file (bootloader hex) into OTA project as shown below After doing the above steps click on \"Apply\" then \"OK\" to take the changes into effect ",
							" Unified Image Generation Compile the project for no errors MPLABX generated hex image will be available in project production folder dist default production There are 3 new images created as an outcome of \"SignFirmware\" MPLABX script These images are the valid images which has the metadata header appended signed unified hex - This is signed unified image along with bootloader This is the current image to be programmed on the device  signed hex - This image is signed image without bootloader This does not work if bootloader is not present on the device    signed bin - This is upgradable image which can be sent over serial DFU Follow the steps mentioned in DFU over serial if want to upgrade the device using serial interface     ",
							" Programming the Current Application Image using MPLABX IDE Build the project after doing all the above changes and program on Curiosity board  Now the device (OTAU Target) is running the application with OTA capability and able to be upgraded using OTAU manager like mobile phone ",
							" Upgradable image bin file generation Referring to Project Properties Configuration for Current image \"SignFirmware\" and \"OTA\" bin generation MPLABX script is added into OTA project \"OTA\" window in project properties is used for OTA DFU image generation  After making the new upgrdabe application keep the new upgradable image version number not same as current running image version The version number has to be taken care in DIS Service in new firmware as well as \"Firmware Rev\" in \"SignFirmware\" window For example new image Firmware Rev is chosen as 1 0 0 1 and same in DIS Firmware version in the project   Follow step 1 in Project Properties Configuration for Current image to open \"SignFirmware\" properties window  Change the \"Firmware Rev\" and then click on \"Apply\"   Compile the project     Follow step 1 in Project Properties Configuration for Current image to open \"OTA\" properties window  \"OTA\" window has few configurations       Output File Name - Name of the image    Output File Encryption - Image is encrypted or plain image    Output File Type - Choose \"BLE OTA File\" type for BLE based OTAU    Flash Image ID - Refer to Enable Flash Image ID for details    After the configurations click on \"Create OTA File\" The Upgradable bin image with selected \"Output File Name\" will be created in X folder This is the image stored in OTAU Manager to send to OTAU Target    ",
							" BLE OTA DFU Demo The below BLE OTA demo steps are common for any application implementing OTA functionality BLE sensor application is the sample project which implements OTA functioanlity as explained in the above steps The current image (ble_sensor X production signed unified_gpiobased hex or ble_sensor X production signed unified_timerbased hex) with OTA capability and new upgrdable bin (ble_sensor_1 0 0 1_enc_ota bin) is also available in ble advanced_applications ble_sensor precompiled_hex for your reference Hardware Required: Tool Qty  WBZ451 Curiosity Board 1 Micro USB cable 1 Android/iOS Mobile 1 Smartphone App: Microchip Bluetooth Data (MBD) iOS/Android app available in stores  Demo steps:   To perform the OTAU the upgradable firmware bin file created in \" Upgradable image bin file generation \" to be stored into MBD app Send the upgrdable bin file to your mail Follow the below screenshots to store the image received on mail into MBD app  iOS Mobile:            Android Mobile:          Turn on mobile Bluetooth and select “OTA DFU\" tab of Microchip Bluetooth Data App on the mobile device    Power On the OTA capable target device ( PIC32CXBZ2 / WBZ451 ) which was programmed in \" Programming the Application using MPLABX IDE \" Device will be advertising Click on \"SCAN\" button in mobile app and the device be visible in scanned list  Click on intended device from the scanned list Mobile app will now get connected with OTA Target device \"Connected\" message will appear for a short while  Click the ‘Select Image’ option to choose the available firmware file    The OTAU firmware image file copied in the step 1 will be visible on screen Click on that image    After confirming the FW version press OK button  Firmware update will be initiated and the progress will be shown in mobile app The process would take few seconds  Once the complete image is transferred \"OTA Update successfully\" status will be shown in mobile app Click on \"OK\" and then device will perform authentication of the image If validation is successful then system reboot automatically      On bootup device does the authentication of new image in Slot1 and then copies the new image to Slot0 Now the new image will be running from Slot0  To verify whether the running image on the target is newly upgraded image follow steps 2 to 7 and check the current version   ",
							" Microchip Utility Tool Microchip Utility Tool is windows based GUI Tool used for firmware upgrade 1 Introduction Microchip Utility Tool works with Microchip PIC32CXBZ2 / PIC32CX1012BZ25048 device family This Tool Works on windows platform and provides the following functionality This Tool communicates with the device over UART/PKOB4 2 Serial Bootloader Demo 3 Programming using IPECMD exe Image(* hex) file can be programmed into the device ",
							" Introduction Microchip Utility Tool works with Microchip PIC32CXBZ2 / PIC32CX1012BZ25048 device family This Tool Works on windows platform and provides the following functionality This Tool communicates with the device over UART/PKOB4 Download - Microchip Utility tool Serial Bootloader Bootloader enabled device is connected to the tool through Serial Port Device is put in DFU mode and Binary Image(* bin) image is sent through Serial Port frame by frame (payload size = 4096 bytes) Details of this functionality is discussed in Serial Bootloader Section  Programming * hex file using MPLAB IPE Image(* hex) is available in the local drive can be programmed using MPLAB IPE Details are provided in in Programming using MPLAB IPE section Image(* hex) file can be programmed into the device  This Tools has three Tabs (Zigbee OTAU Serial Bootloader and Demo Store) There is a common section related to UART functionality which is visible in all three tabs of the tool Details of each tab of the tool is described below ",
							" Serial Bootloader Demo Boot loading over the serial port is discussed in this section Hardware Requirements One WBZ451 Curiosity Board USB Cables PC Software Requirements MPLABX IDE/IPE MicrochipUtilityTool exe Bootload enabled Firmware Image (ble_sensor signed unified hex BootloaderTimerBasedxxx hex) Bootload enabled binary image (ble_sensor signed_uart bin) Procedure Device can put in DFU Mode by one of the following methods GPIO (SW2 Button Press) Timer Based GPIO Based DFU mode Figure 7: Serial Bootlod Demo Start(GPIO) Program WBZ451 Board with the Image file( ble_sensor signed unified Hex ) Start MicrochipUtilityTool exe Follow the steps mentioned in the above picture Select Serial BootLoader Tab Select Baud Rate as 115200 from the drop-down menu Select the device Serial Port from the drop-down menu Click on Connect/DisConnect Button Press reset button on WBZ451 board UART Rx message appears in the log window Press and hold SW2 and then press and release reset Button on the WBZ451 Board and then release SW2 button WBZ451 Board will enter in DFU mode The following message will appear in the log DFU Now Click on Select File Button and choose ble_sensor signed_uart bin file Click on Send Image Button Image starts downloading into WBZ451 device Progress bar keeping advancing and debug status (Frame: Byte Sent: Time(hh:mm:ss)) keeps updating Figure 8: Serial Bootalod Demo End(GPIO) Wait for Image download to complete (Progress bar = 100% Status= Programming Complete) Press reset button on WBZ451 Board Slot1 is erased and new image is copied from slot0 and start executing new image A new command (0x12) has been added in the Tool This is the last command sent during DFU process If this command is supported in Boot loader code then the WBZ451 device will be automatically booted into new image Timer Based DFU mode Figure 9: Serial Bootlad Demo Start (Timer) Program WBZ451 Board with the Image file (BootloaderTimerBasedxxx hex ) Start MicrochipUtilityTool exe Follow the steps mentioned in the above picture Select Serial BootLoader Tab Select Baud Rate as 115200 from the drop-down menu Select the device Serial Port from the drop-down menu Click on Connect/DisConnect Button Connection status as Connected Click on Select File Button and choose ble_sensor signed_uart bin file Enter (Decimal Integer) Timeout period (step 7) Default is 30 sec Check Timer Click on Send Image Button Tool will wait for WBZ451 device to be in DFU mode for a time period entered in step 7(Default 30 sec) Press Reset Button The device will enter in DFU mode The following message will appear in the log DFU Now Image starts downloading into the WBZ451 device Progress bar keeping advancing and debug status (Frame: Byte Sent: Time(hh:mm:ss)) keeps updating Figure 10: Serial Bootoad Demo End (Timer) Wait for Image download to complete (Progress bar = 100% Status= Programming Complete) The device will automatically boot into new image Summary Frame size = 4096 bytes Image (size = 161920 bytes) takes 16 sec to transmit Default Timeout (30 sec) can be changed in the tool Timer Based Bootloading mode will automatically boots into new image after image download No need to press reset button GPIO based Botloading mode can also boot automatically into new image if a new command (command #0x12) is added into bootloader code ",
							" Programming using IPECMD exe Image(* hex) file can be programmed into the device Hardware Requirements One WBZ451 Curiosity Board USB Cables PC Software Requirements MPLABX IDE/IPE MicrochipUtilityTool exe Procedure Follow the steps shown in the following picture Figure 13: IPECMD Click on Browse File Button and select an image file Selected file will appear in the File Text Box Click on Flash Button Wait for Programming to complete Status: Done Summary MPLABX IPE should be installed on the PC ",
							" Wireless System Services API Wireless system services abstracts out the complexities of a networked system design and simplifies development for common BLE use cases like Over the Air Firmware Update and also provides debug services like BLE Virtual Sniffer ",
							" BLE_OTA BLE OTA service component generates the example code implementation needed for handling BLE OTA application callback and OTA timeouts Refer to OTA Application Development document for the usage of this component API's ",
							" BLE_OTA Enums ",
							" APP_OTA_HDL_Mode_T ",
							" C typedef enum APP_OTA_HDL_Mode_T { APP_OTA_MODE_IDLE APP_OTA_MODE_OTA } APP_OTA_HDL_Mode_T; ",
							" Description Application Status Mode Enumerator Description APP_OTA_MODE_IDLE Application in Idle Mode APP_OTA_MODE_OTA Application in OTA Mode ",
							" BLE_OTA Functions ",
							" APP_OTA_EvtHandler ",
							" C void APP_OTA_EvtHandler(BLE_OTAPS_Event_T *p_event); ",
							" Description OTA handler called from OTA profile from middleware ",
							" Parameters Parameter Description [in] p_event pointer to the structure with OTA Handler BLE_OTAPS_Event_T ",
							" APP_OTA_HDL_Complete ",
							" C void APP_OTA_HDL_Complete(void); ",
							" Description Stops the OTA timeout timer as OTA update is completed ",
							" APP_OTA_HDL_ErrorHandle ",
							" C void APP_OTA_HDL_ErrorHandle(uint16_t OTAHandle); ",
							" Description Handles OTA error ",
							" Parameters Parameter Description [in] OTAHandle Handle Associated with the connection ",
							" APP_OTA_HDL_GetOTAMode ",
							" C APP_OTA_HDL_Mode_T APP_OTA_HDL_GetOTAMode(void); ",
							" Description Gets the application mode ",
							" Return values Return value Description APP_OTA_MODE_IDLE Application in Idle Mode APP_OTA_MODE_OTA Application in OTA Mode ",
							" APP_OTA_HDL_Init ",
							" C void APP_OTA_HDL_Init(void); ",
							" Description OTA initialisation API to init mode and encryption API ",
							" APP_OTA_HDL_Prepare ",
							" C void APP_OTA_HDL_Prepare(uint16_t OTAHandle); ",
							" Description Preparation for OTA procedure ",
							" Parameters Parameter Description [in] OTAHandle Handle Associated with the connection ",
							" APP_OTA_HDL_Reset ",
							" C void APP_OTA_HDL_Reset(void); ",
							" Description Starts the OTA reboot timer to reset the device ",
							" APP_OTA_HDL_SetOTAMode ",
							" C void APP_OTA_HDL_SetOTAMode(APP_OTA_HDL_Mode_T mode); ",
							" Description Sets the application in OTA mode ",
							" Parameters Parameter Description [in] mode Variable to the OTA Application Mode structure APP_OTA_HDL_Mode_T ",
							" APP_OTA_HDL_Start ",
							" C void APP_OTA_HDL_Start(void); ",
							" Description Starts the OTA timeout timer ",
							" APP_OTA_HDL_Updating ",
							" C void APP_OTA_HDL_Updating(void); ",
							" Description Starts the OTA timeout timer while OTA update is in progress ",
							" APP_OTA_Reboot_Handler ",
							" C void APP_OTA_Reboot_Handler(void); ",
							" Description OTA reboot timer handler ",
							" APP_OTA_Timeout_Handler ",
							" C void APP_OTA_Timeout_Handler(void); ",
							" Description OTA timeout handler ",
							" BLE_Conn_Handler The example code implementation for handling BLE connected and disconnected events in BLE GAP event callback from application They are supporting API's and are generated when the BLE OTA service component is added in the project Refer to OTA Application Development document for the usage of the API's ",
							" BLE_Conn_Handler Enums ",
							" APP_BLE_LinkState_T ",
							" C typedef enum APP_BLE_LinkState_T { APP_BLE_STATE_STANDBY APP_BLE_STATE_ADVERTISING APP_BLE_STATE_SCANNING APP_BLE_STATE_CONNECTED APP_BLE_STATE_TOTAL } APP_BLE_LinkState_T; ",
							" Description Enumeration type of BLE state Enumerator Description APP_BLE_STATE_STANDBY Standby state i e not advertising APP_BLE_STATE_ADVERTISING BLE is advertising APP_BLE_STATE_SCANNING BLE is scanning (only for BLE_GAP_ROLE_CENTRAL) APP_BLE_STATE_CONNECTED BLE is connected APP_BLE_STATE_TOTAL Final State ",
							" BLE_Conn_Handler Functions ",
							" APP_BleGapConnEvtHandler ",
							" C void APP_BleGapConnEvtHandler(BLE_GAP_Event_T *p_event); ",
							" Description BLE Stack application GAP Connection event handler ",
							" Events generated BLE_GAP_EVT_CONNECTED Generated when the connection is established Succefully ",
							" Parameters Parameter Description [in] p_event Pointer to the BLE_GAP_Event_T Structure buffer ",
							" APP_GetBleState ",
							" C APP_BLE_LinkState_T APP_GetBleState(void); ",
							" Description Returns BLE link state ",
							" Return values Return value Description APP_BLE_STATE_STANDBY Standby state i e not advertising APP_BLE_STATE_ADVERTISING BLE is advertising APP_BLE_STATE_SCANNING BLE is scanning (only for BLE_GAP_ROLE_CENTRAL) APP_BLE_STATE_CONNECTED BLE is connected ",
							" APP_GetConnHandleByIndex ",
							" C uint16_t APP_GetConnHandleByIndex(uint8_t index); ",
							" Description Gets the connection handle based on index passed ",
							" Parameters Parameter Description [in] index Index Associated with the Connection ",
							" Return values Return value Description uint16_t Connection Handle associated with the Index ",
							" APP_GetConnInfoByConnHandle ",
							" C APP_BLE_ConnList_T *APP_GetConnInfoByConnHandle(uint16_t connHandle); ",
							" Description Returns the connection information based on connection handle ",
							" Parameters Parameter Description [in] connHandle Handle assocaited with the Connection ",
							" Return values Return value Description Info Ble link related Info APP_BLE_ConnList_T Structure ",
							" APP_InitConnList ",
							" C void APP_InitConnList(void); ",
							" Description Initialise connection list ",
							" APP_SetBleState ",
							" C void APP_SetBleState(APP_BLE_LinkState_T state); ",
							" Description Sets BLE link state ",
							" Parameters Parameter Description [in] state BLE Link State APP_BLE_LinkState_T Structure ",
							" BLE_Conn_Handler Structures ",
							" APP_BLE_ConnData_T ",
							" C typedef struct APP_BLE_ConnData_T { uint8_t role; uint16_t handle; BLE_GAP_Addr_T remoteAddr; uint16_t connInterval; uint16_t connLatency; uint16_t supervisionTimeout; } APP_BLE_ConnData_T; ",
							" Description The structure contains the BLE Connection parameters ",
							" Field Documentation Field Description role GAP role see BLE_GAP_ROLE  handle Connection handle associated with this connection remoteAddr See BLE_GAP_Addr_T  connInterval Connection interval used on this connection Range should be BLE_GAP_CP_RANGE  connLatency Slave latency for the connection in terms of number of connection events see BLE_GAP_CP_RANGE  supervisionTimeout Supervision timeout for the LE Link see BLE_GAP_CP_RANGE  ",
							" APP_BLE_ConnList_T ",
							" C typedef struct APP_BLE_ConnList_T { APP_BLE_LinkState_T linkState; APP_BLE_ConnData_T connData; } APP_BLE_ConnList_T; ",
							" Description The structure contains the BLE link related information maintained by the application Layer ",
							" Field Documentation Field Description linkState BLE link state see APP_BLE_LinkState_T connData BLE connection information See APP_BLE_ConnData_T ",
							" APP_TRPS ",
							" APP_TRPS Defines ",
							" Control Response ID status Length ",
							" C #define APP_TRPS_CTRL_RSP_ID_STATUS_LEN 2 ",
							" Description The definition of Maximum length of Control Response ID Status ",
							" Macro Definition Macro Description APP_TRPS_CTRL_RSP_ID_STATUS_LEN Control Response Status Size ",
							" Maximum Control List Size ",
							" C #define APP_TRPS_CTRL_LST_SIZE 2 ",
							" Description The definition of Maximum Size of Control List ",
							" Macro Definition Macro Description APP_TRPS_CTRL_LST_SIZE Control List Size ",
							" APP_TRPS Enums ",
							" APP_TRPS_CTRL_STATUS_CODE_T ",
							" C typedef enum APP_TRPS_CTRL_STATUS_CODE_T { SUCCESS = 0x00 OPCODE_NOT_SUPPORTED = 0x01 INVALID_PARAMETER = 0x02 OPERATION_FAILED = 0x03 }APP_TRPS_CTRL_STATUS_CODE_T; ",
							" Description Application Transparent Service Control Status Code Enumerator Description SUCCESS Control Status Success OPCODE_NOT_SUPPORTED COntrol Opcode Not Supported INVALID_PARAMETER Invalid paramter Value OPERATION_FAILED Operation Failed ",
							" APP_TRPS Functions ",
							" APP_TRPS_ConnEvtProc ",
							" C void APP_TRPS_ConnEvtProc(BLE_GAP_Event_T *p_event); ",
							" Description Process Connection Event specific to BLE Sensor ",
							" Parameters Parameter Description [in] p_event pointer to the BLE GAP Event Buffer BLE_GAP_Event_T ",
							" APP_TRPS_deInit ",
							" C void APP_TRPS_deInit(uint8_t opCode); ",
							" Description DeInitialize App Transparent Service Structure ",
							" Parameters Parameter Description [in] opcode opcode specific to the profile ",
							" APP_TRPS_DiscEvtProc ",
							" C void APP_TRPS_DiscEvtProc(uint16_t connHandle); ",
							" Description Process Disconnection event specific to BLE Sensor ",
							" Parameters Parameter Description [in] connHandle Handle associated with the Connection ",
							" APP_TRPS_EventHandler ",
							" C void APP_TRPS_EventHandler(BLE_TRSPS_Event_T *p_event); ",
							" Description TRPS Event handler called from BLE Stack ",
							" Parameters Parameter Description [in] p_event pointer to the Transparent Event buffer BLE_TRSPS_Event_T ",
							" APP_TRPS_Init ",
							" C uint16_t APP_TRPS_Init(uint8_t opcode APP_TRPS_CmdResp_T *p_cmd APP_TRPS_NotifyData_T *p_ntfy uint8_t cmdRspSize uint8_t ntfySize); ",
							" Description Initialize App Transparent Service Structure ",
							" Parameters Parameter Description [in] opcode opcode specific to the profile [in] p_cmd pointer to the command Response buffer APP_TRPS_CmdResp_T [in] p_ntfy pointer to the Notify Data buffer APP_TRPS_NotifyData_T [in] cmdRspSize Command Response Size [in] ntfySize Notify Size ",
							" Return values Return value Description APP_RES_SUCCESS Successfully initialized Transparent service MBA_RES_FAIL Fail to initialize Transparent service ",
							" APP_TRPS_SendNotification ",
							" C uint16_t APP_TRPS_SendNotification(uint8_t opcode uint8_t ntfyId); ",
							" Description Send Control notify data through TRPS control service ",
							" Parameters Parameter Description [in] opcode opcode specific to the profile [in] ntfyId Control Notify ID ",
							" Return values Return value Description MBA_RES_SUCCESS Execution successfully MBA_RES_FAIL Execution fail MBA_RES_INVALID_PARA Invalid parameters MBA_RES_OOM Out of memory ",
							" APP_TRPS Structures ",
							" APP_TRPS_CmdResp_T ",
							" C typedef struct __attribute__ ((packed)) { uint8_t CmdId; uint8_t RspId; uint8_t Length; uint8_t* p_Payload; uint8_t (*fnPtr) (uint8_t*); } APP_TRPS_CmdResp_T; ",
							" Description The structure contains the information about control command/Resp format ",
							" Field Documentation Field Description CmdId Command ID RspId Response ID Length Command/Response Lengh p_Payload Command/Response Payload (*fnPtr) Pointer to Function ",
							" APP_TRPS_ConnList_T ",
							" C typedef struct APP_TRPS_ConnList_T { uint16_t connHandle; } APP_TRPS_ConnList_T; ",
							" Description The structure contains information about APP transparent connection parameters for recording connection information ",
							" Field Documentation Field Description connHandle Connection handle associated with this connection ",
							" APP_TRPS_Ctrl_T ",
							" C typedef struct { uint8_t opcode; uint8_t cmdRspSize; uint8_t ntfySize; APP_TRPS_CmdResp_T *appTrpsCmdResp; APP_TRPS_NotifyData_T *appTrpsNotify; } APP_TRPS_Ctrl_T; ",
							" Description The structure contains the information about control Cmd resp notify structures ",
							" Field Documentation Field Description opcode opcode cmdRspSize Size of cmd Resp array ntfySize Size of Notfy array appTrpsCmdResp Command Response to structure APP_TRPS_CmdResp_T appTrpsNotify Notify Data to structure APP_TRPS_NotifyData_T ",
							" APP_TRPS_CtrlCmd_T ",
							" C typedef struct __attribute__ ((packed)) { uint8_t Opcode; uint8_t Length; uint8_t ctrlID; uint8_t* p_Payload; } APP_TRPS_CtrlCmd_T; ",
							" Description The structure contains the information about control command format ",
							" Field Documentation Field Description Opcode Control Opcode Length Control command length ctrlID Control control ID p_Payload Control command data pointer ",
							" APP_TRPS_NotifyData_T ",
							" C typedef struct __attribute__ ((packed)) { uint8_t NtfID; uint8_t Length; uint8_t *p_Payload; } APP_TRPS_NotifyData_T; ",
							" Description The structure contains the information about control Notify format ",
							" Field Documentation Field Description NtfID Control Notify ID Length Control Notify length p_Payload Control Notify data pointer ",
							" APP_ERROR_DEF ",
							" APP_ERROR_DEF Defines ",
							" Error Codes Def-1 ",
							" C #define APP_RES_SUCCESS MBA_RES_SUCCESS #define APP_RES_FAIL MBA_RES_FAIL #define APP_RES_OOM MBA_RES_OOM #define APP_RES_INVALID_PARA MBA_RES_INVALID_PARA #define APP_RES_NO_RESOURCE MBA_RES_NO_RESOURCE #define APP_RES_BAD_STATE MBA_RES_BAD_STATE #define APP_RES_PENDING_DUE_TO_SECURITY MBA_RES_PENDING_DUE_TO_SECURITY #define APP_RES_BUSY MBA_RES_BUSY ",
							" Description The definition of App Request Status ",
							" Macro Definition Macro Description APP_RES_SUCCESS Execution successfully APP_RES_FAIL Execution fail APP_RES_OOM Out of memory APP_RES_INVALID_PARA Invalid parameters APP_RES_NO_RESOURCE No resource APP_RES_BAD_STATE Bad State APP_RES_PENDING_DUE_TO_SECURITY Pending the request due to security process APP_RES_BUSY Execution fail due to system is busy ",
							" Error Codes Def-2 ",
							" C #define APP_RES_SUCCESS 0x0000 #define APP_RES_FAIL 0x0001 #define APP_RES_OOM 0x0002 #define APP_RES_INVALID_PARA 0x0003 #define APP_RES_NO_RESOURCE 0x0004 #define APP_RES_BAD_STATE 0x0005 #define APP_RES_PENDING_DUE_TO_SECURITY 0x0006 #define APP_RES_BUSY 0x0007 ",
							" Description The definition of App Request Status ",
							" Macro Definition Macro Description APP_RES_SUCCESS Execution successfully APP_RES_FAIL Execution fail APP_RES_OOM Out of memory APP_RES_INVALID_PARA Invalid parameters APP_RES_NO_RESOURCE No resource APP_RES_BAD_STATE Bad State APP_RES_PENDING_DUE_TO_SECURITY Pending the request due to security process APP_RES_BUSY Execution fail due to system is busy ",
							" APP_Timer ",
							" APP_Timer Defines ",
							" APP_TIMER_TIMEOUT ",
							" C #define APP_TIMER_10MS 0x0A #define APP_TIMER_12MS 0x0C #define APP_TIMER_18MS 0x12 #define APP_TIMER_30MS 0x1E #define APP_TIMER_50MS 0x32 #define APP_TIMER_100MS 0x64 #define APP_TIMER_500MS 0x1F4 #define APP_TIMER_1S 0x3E8 #define APP_TIMER_2S 0x7D0 #define APP_TIMER_3S 0xBB8 #define APP_TIMER_5S 0x1388 #define APP_TIMER_30S 0x7530 ",
							" Description The definition of the timeout value ",
							" Macro Definition Macro Description APP_TIMER_10MS 10ms timer APP_TIMER_12MS 12ms timer APP_TIMER_18MS 18ms timer APP_TIMER_30MS 30ms timer APP_TIMER_50MS 50ms timer APP_TIMER_100MS 100ms timer APP_TIMER_500MS 500ms timer APP_TIMER_1S 1s timer APP_TIMER_2S 2s timer APP_TIMER_3S 3s timer APP_TIMER_5S 5s timer APP_TIMER_30S 30s timer ",
							" APP_Timer Enums ",
							" APP_TIMER_TimerId_T ",
							" C typedef enum APP_TIMER_TimerId_T { APP_TIMER_ID_0 APP_TIMER_ID_1 APP_TIMER_ID_2 APP_TIMER_ID_3 APP_TIMER_ID_4 APP_TIMER_ID_5 APP_TIMER_TOTAL } APP_TIMER_TimerId_T; ",
							" Description The definition of Timer ID ",
							" Note Naming of the Elements provided are default and can be modified inside MCC Configuration Enumerator Description APP_TIMER_ID_0 App Timer ID 0 APP_TIMER_ID_1 App Timer ID 1 APP_TIMER_ID_2 App Timer ID 2 APP_TIMER_ID_3 App Timer ID 3 APP_TIMER_ID_4 App Timer ID 4 APP_TIMER_ID_5 App Timer ID 5 APP_TIMER_TOTAL Total App Timers ",
							" App_Timer Functions ",
							" APP_TIMER_IsTimerExisted ",
							" C bool APP_TIMER_IsTimerExisted(uint8_t timerId); ",
							" Description The function is used to check if a timer exists already ",
							" Parameters Parameter Description [in] timerId Timer ID See APP_TIMER_TimerId_T  ",
							" Return values Return value Description true This timer exites already false This timer doesn't exist ",
							" APP_TIMER_ResetTimer ",
							" C uint16_t APP_TIMER_ResetTimer(uint8_t timerId); ",
							" Description The function is used to re-start a timer Not available if the timer is one-shot and it has been expired ",
							" Parameters Parameter Description [in] timerId Timer ID See APP_TIMER_TimerId_T  ",
							" Return values Return value Description APP_RES_SUCCESS Reset a timer successfully APP_RES_FAIL Failed to reset the timer APP_RES_INVALID_PARA The timerId doesn't exist ",
							" APP_TIMER_SetTimer ",
							" C uint16_t APP_TIMER_SetTimer(uint8_t timerId uint32_t timeout bool isPeriodicTimer); ",
							" Description The function is used to set and start a timer ",
							" Parameters Parameter Description [in] timerId Timer ID See APP_TIMER_TimerId_T  [in] timeout Timeout value (unit: ms) [in] isPeriodicTimer Set as true to let the timer expire repeatedly with a frequency set by the timeout parameter Set as false to let the timer be a one-shot timer ",
							" Return values Return value Description APP_RES_SUCCESS Set and start a timer successfully APP_RES_FAIL Failed to start the timer APP_RES_OOM No available memory APP_RES_NO_RESOURCE Failed to create a new timer ",
							" APP_TIMER_StopTimer ",
							" C uint16_t APP_TIMER_StopTimer(uint8_t timerId); ",
							" Description The function is used to stop a timer ",
							" Parameters Parameter Description [in] timerId Timer ID See APP_TIMER_TimerId_T  ",
							" Return values Return value Description APP_RES_SUCCESS Stop a timer successfully APP_RES_FAIL Failed to stop the timer APP_RES_INVALID_PARA The timerId doesn't exist ",
							" Support Documentation This section has documentation that is generic and used as supporting document with our application example documentation ",
							"  User Action This document explains to users the code edits that are needed to be made after a user does code generation using MPLAB Code Configurator Developers are required to call API - app_idle_task() in vApplicationIdleHook() This is required to enable periodic Persistent Data Storage RF calibration Persistant Data Storage provides means for storing data in non-volatile memory(Flash) User application and stack parameters like peer connection etc are saved IDLE task is set to execute at the lowest priority in FreeRtos Users will be prompted to call app_idle_task() and app_idle_updateRtcCnt(RTC_Timer32CounterGet()) when they compile/build the project with a compile error action required to be taken users are required to open freertos_hooks c file and add #include \"definitions h\" users are required to open freertos_hooks c file and add API app_idle_task() users are required to comment out #error in app_user_edits c file Initiate build and user will be able to build successfully Note: User action is only required for the first time code gets generated Additional User Action when Low Power is enabled Developers are required to call app_idle_updateRtcCnt(RTC_Timer32CounterGet()) in vApplicationTickHook() This API call is used to compensate for FreeRTOSTimer when in sleep mode users are required to open freertos_hooks c file and add API app_idle_updateRtcCnt(RTC_Timer32CounterGet()) ",
							" MPLAB Code Configurator(MCC) Code Generation Generate code Select Generate Merge Strategy Understanding MCC Merge Window Tip: if a user wants to maintain the modifications made for their application code development they should select \"Close\" the merge window ",
							" Import existing App Example Configuration Users who want to implement a similar application based on the existing application examples provided by Microchip can choose to import the configuration so that they srart from a known good configuration Create a new MPLAB MCC Harmony Project Select the MPLAB Harmony option Select Finish Select Harmony Framework Default project graph will be loaded Close the MPLAB Code Configurator by clicking on the MCC option in IDE User should now overwrite the mc3 file created for the new MPLAB MCC Harmony Project (in step 1) with the mc3 file of the application example of their choice provided by Microchip For example we will now overwrite the mc3 file (created with the new MPLAB MCC Harmony Project)with mc3 file created for legacy advertisement application Reopen MCC to see if project graph has imported the components and the respective configuration for these components as expected ",
							" Microchip Information ",
							" The Microchip Website  Microchip provides online support via our website at This website is used to make files and information easily available to customers Some of the content available includes:   Product Support – Data sheets and errata application notes and sample programs design resources user’s guides and hardware support documents latest software releases and archived software  General Technical Support – Frequently Asked Questions (FAQs) technical support requests online discussion groups Microchip design partner program member listing  Business of Microchip – Product selector and ordering guides latest Microchip press releases listing of seminars and events listings of Microchip sales offices distributors and factory representatives   ",
							" Product Change Notification Service  Microchip’s product change notification service helps keep customers current on Microchip products Subscribers will receive email notification whenever there are changes updates revisions or errata related to a specified product family or development tool of interest  To register go to and follow the registration instructions  ",
							" Customer Support  Users of Microchip products can receive assistance through several channels:   Distributor or Representative  Local Sales Office  Embedded Solutions Engineer (ESE)  Technical Support   Customers should contact their distributor representative or ESE for support Local sales offices are also available to help customers A listing of sales offices and locations is included in this document  Technical support is available through the website at:  ",
							" Microchip Devices Code Protection Feature  Note the following details of the code protection feature on Microchip products:   Microchip products meet the specifications contained in their particular Microchip Data Sheet  Microchip believes that its family of products is secure when used in the intended manner within operating specifications and under normal conditions  Microchip values and aggressively protects its intellectual property rights Attempts to breach the code protection features of Microchip product is strictly prohibited and may violate the Digital Millennium Copyright Act  Neither Microchip nor any other semiconductor manufacturer can guarantee the security of its code Code protection does not mean that we are guaranteeing the product is “unbreakable” Code protection is constantly evolving Microchip is committed to continuously improving the code protection features of our products   ",
							" Legal Notice  This publication and the information herein may be used only with Microchip products including to design test and integrate Microchip products with your application Use of this information in any other manner violates these terms Information regarding device applications is provided only for your convenience and may be superseded by updates It is your responsibility to ensure that your application meets with your specifications Contact your local Microchip sales office for additional support or obtain additional support at   THIS INFORMATION IS PROVIDED BY MICROCHIP \"AS IS\" MICROCHIP MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND WHETHER EXPRESS OR IMPLIED WRITTEN OR ORAL STATUTORY OR OTHERWISE RELATED TO THE INFORMATION INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE OR WARRANTIES RELATED TO ITS CONDITION QUALITY OR PERFORMANCE  IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT SPECIAL PUNITIVE INCIDENTAL OR CONSEQUENTIAL LOSS DAMAGE COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE INFORMATION OR ITS USE HOWEVER CAUSED EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE TO THE FULLEST EXTENT ALLOWED BY LAW MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THE INFORMATION OR ITS USE WILL NOT EXCEED THE AMOUNT OF FEES IF ANY THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THE INFORMATION  Use of Microchip devices in life support and/or safety applications is entirely at the buyer's risk and the buyer agrees to defend indemnify and hold harmless Microchip from any and all damages claims suits or expenses resulting from such use No licenses are conveyed implicitly or otherwise under any Microchip intellectual property rights unless otherwise stated  ",
							" Trademarks  The Microchip name and logo the Microchip logo Adaptec AVR AVR logo AVR Freaks BesTime BitCloud CryptoMemory CryptoRF dsPIC flexPWR HELDO IGLOO JukeBlox KeeLoq Kleer LANCheck LinkMD maXStylus maXTouch MediaLB megaAVR Microsemi Microsemi logo MOST MOST logo MPLAB OptoLyzer PIC picoPower PICSTART PIC32 logo PolarFire Prochip Designer QTouch SAM-BA SenGenuity SpyNIC SST SST Logo SuperFlash Symmetricom SyncServer Tachyon TimeSource tinyAVR UNI/O Vectron and XMEGA are registered trademarks of Microchip Technology Incorporated in the U S A and other countries  AgileSwitch APT ClockWorks The Embedded Control Solutions Company EtherSynch Flashtec Hyper Speed Control HyperLight Load Libero motorBench mTouch Powermite 3 Precision Edge ProASIC ProASIC Plus ProASIC Plus logo Quiet- Wire SmartFusion SyncWorld Temux TimeCesium TimeHub TimePictra TimeProvider TrueTime and ZL are registered trademarks of Microchip Technology Incorporated in the U S A  Adjacent Key Suppression AKS Analog-for-the-Digital Age Any Capacitor AnyIn AnyOut Augmented Switching BlueSky BodyCom Clockstudio CodeGuard CryptoAuthentication CryptoAutomotive CryptoCompanion CryptoController dsPICDEM dsPICDEM net Dynamic Average Matching DAM ECAN Espresso T1S EtherGREEN GridTime IdealBridge In-Circuit Serial Programming ICSP INICnet Intelligent Paralleling IntelliMOS Inter-Chip Connectivity JitterBlocker Knob-on-Display KoD maxCrypto maxView memBrain Mindi MiWi MPASM MPF MPLAB Certified logo MPLIB MPLINK MultiTRAK NetDetach Omniscient Code Generation PICDEM PICDEM net PICkit PICtail PowerSmart PureSilicon QMatrix REAL ICE Ripple Blocker RTAX RTG4 SAM-ICE Serial Quad I/O simpleMAP SimpliPHY SmartBuffer SmartHLS SMART-I S storClad SQI SuperSwitcher SuperSwitcher II Switchtec SynchroPHY Total Endurance Trusted Time TSHARC USBCheck VariSense VectorBlox VeriPHY ViewSpan WiperLock XpressConnect and ZENA are trademarks of Microchip Technology Incorporated in the U S A and other countries  SQTP is a service mark of Microchip Technology Incorporated in the U S A  The Adaptec logo Frequency on Demand Silicon Storage Technology and Symmcom are registered trademarks of Microchip Technology Inc in other countries  GestIC is a registered trademark of Microchip Technology Germany II GmbH Co KG a subsidiary of Microchip Technology Inc in other countries  All other trademarks mentioned herein are property of their respective companies  © Microchip Technology Incorporated and its subsidiaries All Rights Reserved  ISBN:  ",
							" Quality Management System   For information regarding Microchip’s Quality Management Systems please visit    ",
							" Worldwide Sales and Service          AMERICAS  ASIA/PACIFIC  ASIA/PACIFIC  EUROPE       Corporate Office  2355 West Chandler Blvd  Chandler AZ 85224-6199  Tel: 480-792-7200  Fax: 480-792-7277  Technical Support:   Web Address:   Atlanta  Duluth GA  Tel: 678-957-9614  Fax: 678-957-1455  Austin TX  Tel: 512-257-3370  Boston  Westborough MA  Tel: 774-760-0087  Fax: 774-760-0088  Chicago  Itasca IL  Tel: 630-285-0071  Fax: 630-285-0075  Dallas  Addison TX  Tel: 972-818-7423  Fax: 972-818-2924  Detroit  Novi MI  Tel: 248-848-4000  Houston TX  Tel: 281-894-5983  Indianapolis  Noblesville IN  Tel: 317-773-8323  Fax: 317-773-5453  Tel: 317-536-2380  Los Angeles  Mission Viejo CA  Tel: 949-462-9523  Fax: 949-462-9608  Tel: 951-273-7800  Raleigh NC  Tel: 919-844-7510  New York NY  Tel: 631-435-6000  San Jose CA  Tel: 408-735-9110  Tel: 408-436-4270  Canada - Toronto  Tel: 905-695-1980  Fax: 905-695-2078    Australia - Sydney  Tel: 61-2-9868-6733  China - Beijing  Tel: 86-10-8569-7000  China - Chengdu  Tel: 86-28-8665-5511  China - Chongqing  Tel: 86-23-8980-9588  China - Dongguan  Tel: 86-769-8702-9880  China - Guangzhou  Tel: 86-20-8755-8029  China - Hangzhou  Tel: 86-571-8792-8115  China - Hong Kong SAR  Tel: 852-2943-5100  China - Nanjing  Tel: 86-25-8473-2460  China - Qingdao  Tel: 86-532-8502-7355  China - Shanghai  Tel: 86-21-3326-8000  China - Shenyang  Tel: 86-24-2334-2829  China - Shenzhen  Tel: 86-755-8864-2200  China - Suzhou  Tel: 86-186-6233-1526  China - Wuhan  Tel: 86-27-5980-5300  China - Xian  Tel: 86-29-8833-7252  China - Xiamen  Tel: 86-592-2388138  China - Zhuhai  Tel: 86-756-3210040    India - Bangalore  Tel: 91-80-3090-4444  India - New Delhi  Tel: 91-11-4160-8631  India - Pune  Tel: 91-20-4121-0141  Japan - Osaka  Tel: 81-6-6152-7160  Japan - Tokyo  Tel: 81-3-6880- 3770  Korea - Daegu  Tel: 82-53-744-4301  Korea - Seoul  Tel: 82-2-554-7200  Malaysia - Kuala Lumpur  Tel: 60-3-7651-7906  Malaysia - Penang  Tel: 60-4-227-8870  Philippines - Manila  Tel: 63-2-634-9065  Singapore  Tel: 65-6334-8870  Taiwan - Hsin Chu  Tel: 886-3-577-8366  Taiwan - Kaohsiung  Tel: 886-7-213-7830  Taiwan - Taipei  Tel: 886-2-2508-8600  Thailand - Bangkok  Tel: 66-2-694-1351  Vietnam - Ho Chi Minh  Tel: 84-28-5448-2100    Austria - Wels  Tel: 43-7242-2244-39  Fax: 43-7242-2244-393  Denmark - Copenhagen  Tel: 45-4485-5910  Fax: 45-4485-2829  Finland - Espoo  Tel: 358-9-4520-820  France - Paris  Tel: 33-1-69-53-63-20  Fax: 33-1-69-30-90-79  Germany - Garching  Tel: 49-8931-9700  Germany - Haan  Tel: 49-2129-3766400  Germany - Heilbronn  Tel: 49-7131-72400  Germany - Karlsruhe  Tel: 49-721-625370  Germany - Munich  Tel: 49-89-627-144-0  Fax: 49-89-627-144-44  Germany - Rosenheim  Tel: 49-8031-354-560  Israel - Ra’anana  Tel: 972-9-744-7705  Italy - Milan  Tel: 39-0331-742611  Fax: 39-0331-466781  Italy - Padova  Tel: 39-049-7625286  Netherlands - Drunen  Tel: 31-416-690399  Fax: 31-416-690340  Norway - Trondheim  Tel: 47-72884388  Poland - Warsaw  Tel: 48-22-3325737  Romania - Bucharest  Tel: 40-21-407-87-50  Spain - Madrid  Tel: 34-91-708-08-90  Fax: 34-91-708-08-91  Sweden - Gothenberg  Tel: 46-31-704-60-40  Sweden - Stockholm  Tel: 46-8-5090-4654  UK - Wokingham  Tel: 44-118-921-5800  Fax: 44-118-921-5820       "];

